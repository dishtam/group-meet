(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const debug_1 = require("debug");
const LIB_NAME = 'awaitqueue';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(LIB_NAME);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;

},{"debug":5}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
const Logger_1 = require("./Logger");
const logger = new Logger_1.Logger();
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */
class AwaitQueueStoppedError extends Error {
    constructor(message) {
        super(message ?? 'AwaitQueue stopped');
        this.name = 'AwaitQueueStoppedError';
        // @ts-ignore
        if (typeof Error.captureStackTrace === 'function') {
            // @ts-ignore
            Error.captureStackTrace(this, AwaitQueueStoppedError);
        }
    }
}
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */
class AwaitQueueRemovedTaskError extends Error {
    constructor(message) {
        super(message ?? 'AwaitQueue task removed');
        this.name = 'AwaitQueueRemovedTaskError';
        // @ts-ignore
        if (typeof Error.captureStackTrace === 'function') {
            // @ts-ignore
            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
        }
    }
}
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
class AwaitQueue {
    constructor() {
        // Queue of pending tasks (map of PendingTasks indexed by id).
        this.pendingTasks = new Map();
        // Incrementing PendingTask id.
        this.nextTaskId = 0;
        // Whether stop() method is stopping all pending tasks.
        this.stopping = false;
    }
    get size() {
        return this.pendingTasks.size;
    }
    async push(task, name) {
        name = name ?? task.name;
        logger.debug(`push() [name:${name}]`);
        if (typeof task !== 'function') {
            throw new TypeError('given task is not a function');
        }
        if (name) {
            try {
                Object.defineProperty(task, 'name', { value: name });
            }
            catch (error) { }
        }
        return new Promise((resolve, reject) => {
            const pendingTask = {
                id: this.nextTaskId++,
                task: task,
                name: name,
                enqueuedAt: Date.now(),
                executedAt: undefined,
                completed: false,
                resolve: (result) => {
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) {
                        return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`resolving task [name:${pendingTask.name}]`);
                    // Resolve the task with the obtained result.
                    resolve(result);
                    // Execute the next pending task (if any).
                    const [nextPendingTask] = this.pendingTasks.values();
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                        void this.execute(nextPendingTask);
                    }
                },
                reject: (error) => {
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) {
                        return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                    // Reject the task with the obtained error.
                    reject(error);
                    // Execute the next pending task (if any) unless stop() is running.
                    if (!this.stopping) {
                        const [nextPendingTask] = this.pendingTasks.values();
                        // NOTE: During the reject() callback the user app may have interacted
                        // with the queue. For instance, the app may have pushed a task while
                        // the queue was empty so such a task is already being executed. If so,
                        // don't execute it twice.
                        if (nextPendingTask && !nextPendingTask.executedAt) {
                            void this.execute(nextPendingTask);
                        }
                    }
                }
            };
            // Append task to the queue.
            this.pendingTasks.set(pendingTask.id, pendingTask);
            // And execute it if this is the only task in the queue.
            if (this.pendingTasks.size === 1) {
                void this.execute(pendingTask);
            }
        });
    }
    stop() {
        logger.debug('stop()');
        this.stopping = true;
        for (const pendingTask of this.pendingTasks.values()) {
            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new AwaitQueueStoppedError());
        }
        this.stopping = false;
    }
    remove(taskIdx) {
        logger.debug(`remove() [taskIdx:${taskIdx}]`);
        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
        if (!pendingTask) {
            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
        }
        pendingTask.reject(new AwaitQueueRemovedTaskError());
    }
    dump() {
        const now = Date.now();
        let idx = 0;
        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
            idx: idx++,
            task: pendingTask.task,
            name: pendingTask.name,
            enqueuedTime: pendingTask.executedAt
                ? pendingTask.executedAt - pendingTask.enqueuedAt
                : now - pendingTask.enqueuedAt,
            executionTime: pendingTask.executedAt
                ? now - pendingTask.executedAt
                : 0
        }));
    }
    async execute(pendingTask) {
        logger.debug(`execute() [name:${pendingTask.name}]`);
        if (pendingTask.executedAt) {
            throw new Error('task already being executed');
        }
        pendingTask.executedAt = Date.now();
        try {
            const result = await pendingTask.task();
            // Resolve the task with its resolved result (if any).
            pendingTask.resolve(result);
        }
        catch (error) {
            // Reject the task with its rejected error.
            pendingTask.reject(error);
        }
    }
}
exports.AwaitQueue = AwaitQueue;

},{"./Logger":3}],5:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":6,"_process":1}],6:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(' ', ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":66}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
exports.hasCORS = value;

},{}],8:[function(require,module,exports){
"use strict";
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = encode;
exports.decode = decode;
function encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];
function parse(str) {
    if (str.length > 8000) {
        throw "URI too long";
    }
    const src = str, b = str.indexOf('['), e = str.indexOf(']');
    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    let m = re.exec(str || ''), uri = {}, i = 14;
    while (i--) {
        uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
}
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
        names.splice(names.length - 1, 1);
    }
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });
    return data;
}

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBinaryType = exports.globalThisShim = exports.nextTick = void 0;
exports.createCookieJar = createCookieJar;
exports.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
exports.globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();
exports.defaultBinaryType = "arraybuffer";
function createCookieJar() { }

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = exports.Socket = void 0;
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
var socket_js_2 = require("./socket.js");
Object.defineProperty(exports, "SocketWithoutUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithoutUpgrade; } });
Object.defineProperty(exports, "SocketWithUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithUpgrade; } });
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", { enumerable: true, get: function () { return transport_js_1.Transport; } });
Object.defineProperty(exports, "TransportError", { enumerable: true, get: function () { return transport_js_1.TransportError; } });
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", { enumerable: true, get: function () { return index_js_1.transports; } });
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parseuri_js_1.parse; } });
var globals_node_js_1 = require("./globals.node.js");
Object.defineProperty(exports, "nextTick", { enumerable: true, get: function () { return globals_node_js_1.nextTick; } });
var polling_fetch_js_1 = require("./transports/polling-fetch.js");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return polling_fetch_js_1.Fetch; } });
var polling_xhr_node_js_1 = require("./transports/polling-xhr.node.js");
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return polling_xhr_node_js_1.XHR; } });
var polling_xhr_js_1 = require("./transports/polling-xhr.js");
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return polling_xhr_js_1.XHR; } });
var websocket_node_js_1 = require("./transports/websocket.node.js");
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return websocket_node_js_1.WS; } });
var websocket_js_1 = require("./transports/websocket.js");
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return websocket_js_1.WS; } });
var webtransport_js_1 = require("./transports/webtransport.js");
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return webtransport_js_1.WT; } });

},{"./contrib/parseuri.js":9,"./globals.node.js":10,"./socket.js":12,"./transport.js":13,"./transports/index.js":14,"./transports/polling-fetch.js":15,"./transports/polling-xhr.js":16,"./transports/polling-xhr.node.js":16,"./transports/websocket.js":18,"./transports/websocket.node.js":18,"./transports/webtransport.js":19,"./util.js":20}],12:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = void 0;
const index_js_1 = require("./transports/index.js");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const parseuri_js_1 = require("./contrib/parseuri.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const engine_io_parser_1 = require("engine.io-parser");
const globals_node_js_1 = require("./globals.node.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:socket"); // debug()
const withEventListeners = typeof addEventListener === "function" &&
    typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
    // script, so we create one single event listener here which will forward the event to the socket instances
    addEventListener("offline", () => {
        debug("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
    }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
class SocketWithoutUpgrade extends component_emitter_1.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts) {
        super();
        this.binaryType = globals_node_js_1.defaultBinaryType;
        this.writeBuffer = [];
        this._prevBufferLen = 0;
        this._pingInterval = -1;
        this._pingTimeout = -1;
        this._maxPayload = -1;
        /**
         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
         */
        this._pingTimeoutTime = Infinity;
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            const parsedUri = (0, parseuri_js_1.parse)(uri);
            opts.hostname = parsedUri.host;
            opts.secure =
                parsedUri.protocol === "https" || parsedUri.protocol === "wss";
            opts.port = parsedUri.port;
            if (parsedUri.query)
                opts.query = parsedUri.query;
        }
        else if (opts.host) {
            opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = [];
        this._transportsByName = {};
        opts.transports.forEach((t) => {
            const transportName = t.prototype.name;
            this.transports.push(transportName);
            this._transportsByName[transportName] = t;
        });
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024,
            },
            transportOptions: {},
            closeOnBeforeunload: false,
        }, opts);
        this.opts.path =
            this.opts.path.replace(/\/$/, "") +
                (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
            this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
        }
        if (withEventListeners) {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this._beforeunloadEventListener = () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this._beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                debug("adding listener for the 'offline' event");
                this._offlineEventListener = () => {
                    this._onClose("transport close", {
                        description: "network connection lost",
                    });
                };
                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
            }
        }
        if (this.opts.withCredentials) {
            this._cookieJar = (0, globals_node_js_1.createCookieJar)();
        }
        this._open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
        debug('creating transport "%s"', name);
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser_1.protocol;
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port,
        }, this.opts.transportOptions[name]);
        debug("options: %j", opts);
        return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    _open() {
        if (this.transports.length === 0) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        const transportName = this.opts.rememberUpgrade &&
            SocketWithoutUpgrade.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1
            ? "websocket"
            : this.transports[0];
        this.readyState = "opening";
        const transport = this.createTransport(transportName);
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
        debug("setting transport %s", transport.name);
        if (this.transport) {
            debug("clearing existing transport %s", this.transport.name);
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this._onDrain.bind(this))
            .on("packet", this._onPacket.bind(this))
            .on("error", this._onError.bind(this))
            .on("close", (reason) => this._onClose("transport close", reason));
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
        debug("socket open");
        this.readyState = "open";
        SocketWithoutUpgrade.priorWebsocketSuccess =
            "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    _onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this._sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    this._resetPingTimeout();
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this._onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
            debug('packet received with socket readyState "%s"', this.readyState);
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this._pingInterval = data.pingInterval;
        this._pingTimeout = data.pingTimeout;
        this._maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const delay = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + delay;
        this._pingTimeoutTimer = this.setTimeoutFn(() => {
            this._onClose("ping timeout");
        }, delay);
        if (this.opts.autoUnref) {
            this._pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this._prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            const packets = this._getWritablePackets();
            debug("flushing %d packets in socket", packets.length);
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this._prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    _getWritablePackets() {
        const shouldCheckPayloadSize = this._maxPayload &&
            this.transport.name === "polling" &&
            this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for (let i = 0; i < this.writeBuffer.length; i++) {
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += (0, util_js_1.byteLength)(data);
            }
            if (i > 0 && payloadSize > this._maxPayload) {
                debug("only send %d out of %d packets", i, this.writeBuffer.length);
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        debug("payload size is %d (max: %d)", payloadSize, this._maxPayload);
        return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */ _hasPingExpired() {
        if (!this._pingTimeoutTime)
            return true;
        const hasExpired = Date.now() > this._pingTimeoutTime;
        if (hasExpired) {
            debug("throttled timer detected, scheduling connection close");
            this._pingTimeoutTime = 0;
            (0, globals_node_js_1.nextTick)(() => {
                this._onClose("ping timeout");
            }, this.setTimeoutFn);
        }
        return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    send(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    _sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options,
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
        const close = () => {
            this._onClose("forced close");
            debug("socket closing - telling transport to close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    _onError(err) {
        debug("socket error %j", err);
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        if (this.opts.tryAllTransports &&
            this.transports.length > 1 &&
            this.readyState === "opening") {
            debug("trying next transport");
            this.transports.shift();
            return this._open();
        }
        this.emitReserved("error", err);
        this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    _onClose(reason, description) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            debug('socket close with reason: "%s"', reason);
            // clear timers
            this.clearTimeoutFn(this._pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (withEventListeners) {
                if (this._beforeunloadEventListener) {
                    removeEventListener("beforeunload", this._beforeunloadEventListener, false);
                }
                if (this._offlineEventListener) {
                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
                    if (i !== -1) {
                        debug("removing listener for the 'offline' event");
                        OFFLINE_EVENT_LISTENERS.splice(i, 1);
                    }
                }
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this._prevBufferLen = 0;
        }
    }
}
exports.SocketWithoutUpgrade = SocketWithoutUpgrade;
SocketWithoutUpgrade.protocol = engine_io_parser_1.protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
class SocketWithUpgrade extends SocketWithoutUpgrade {
    constructor() {
        super(...arguments);
        this._upgrades = [];
    }
    onOpen() {
        super.onOpen();
        if ("open" === this.readyState && this.opts.upgrade) {
            debug("starting upgrade probes");
            for (let i = 0; i < this._upgrades.length; i++) {
                this._probe(this._upgrades[i]);
            }
        }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    _probe(name) {
        debug('probing transport "%s"', name);
        let transport = this.createTransport(name);
        let failed = false;
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            debug('probe transport "%s" opened', name);
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    debug('probe transport "%s" pong', name);
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    SocketWithoutUpgrade.priorWebsocketSuccess =
                        "websocket" === transport.name;
                    debug('pausing current transport "%s"', this.transport.name);
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        debug("changing transport and sending upgrade packet");
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    debug('probe transport "%s" failed', name);
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err) => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                debug('"%s" works - aborting "%s"', to.name, transport.name);
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this._upgrades.indexOf("webtransport") !== -1 &&
            name !== "webtransport") {
            // favor WebTransport
            this.setTimeoutFn(() => {
                if (!failed) {
                    transport.open();
                }
            }, 200);
        }
        else {
            transport.open();
        }
    }
    onHandshake(data) {
        this._upgrades = this._filterUpgrades(data.upgrades);
        super.onHandshake(data);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    _filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        for (let i = 0; i < upgrades.length; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
exports.SocketWithUpgrade = SocketWithUpgrade;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
class Socket extends SocketWithUpgrade {
    constructor(uri, opts = {}) {
        const o = typeof uri === "object" ? uri : opts;
        if (!o.transports ||
            (o.transports && typeof o.transports[0] === "string")) {
            o.transports = (o.transports || ["polling", "websocket", "webtransport"])
                .map((transportName) => index_js_1.transports[transportName])
                .filter((t) => !!t);
        }
        super(uri, o);
    }
}
exports.Socket = Socket;

},{"./contrib/parseqs.js":8,"./contrib/parseuri.js":9,"./globals.node.js":10,"./transports/index.js":14,"./util.js":20,"@socket.io/component-emitter":2,"debug":21,"engine.io-parser":27}],13:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = exports.TransportError = void 0;
const engine_io_parser_1 = require("engine.io-parser");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:transport"); // debug()
class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
exports.TransportError = TransportError;
class Transport extends component_emitter_1.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
            debug("transport is not open, discarding packets");
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
    createUri(schema, query = {}) {
        return (schema +
            "://" +
            this._hostname() +
            this._port() +
            this.opts.path +
            this._query(query));
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port &&
            ((this.opts.secure && Number(this.opts.port !== 443)) ||
                (!this.opts.secure && Number(this.opts.port) !== 80))) {
            return ":" + this.opts.port;
        }
        else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}
exports.Transport = Transport;

},{"./contrib/parseqs.js":8,"./util.js":20,"@socket.io/component-emitter":2,"debug":21,"engine.io-parser":27}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transports = void 0;
const polling_xhr_node_js_1 = require("./polling-xhr.node.js");
const websocket_node_js_1 = require("./websocket.node.js");
const webtransport_js_1 = require("./webtransport.js");
exports.transports = {
    websocket: websocket_node_js_1.WS,
    webtransport: webtransport_js_1.WT,
    polling: polling_xhr_node_js_1.XHR,
};

},{"./polling-xhr.node.js":16,"./websocket.node.js":18,"./webtransport.js":19}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fetch = void 0;
const polling_js_1 = require("./polling.js");
/**
 * HTTP long-polling based on the built-in `fetch()` method.
 *
 * Usage: browser, Node.js (since v18), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * @see https://caniuse.com/fetch
 * @see https://nodejs.org/api/globals.html#fetch
 */
class Fetch extends polling_js_1.Polling {
    doPoll() {
        this._fetch()
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch read error", res.status, res);
            }
            res.text().then((data) => this.onData(data));
        })
            .catch((err) => {
            this.onError("fetch read error", err);
        });
    }
    doWrite(data, callback) {
        this._fetch(data)
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch write error", res.status, res);
            }
            callback();
        })
            .catch((err) => {
            this.onError("fetch write error", err);
        });
    }
    _fetch(data) {
        var _a;
        const isPost = data !== undefined;
        const headers = new Headers(this.opts.extraHeaders);
        if (isPost) {
            headers.set("content-type", "text/plain;charset=UTF-8");
        }
        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
        return fetch(this.uri(), {
            method: isPost ? "POST" : "GET",
            body: isPost ? data : null,
            headers,
            credentials: this.opts.withCredentials ? "include" : "omit",
        }).then((res) => {
            var _a;
            // @ts-ignore getSetCookie() was added in Node.js v19.7.0
            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
            return res;
        });
    }
}
exports.Fetch = Fetch;

},{"./polling.js":17}],16:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XHR = exports.Request = exports.BaseXHR = void 0;
const polling_js_1 = require("./polling.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("../util.js");
const globals_node_js_1 = require("../globals.node.js");
const has_cors_js_1 = require("../contrib/has-cors.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
function empty() { }
class BaseXHR extends polling_js_1.Polling {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
        }
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
exports.BaseXHR = BaseXHR;
class Request extends component_emitter_1.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(createRequest, uri, opts) {
        super();
        this.createRequest = createRequest;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = undefined !== opts.data ? opts.data : null;
        this._create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    _create() {
        var _a;
        const opts = (0, util_js_1.pick)(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = (this._xhr = this.createRequest(opts));
        try {
            debug("xhr open %s: %s", this._method, this._uri);
            xhr.open(this._method, this._uri, true);
            try {
                if (this._opts.extraHeaders) {
                    // @ts-ignore
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this._opts.extraHeaders) {
                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this._method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this._opts.withCredentials;
            }
            if (this._opts.requestTimeout) {
                xhr.timeout = this._opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
                    // @ts-ignore
                    xhr.getResponseHeader("set-cookie"));
                }
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this._onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            debug("xhr data %s", this._data);
            xhr.send(this._data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this._onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this._index = Request.requestsCount++;
            Request.requests[this._index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
            return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this._xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this._index];
        }
        this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this._cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this._cleanup();
    }
}
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globals_node_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}
const hasXHR2 = (function () {
    const xhr = newRequest({
        xdomain: false,
    });
    return xhr && xhr.responseType !== null;
})();
/**
 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
 *
 * Usage: browser
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
class XHR extends BaseXHR {
    constructor(opts) {
        super(opts);
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd }, this.opts);
        return new Request(newRequest, this.uri(), opts);
    }
}
exports.XHR = XHR;
function newRequest(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new globals_node_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}

},{"../contrib/has-cors.js":7,"../globals.node.js":10,"../util.js":20,"./polling.js":17,"@socket.io/component-emitter":2,"debug":21}],17:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polling = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
class Polling extends transport_js_1.Transport {
    constructor() {
        super(...arguments);
        this._polling = false;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            debug("paused");
            this.readyState = "paused";
            onPause();
        };
        if (this._polling || !this.writable) {
            let total = 0;
            if (this._polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function () {
                    debug("pre-pause polling complete");
                    --total || pause();
                });
            }
            if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function () {
                    debug("pre-pause writing complete");
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    _poll() {
        debug("polling");
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        debug("polling got data %s", data);
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this._polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this._poll();
            }
            else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            debug("writing close packet");
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            debug("transport open - closing");
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug("transport not open - deferring close");
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.Polling = Polling;

},{"../transport.js":13,"../util.js":20,"debug":21,"engine.io-parser":27}],18:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WS = exports.BaseWS = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const globals_node_js_1 = require("../globals.node.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:websocket"); // debug()
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class BaseWS extends transport_js_1.Transport {
    get name() {
        return "websocket";
    }
    doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws = this.createSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    this.doWrite(packet, data);
                }
                catch (e) {
                    debug("websocket closed before onclose event");
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.onerror = () => { };
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.BaseWS = BaseWS;
const WebSocketCtor = globals_node_js_1.globalThisShim.WebSocket || globals_node_js_1.globalThisShim.MozWebSocket;
/**
 * WebSocket transport based on the built-in `WebSocket` object.
 *
 * Usage: browser, Node.js (since v21), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 * @see https://caniuse.com/mdn-api_websocket
 * @see https://nodejs.org/api/globals.html#websocket
 */
class WS extends BaseWS {
    createSocket(uri, protocols, opts) {
        return !isReactNative
            ? protocols
                ? new WebSocketCtor(uri, protocols)
                : new WebSocketCtor(uri)
            : new WebSocketCtor(uri, protocols, opts);
    }
    doWrite(_packet, data) {
        this.ws.send(data);
    }
}
exports.WS = WS;

},{"../globals.node.js":10,"../transport.js":13,"../util.js":20,"debug":21,"engine.io-parser":27}],19:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WT = void 0;
const transport_js_1 = require("../transport.js");
const globals_node_js_1 = require("../globals.node.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:webtransport"); // debug()
/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
class WT extends transport_js_1.Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed
            .then(() => {
            debug("transport closed gracefully");
            this.onClose();
        })
            .catch((err) => {
            debug("transport closed due to %s", err);
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then((stream) => {
                const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
                encoderStream.readable.pipeTo(stream.writable);
                this._writer = encoderStream.writable.getWriter();
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            debug("session is closed");
                            return;
                        }
                        debug("received chunk: %o", value);
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                        debug("an error occurred while reading: %s", err);
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this._writer.write(packet).then(() => this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this._writer.write(packet).then(() => {
                if (lastPacket) {
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}
exports.WT = WT;

},{"../globals.node.js":10,"../transport.js":13,"debug":21,"engine.io-parser":27}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = pick;
exports.installTimerFunctions = installTimerFunctions;
exports.byteLength = byteLength;
exports.randomString = randomString;
const globals_node_js_1 = require("./globals.node.js");
function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globals_node_js_1.globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globals_node_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globals_node_js_1.globalThisShim);
    }
    else {
        obj.setTimeoutFn = globals_node_js_1.globalThisShim.setTimeout.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = globals_node_js_1.globalThisShim.clearTimeout.bind(globals_node_js_1.globalThisShim);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}
/**
 * Generates a random 8-characters string.
 */
function randomString() {
    return (Date.now().toString(36).substring(3) +
        Math.random().toString(36).substring(2, 5));
}

},{"./globals.node.js":10}],21:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":22,"_process":1}],22:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":66}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
exports.ERROR_PACKET = ERROR_PACKET;

},{}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
exports.encode = encode;
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};
exports.decode = decode;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePacket = void 0;
const commons_js_1 = require("./commons.js");
const base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
        };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
        };
};
exports.decodePacket = decodePacket;
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            if (data instanceof Blob) {
                // from WebSocket + binaryType "blob"
                return data;
            }
            else {
                // from HTTP long-polling or WebTransport
                return new Blob([data]);
            }
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) {
                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
    }
};

},{"./commons.js":23,"./contrib/base64-arraybuffer.js":24}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePacket = void 0;
exports.encodePacketToBinary = encodePacketToBinary;
const commons_js_1 = require("./commons.js");
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
        return packet.data.arrayBuffer().then(toArray).then(callback);
    }
    else if (withNativeArrayBuffer &&
        (packet.data instanceof ArrayBuffer || isView(packet.data))) {
        return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
        if (!TEXT_ENCODER) {
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}

},{"./commons.js":23}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
exports.createPacketEncoderStream = createPacketEncoderStream;
exports.createPacketDecoderStream = createPacketDecoderStream;
const encodePacket_js_1 = require("./encodePacket.js");
Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function () { return encodePacket_js_1.encodePacket; } });
const decodePacket_js_1 = require("./decodePacket.js");
Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function () { return decodePacket_js_1.decodePacket; } });
const commons_js_1 = require("./commons.js");
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
exports.encodePayload = encodePayload;
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
    return new TransformStream({
        transform(packet, controller) {
            (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* State.READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(commons_js_1.ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(commons_js_1.ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
exports.protocol = 4;

},{"./commons.js":23,"./decodePacket.js":25,"./encodePacket.js":26}],28:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const debug_1 = __importDefault(require("debug"));
const APP_NAME = 'h264-profile-level-id';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;

},{"debug":5}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
const Logger_1 = require("./Logger");
const logger = new Logger_1.Logger();
/**
 * Supported profiles.
 */
// ESLint absurdly complains about "'Profile' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Profile;
(function (Profile) {
    Profile[Profile["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
    Profile[Profile["Baseline"] = 2] = "Baseline";
    Profile[Profile["Main"] = 3] = "Main";
    Profile[Profile["ConstrainedHigh"] = 4] = "ConstrainedHigh";
    Profile[Profile["High"] = 5] = "High";
    Profile[Profile["PredictiveHigh444"] = 6] = "PredictiveHigh444";
})(Profile || (exports.Profile = Profile = {}));
/**
 * Supported levels.
 */
// ESLint absurdly complains about "'Level' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Level;
(function (Level) {
    Level[Level["L1_b"] = 0] = "L1_b";
    Level[Level["L1"] = 10] = "L1";
    Level[Level["L1_1"] = 11] = "L1_1";
    Level[Level["L1_2"] = 12] = "L1_2";
    Level[Level["L1_3"] = 13] = "L1_3";
    Level[Level["L2"] = 20] = "L2";
    Level[Level["L2_1"] = 21] = "L2_1";
    Level[Level["L2_2"] = 22] = "L2_2";
    Level[Level["L3"] = 30] = "L3";
    Level[Level["L3_1"] = 31] = "L3_1";
    Level[Level["L3_2"] = 32] = "L3_2";
    Level[Level["L4"] = 40] = "L4";
    Level[Level["L4_1"] = 41] = "L4_1";
    Level[Level["L4_2"] = 42] = "L4_2";
    Level[Level["L5"] = 50] = "L5";
    Level[Level["L5_1"] = 51] = "L5_1";
    Level[Level["L5_2"] = 52] = "L5_2";
})(Level || (exports.Level = Level = {}));
/**
 * Represents a parsed h264 profile-level-id value.
 */
class ProfileLevelId {
    constructor(profile, level) {
        this.profile = profile;
        this.level = level;
    }
}
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
const DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */
class BitPattern {
    constructor(str) {
        this.mask = ~byteMaskString('x', str);
        this.masked_value = byteMaskString('1', str);
    }
    isMatch(value) {
        return this.masked_value === (value & this.mask);
    }
}
/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */
class ProfilePattern {
    constructor(profile_idc, profile_iop, profile) {
        this.profile_idc = profile_idc;
        this.profile_iop = profile_iop;
        this.profile = profile;
    }
}
// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
const ProfilePatterns = [
    new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x4D, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline),
    new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline),
    new ProfilePattern(0x4D, new BitPattern('0x0x0000'), Profile.Main),
    new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High),
    new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh),
    new ProfilePattern(0xF4, new BitPattern('00000000'), Profile.PredictiveHigh444)
];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */
function parseProfileLevelId(str) {
    // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
    // flag specifies if level 1b or level 1.1 is used.
    const ConstraintSet3Flag = 0x10;
    // The string should consist of 3 bytes in hexadecimal format.
    if (typeof str !== 'string' || str.length !== 6) {
        return undefined;
    }
    const profile_level_id_numeric = parseInt(str, 16);
    if (profile_level_id_numeric === 0) {
        return undefined;
    }
    // Separate into three bytes.
    const level_idc = (profile_level_id_numeric & 0xFF);
    const profile_iop = (profile_level_id_numeric >> 8) & 0xFF;
    const profile_idc = (profile_level_id_numeric >> 16) & 0xFF;
    // Parse level based on level_idc and constraint set 3 flag.
    let level;
    switch (level_idc) {
        case Level.L1_1:
            {
                level = (profile_iop & ConstraintSet3Flag) !== 0
                    ? Level.L1_b
                    : Level.L1_1;
                break;
            }
        case Level.L1:
        case Level.L1_2:
        case Level.L1_3:
        case Level.L2:
        case Level.L2_1:
        case Level.L2_2:
        case Level.L3:
        case Level.L3_1:
        case Level.L3_2:
        case Level.L4:
        case Level.L4_1:
        case Level.L4_2:
        case Level.L5:
        case Level.L5_1:
        case Level.L5_2:
            {
                level = level_idc;
                break;
            }
        // Unrecognized level_idc.
        default:
            {
                logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
                return undefined;
            }
    }
    // Parse profile_idc/profile_iop into a Profile enum.
    for (const pattern of ProfilePatterns) {
        if (profile_idc === pattern.profile_idc &&
            pattern.profile_iop.isMatch(profile_iop)) {
            return new ProfileLevelId(pattern.profile, level);
        }
    }
    logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
    return undefined;
}
exports.parseProfileLevelId = parseProfileLevelId;
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */
function profileLevelIdToString(profile_level_id) {
    // Handle special case level == 1b.
    if (profile_level_id.level == Level.L1_b) {
        switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline:
                {
                    return '42f00b';
                }
            case Profile.Baseline:
                {
                    return '42100b';
                }
            case Profile.Main:
                {
                    return '4d100b';
                }
            // Level 1_b is not allowed for other profiles.
            default:
                {
                    logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
                    return undefined;
                }
        }
    }
    let profile_idc_iop_string;
    switch (profile_level_id.profile) {
        case Profile.ConstrainedBaseline:
            {
                profile_idc_iop_string = '42e0';
                break;
            }
        case Profile.Baseline:
            {
                profile_idc_iop_string = '4200';
                break;
            }
        case Profile.Main:
            {
                profile_idc_iop_string = '4d00';
                break;
            }
        case Profile.ConstrainedHigh:
            {
                profile_idc_iop_string = '640c';
                break;
            }
        case Profile.High:
            {
                profile_idc_iop_string = '6400';
                break;
            }
        case Profile.PredictiveHigh444:
            {
                profile_idc_iop_string = 'f400';
                break;
            }
        default:
            {
                logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
                return undefined;
            }
    }
    let levelStr = (profile_level_id.level).toString(16);
    if (levelStr.length === 1) {
        levelStr = `0${levelStr}`;
    }
    return `${profile_idc_iop_string}${levelStr}`;
}
exports.profileLevelIdToString = profileLevelIdToString;
/**
 * Returns a human friendly name for the given profile.
 */
function profileToString(profile) {
    switch (profile) {
        case Profile.ConstrainedBaseline:
            {
                return 'ConstrainedBaseline';
            }
        case Profile.Baseline:
            {
                return 'Baseline';
            }
        case Profile.Main:
            {
                return 'Main';
            }
        case Profile.ConstrainedHigh:
            {
                return 'ConstrainedHigh';
            }
        case Profile.High:
            {
                return 'High';
            }
        case Profile.PredictiveHigh444:
            {
                return 'PredictiveHigh444';
            }
        default:
            {
                logger.warn(`profileToString() | unrecognized profile ${profile}`);
                return undefined;
            }
    }
}
exports.profileToString = profileToString;
/**
 * Returns a human friendly name for the given level.
 */
function levelToString(level) {
    switch (level) {
        case Level.L1_b:
            {
                return '1b';
            }
        case Level.L1:
            {
                return '1';
            }
        case Level.L1_1:
            {
                return '1.1';
            }
        case Level.L1_2:
            {
                return '1.2';
            }
        case Level.L1_3:
            {
                return '1.3';
            }
        case Level.L2:
            {
                return '2';
            }
        case Level.L2_1:
            {
                return '2.1';
            }
        case Level.L2_2:
            {
                return '2.2';
            }
        case Level.L3:
            {
                return '3';
            }
        case Level.L3_1:
            {
                return '3.1';
            }
        case Level.L3_2:
            {
                return '3.2';
            }
        case Level.L4:
            {
                return '4';
            }
        case Level.L4_1:
            {
                return '4.1';
            }
        case Level.L4_2:
            {
                return '4.2';
            }
        case Level.L5:
            {
                return '5';
            }
        case Level.L5_1:
            {
                return '5.1';
            }
        case Level.L5_2:
            {
                return '5.2';
            }
        default:
            {
                logger.warn(`levelToString() | unrecognized level ${level}`);
                return undefined;
            }
    }
}
exports.levelToString = levelToString;
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */
function parseSdpProfileLevelId(params = {}) {
    const profile_level_id = params['profile-level-id'];
    return profile_level_id
        ? parseProfileLevelId(profile_level_id)
        : DefaultProfileLevelId;
}
exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 */
function isSameProfile(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    // Compare H264 profiles, but not levels.
    return Boolean(profile_level_id_1 &&
        profile_level_id_2 &&
        profile_level_id_1.profile === profile_level_id_2.profile);
}
exports.isSameProfile = isSameProfile;
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */
function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
    // If both local and remote params do not contain profile-level-id, they are
    // both using the default profile. In this case, don't return anything.
    if (!local_supported_params['profile-level-id'] &&
        !remote_offered_params['profile-level-id']) {
        logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');
        return undefined;
    }
    // Parse profile-level-ids.
    const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
    // The local and remote codec must have valid and equal H264 Profiles.
    if (!local_profile_level_id) {
        throw new TypeError('invalid local_profile_level_id');
    }
    if (!remote_profile_level_id) {
        throw new TypeError('invalid remote_profile_level_id');
    }
    if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
        throw new TypeError('H264 Profile mismatch');
    }
    // Parse level information.
    const level_asymmetry_allowed = (isLevelAsymmetryAllowed(local_supported_params) &&
        isLevelAsymmetryAllowed(remote_offered_params));
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
    // Determine answer level. When level asymmetry is not allowed, level upgrade
    // is not allowed, i.e., the level in the answer must be equal to or lower
    // than the level in the offer.
    const answer_level = level_asymmetry_allowed
        ? local_level
        : min_level;
    logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
    // Return the resulting profile-level-id for the answer parameters.
    return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
}
exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */
function byteMaskString(c, str) {
    return ((Number(str[0] === c) << 7) | (Number(str[1] === c) << 6) |
        (Number(str[2] === c) << 5) | (Number(str[3] === c) << 4) |
        (Number(str[4] === c) << 3) | (Number(str[5] === c) << 2) |
        (Number(str[6] === c) << 1) | (Number(str[7] === c) << 0));
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
    if (a === Level.L1_b) {
        return b !== Level.L1 && b !== Level.L1_b;
    }
    if (b === Level.L1_b) {
        return a !== Level.L1;
    }
    return a < b;
}
function minLevel(a, b) {
    return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed(params = {}) {
    const level_asymmetry_allowed = params['level-asymmetry-allowed'];
    return (level_asymmetry_allowed === true ||
        level_asymmetry_allowed === 1 ||
        level_asymmetry_allowed === '1');
}

},{"./Logger":28}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consumer = void 0;
const Logger_1 = require("./Logger");
const enhancedEvents_1 = require("./enhancedEvents");
const errors_1 = require("./errors");
const logger = new Logger_1.Logger('Consumer');
class Consumer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._producerId = producerId;
        this._rtpReceiver = rtpReceiver;
        this._track = track;
        this._rtpParameters = rtpParameters;
        this._paused = !track.enabled;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        this.handleTrack();
    }
    /**
     * Consumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Associated Producer id.
     */
    get producerId() {
        return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
    get rtpReceiver() {
        return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Consumer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this.destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this.destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return new Promise((resolve, reject) => {
            this.safeEmit('@getstats', resolve, reject);
        });
    }
    /**
     * Pauses receiving media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Consumer closed');
            return;
        }
        if (this._paused) {
            logger.debug('pause() | Consumer is already paused');
            return;
        }
        this._paused = true;
        this._track.enabled = false;
        this.emit('@pause');
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Consumer closed');
            return;
        }
        if (!this._paused) {
            logger.debug('resume() | Consumer is already resumed');
            return;
        }
        this._paused = false;
        this._track.enabled = true;
        this.emit('@resume');
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    handleTrack() {
        this._track.addEventListener('ended', this.onTrackEnded);
    }
    destroyTrack() {
        try {
            this._track.removeEventListener('ended', this.onTrackEnded);
            this._track.stop();
        }
        catch (error) { }
    }
}
exports.Consumer = Consumer;

},{"./Logger":34,"./enhancedEvents":39,"./errors":40}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataConsumer = void 0;
const Logger_1 = require("./Logger");
const enhancedEvents_1 = require("./enhancedEvents");
const logger = new Logger_1.Logger('DataConsumer');
class DataConsumer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._dataProducerId = dataProducerId;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
    }
    /**
     * DataConsumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Associated DataProducer id.
     */
    get dataProducerId() {
        return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
    get binaryType() {
        return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */
    set binaryType(binaryType) {
        this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed) {
                return;
            }
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', (event) => {
            if (this._closed) {
                return;
            }
            let { error } = event;
            if (!error) {
                error = new Error('unknown DataChannel error');
            }
            if (error.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
            // Emit observer event.
            this._observer.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', (event) => {
            if (this._closed) {
                return;
            }
            this.safeEmit('message', event.data);
        });
    }
}
exports.DataConsumer = DataConsumer;

},{"./Logger":34,"./enhancedEvents":39}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataProducer = void 0;
const Logger_1 = require("./Logger");
const enhancedEvents_1 = require("./enhancedEvents");
const errors_1 = require("./errors");
const logger = new Logger_1.Logger('DataProducer');
class DataProducer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, dataChannel, sctpStreamParameters, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
    }
    /**
     * DataProducer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
    get bufferedAmount() {
        return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
    get bufferedAmountLowThreshold() {
        return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */
    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
    send(data) {
        logger.debug('send()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        this._dataChannel.send(data);
    }
    handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed) {
                return;
            }
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', (event) => {
            if (this._closed) {
                return;
            }
            let { error } = event;
            if (!error) {
                error = new Error('unknown DataChannel error');
            }
            if (error.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
            // Emit observer event.
            this._observer.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "message" event in a DataProducer, message discarded');
        });
        this._dataChannel.addEventListener('bufferedamountlow', () => {
            if (this._closed) {
                return;
            }
            this.safeEmit('bufferedamountlow');
        });
    }
}
exports.DataProducer = DataProducer;

},{"./Logger":34,"./enhancedEvents":39,"./errors":40}],33:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Device = void 0;
exports.detectDevice = detectDevice;
const ua_parser_js_1 = require("ua-parser-js");
const Logger_1 = require("./Logger");
const enhancedEvents_1 = require("./enhancedEvents");
const errors_1 = require("./errors");
const utils = __importStar(require("./utils"));
const ortc = __importStar(require("./ortc"));
const Transport_1 = require("./Transport");
const Chrome111_1 = require("./handlers/Chrome111");
const Chrome74_1 = require("./handlers/Chrome74");
const Chrome70_1 = require("./handlers/Chrome70");
const Chrome67_1 = require("./handlers/Chrome67");
const Chrome55_1 = require("./handlers/Chrome55");
const Firefox120_1 = require("./handlers/Firefox120");
const Firefox60_1 = require("./handlers/Firefox60");
const Safari12_1 = require("./handlers/Safari12");
const Safari11_1 = require("./handlers/Safari11");
const Edge11_1 = require("./handlers/Edge11");
const ReactNativeUnifiedPlan_1 = require("./handlers/ReactNativeUnifiedPlan");
const ReactNative_1 = require("./handlers/ReactNative");
const logger = new Logger_1.Logger('Device');
function detectDevice(userAgent) {
    // React-Native.
    // NOTE: react-native-webrtc >= 1.75.0 is required.
    // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
    if (!userAgent &&
        typeof navigator === 'object' &&
        navigator.product === 'ReactNative') {
        logger.debug('detectDevice() | React-Native detected');
        if (typeof RTCPeerConnection === 'undefined') {
            logger.warn('detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?');
            return undefined;
        }
        if (typeof RTCRtpTransceiver !== 'undefined') {
            logger.debug('detectDevice() | ReactNative UnifiedPlan handler chosen');
            return 'ReactNativeUnifiedPlan';
        }
        else {
            logger.debug('detectDevice() | ReactNative PlanB handler chosen');
            return 'ReactNative';
        }
    }
    // Browser.
    else if (userAgent ||
        (typeof navigator === 'object' && typeof navigator.userAgent === 'string')) {
        userAgent ?? (userAgent = navigator.userAgent);
        const uaParser = new ua_parser_js_1.UAParser(userAgent);
        logger.debug('detectDevice() | browser detected [userAgent:%s, parsed:%o]', userAgent, uaParser.getResult());
        const browser = uaParser.getBrowser();
        const browserName = browser.name?.toLowerCase();
        const browserVersion = parseInt(browser.major ?? '0');
        const engine = uaParser.getEngine();
        const engineName = engine.name?.toLowerCase();
        const os = uaParser.getOS();
        const osName = os.name?.toLowerCase();
        const osVersion = parseFloat(os.version ?? '0');
        const device = uaParser.getDevice();
        const deviceModel = device.model?.toLowerCase();
        const isIOS = osName === 'ios' || deviceModel === 'ipad';
        const isChrome = browserName &&
            [
                'chrome',
                'chromium',
                'mobile chrome',
                'chrome webview',
                'chrome headless',
            ].includes(browserName);
        const isFirefox = browserName &&
            ['firefox', 'mobile firefox', 'mobile focus'].includes(browserName);
        const isSafari = browserName && ['safari', 'mobile safari'].includes(browserName);
        const isEdge = browserName && ['edge'].includes(browserName);
        // Chrome, Chromium, and Edge.
        if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
            return 'Chrome111';
        }
        else if ((isChrome && !isIOS && browserVersion >= 74) ||
            (isEdge && !isIOS && browserVersion >= 88)) {
            return 'Chrome74';
        }
        else if (isChrome && !isIOS && browserVersion >= 70) {
            return 'Chrome70';
        }
        else if (isChrome && !isIOS && browserVersion >= 67) {
            return 'Chrome67';
        }
        else if (isChrome && !isIOS && browserVersion >= 55) {
            return 'Chrome55';
        }
        // Firefox.
        else if (isFirefox && !isIOS && browserVersion >= 120) {
            return 'Firefox120';
        }
        else if (isFirefox && !isIOS && browserVersion >= 60) {
            return 'Firefox60';
        }
        // Firefox on iOS (so Safari).
        else if (isFirefox && isIOS && osVersion >= 14.3) {
            return 'Safari12';
        }
        // Safari with Unified-Plan support enabled.
        else if (isSafari &&
            browserVersion >= 12 &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Safari with Plab-B support.
        else if (isSafari && browserVersion >= 11) {
            return 'Safari11';
        }
        // Old Edge with ORTC support.
        else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {
            return 'Edge11';
        }
        // Best effort for WebKit based browsers in iOS.
        else if (engineName === 'webkit' &&
            isIOS &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Best effort for Chromium based browsers.
        else if (engineName === 'blink') {
            // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
            const match = userAgent.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
                const version = Number(match[1]);
                if (version >= 111) {
                    return 'Chrome111';
                }
                else if (version >= 74) {
                    return 'Chrome74';
                }
                else if (version >= 70) {
                    return 'Chrome70';
                }
                else if (version >= 67) {
                    return 'Chrome67';
                }
                else {
                    return 'Chrome55';
                }
            }
            else {
                return 'Chrome111';
            }
        }
        // Unsupported browser.
        else {
            logger.warn('detectDevice() | browser not supported [name:%s, version:%s]', browserName, browserVersion);
            return undefined;
        }
    }
    // Unknown device.
    else {
        logger.warn('detectDevice() | unknown device');
        return undefined;
    }
}
class Device {
    /**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    constructor({ handlerName, handlerFactory } = {}) {
        // Loaded flag.
        this._loaded = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        if (handlerName && handlerFactory) {
            throw new TypeError('just one of handlerName or handlerInterface can be given');
        }
        if (handlerFactory) {
            this._handlerFactory = handlerFactory;
        }
        else {
            if (handlerName) {
                logger.debug('constructor() | handler given: %s', handlerName);
            }
            else {
                handlerName = detectDevice();
                if (handlerName) {
                    logger.debug('constructor() | detected handler: %s', handlerName);
                }
                else {
                    throw new errors_1.UnsupportedError('device not supported');
                }
            }
            switch (handlerName) {
                case 'Chrome111': {
                    this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                    break;
                }
                case 'Chrome74': {
                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                    break;
                }
                case 'Chrome70': {
                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                    break;
                }
                case 'Chrome67': {
                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                    break;
                }
                case 'Chrome55': {
                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                    break;
                }
                case 'Firefox120': {
                    this._handlerFactory = Firefox120_1.Firefox120.createFactory();
                    break;
                }
                case 'Firefox60': {
                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                    break;
                }
                case 'Safari12': {
                    this._handlerFactory = Safari12_1.Safari12.createFactory();
                    break;
                }
                case 'Safari11': {
                    this._handlerFactory = Safari11_1.Safari11.createFactory();
                    break;
                }
                case 'Edge11': {
                    this._handlerFactory = Edge11_1.Edge11.createFactory();
                    break;
                }
                case 'ReactNativeUnifiedPlan': {
                    this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                    break;
                }
                case 'ReactNative': {
                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                    break;
                }
                default: {
                    throw new TypeError(`unknown handlerName "${handlerName}"`);
                }
            }
        }
        // Create a temporal handler to get its name.
        const handler = this._handlerFactory();
        this._handlerName = handler.name;
        handler.close();
        this._extendedRtpCapabilities = undefined;
        this._recvRtpCapabilities = undefined;
        this._canProduceByKind = {
            audio: false,
            video: false,
        };
        this._sctpCapabilities = undefined;
    }
    /**
     * The RTC handler name.
     */
    get handlerName() {
        return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
    get loaded() {
        return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get rtpCapabilities() {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get sctpCapabilities() {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        return this._sctpCapabilities;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Initialize the Device.
     */
    async load({ routerRtpCapabilities, }) {
        logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
        // Temporal handler to get its capabilities.
        let handler;
        try {
            if (this._loaded) {
                throw new errors_1.InvalidStateError('already loaded');
            }
            // Clone given router RTP capabilities to not modify input data.
            const clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(clonedRouterRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);
            // Clone obtained native RTP capabilities to not modify input data.
            const clonedNativeRtpCapabilities = utils.clone(nativeRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(clonedNativeRtpCapabilities);
            // Get extended RTP capabilities.
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities, clonedRouterRtpCapabilities);
            logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);
            // Check whether we can produce audio/video.
            this._canProduceByKind.audio = ortc.canSend('audio', this._extendedRtpCapabilities);
            this._canProduceByKind.video = ortc.canSend('video', this._extendedRtpCapabilities);
            // Generate our receiving RTP capabilities for receiving media.
            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
            // Generate our SCTP capabilities.
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
            // This may throw.
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger.debug('load() succeeded');
            this._loaded = true;
            handler.close();
        }
        catch (error) {
            if (handler) {
                handler.close();
            }
            throw error;
        }
    }
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    canProduce(kind) {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        else if (kind !== 'audio' && kind !== 'video') {
            throw new TypeError(`invalid kind "${kind}"`);
        }
        return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {
        logger.debug('createSendTransport()');
        return this.createTransport({
            direction: 'send',
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData,
        });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {
        logger.debug('createRecvTransport()');
        return this.createTransport({
            direction: 'recv',
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData,
        });
    }
    createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof iceParameters !== 'object') {
            throw new TypeError('missing iceParameters');
        }
        else if (!Array.isArray(iceCandidates)) {
            throw new TypeError('missing iceCandidates');
        }
        else if (typeof dtlsParameters !== 'object') {
            throw new TypeError('missing dtlsParameters');
        }
        else if (sctpParameters && typeof sctpParameters !== 'object') {
            throw new TypeError('wrong sctpParameters');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Create a new Transport.
        const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind,
        });
        // Emit observer event.
        this._observer.safeEmit('newtransport', transport);
        return transport;
    }
}
exports.Device = Device;

},{"./Logger":34,"./Transport":38,"./enhancedEvents":39,"./errors":40,"./handlers/Chrome111":41,"./handlers/Chrome55":42,"./handlers/Chrome67":43,"./handlers/Chrome70":44,"./handlers/Chrome74":45,"./handlers/Edge11":46,"./handlers/Firefox120":47,"./handlers/Firefox60":48,"./handlers/ReactNative":50,"./handlers/ReactNativeUnifiedPlan":51,"./handlers/Safari11":52,"./handlers/Safari12":53,"./ortc":62,"./utils":65,"ua-parser-js":86}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const debug_1 = __importDefault(require("debug"));
const APP_NAME = 'mediasoup-client';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;

},{"debug":5}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = void 0;
const Logger_1 = require("./Logger");
const enhancedEvents_1 = require("./enhancedEvents");
const errors_1 = require("./errors");
const logger = new Logger_1.Logger('Producer');
class Producer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._rtpSender = rtpSender;
        this._track = track;
        this._kind = track.kind;
        this._rtpParameters = rtpParameters;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = undefined;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
        // '@replacetrack' event here, so RTCRtpSender.track won't be null.
        this.handleTrack();
    }
    /**
     * Producer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
    get rtpSender() {
        return this._rtpSender;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
    get maxSpatialLayer() {
        return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Producer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this.destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this.destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return new Promise((resolve, reject) => {
            this.safeEmit('@getstats', resolve, reject);
        });
    }
    /**
     * Pauses sending media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Producer closed');
            return;
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
        }
        if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
                this.safeEmit('@pause', resolve, reject);
            }).catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Producer closed');
            return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
        }
        if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
                this.safeEmit('@resume', resolve, reject);
            }).catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
    async replaceTrack({ track, }) {
        logger.debug('replaceTrack() [track:%o]', track);
        if (this._closed) {
            // This must be done here. Otherwise there is no chance to stop the given
            // track.
            if (track && this._stopTracks) {
                try {
                    track.stop();
                }
                catch (error) { }
            }
            throw new errors_1.InvalidStateError('closed');
        }
        else if (track && track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        // Do nothing if this is the same track as the current handled one.
        if (track === this._track) {
            logger.debug('replaceTrack() | same track, ignored');
            return;
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@replacetrack', track, resolve, reject);
        });
        // Destroy the previous track.
        this.destroyTrack();
        // Set the new track.
        this._track = track;
        // If this Producer was paused/resumed and the state of the new
        // track does not match, fix it.
        if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
                this._track.enabled = true;
            }
            else if (this._paused) {
                this._track.enabled = false;
            }
        }
        // Handle the effective track.
        this.handleTrack();
    }
    /**
     * Sets the video max spatial layer to be sent.
     */
    async setMaxSpatialLayer(spatialLayer) {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._kind !== 'video') {
            throw new errors_1.UnsupportedError('not a video Producer');
        }
        else if (typeof spatialLayer !== 'number') {
            throw new TypeError('invalid spatialLayer');
        }
        if (spatialLayer === this._maxSpatialLayer) {
            return;
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);
        }).catch(() => { });
        this._maxSpatialLayer = spatialLayer;
    }
    async setRtpEncodingParameters(params) {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (typeof params !== 'object') {
            throw new TypeError('invalid params');
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@setrtpencodingparameters', params, resolve, reject);
        });
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    handleTrack() {
        if (!this._track) {
            return;
        }
        this._track.addEventListener('ended', this.onTrackEnded);
    }
    destroyTrack() {
        if (!this._track) {
            return;
        }
        try {
            this._track.removeEventListener('ended', this.onTrackEnded);
            // Just stop the track unless the app set stopTracks: false.
            if (this._stopTracks) {
                this._track.stop();
            }
        }
        catch (error) { }
    }
}
exports.Producer = Producer;

},{"./Logger":34,"./enhancedEvents":39,"./errors":40}],36:[function(require,module,exports){
"use strict";
/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],38:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
const awaitqueue_1 = require("awaitqueue");
const queue_microtask_1 = __importDefault(require("queue-microtask"));
const Logger_1 = require("./Logger");
const enhancedEvents_1 = require("./enhancedEvents");
const errors_1 = require("./errors");
const utils = __importStar(require("./utils"));
const ortc = __importStar(require("./ortc"));
const Producer_1 = require("./Producer");
const Consumer_1 = require("./Consumer");
const DataProducer_1 = require("./DataProducer");
const DataConsumer_1 = require("./DataConsumer");
const logger = new Logger_1.Logger('Transport');
class ConsumerCreationTask {
    constructor(consumerOptions) {
        this.consumerOptions = consumerOptions;
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
class Transport extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Transport ICE gathering state.
        this._iceGatheringState = 'new';
        // Transport connection state.
        this._connectionState = 'new';
        // Map of Producers indexed by id.
        this._producers = new Map();
        // Map of Consumers indexed by id.
        this._consumers = new Map();
        // Map of DataProducers indexed by id.
        this._dataProducers = new Map();
        // Map of DataConsumers indexed by id.
        this._dataConsumers = new Map();
        // Whether the Consumer for RTP probation has been created.
        this._probatorConsumerCreated = false;
        // AwaitQueue instance to make async tasks happen sequentially.
        this._awaitQueue = new awaitqueue_1.AwaitQueue();
        // Consumer creation tasks awaiting to be processed.
        this._pendingConsumerTasks = [];
        // Consumer creation in progress flag.
        this._consumerCreationInProgress = false;
        // Consumers pending to be paused.
        this._pendingPauseConsumers = new Map();
        // Consumer pause in progress flag.
        this._consumerPauseInProgress = false;
        // Consumers pending to be resumed.
        this._pendingResumeConsumers = new Map();
        // Consumer resume in progress flag.
        this._consumerResumeInProgress = false;
        // Consumers pending to be closed.
        this._pendingCloseConsumers = new Map();
        // Consumer close in progress flag.
        this._consumerCloseInProgress = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor() [id:%s, direction:%s]', id, direction);
        this._id = id;
        this._direction = direction;
        this._extendedRtpCapabilities = extendedRtpCapabilities;
        this._canProduceByKind = canProduceByKind;
        this._maxSctpMessageSize = sctpParameters
            ? sctpParameters.maxMessageSize
            : null;
        // Clone and sanitize additionalSettings.
        const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};
        delete clonedAdditionalSettings.iceServers;
        delete clonedAdditionalSettings.iceTransportPolicy;
        delete clonedAdditionalSettings.bundlePolicy;
        delete clonedAdditionalSettings.rtcpMuxPolicy;
        delete clonedAdditionalSettings.sdpSemantics;
        this._handler = handlerFactory();
        this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings: clonedAdditionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
        });
        this._appData = appData ?? {};
        this.handleHandler();
    }
    /**
     * Transport id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Transport direction.
     */
    get direction() {
        return this._direction;
    }
    /**
     * RTC handler instance.
     */
    get handler() {
        return this._handler;
    }
    /**
     * ICE gathering state.
     */
    get iceGatheringState() {
        return this._iceGatheringState;
    }
    /**
     * Connection state.
     */
    get connectionState() {
        return this._connectionState;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Close the Transport.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        // Stop the AwaitQueue.
        this._awaitQueue.stop();
        // Close the handler.
        this._handler.close();
        // Change connection state to 'closed' since the handler may not emit
        // '@connectionstatechange' event.
        this._connectionState = 'closed';
        // Close all Producers.
        for (const producer of this._producers.values()) {
            producer.transportClosed();
        }
        this._producers.clear();
        // Close all Consumers.
        for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
        }
        this._consumers.clear();
        // Close all DataProducers.
        for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
        }
        this._dataProducers.clear();
        // Close all DataConsumers.
        for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this._dataConsumers.clear();
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return this._handler.getTransportStats();
    }
    /**
     * Restart ICE connection.
     */
    async restartIce({ iceParameters, }) {
        logger.debug('restartIce()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!iceParameters) {
            throw new TypeError('missing iceParameters');
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), 'transport.restartIce()');
    }
    /**
     * Update ICE servers.
     */
    async updateIceServers({ iceServers, } = {}) {
        logger.debug('updateIceServers()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!Array.isArray(iceServers)) {
            throw new TypeError('missing iceServers');
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');
    }
    /**
     * Create a Producer.
     */
    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {}, } = {}) {
        logger.debug('produce() [track:%o]', track);
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!track) {
            throw new TypeError('missing track');
        }
        else if (this._direction !== 'send') {
            throw new errors_1.UnsupportedError('not a sending Transport');
        }
        else if (!this._canProduceByKind[track.kind]) {
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
        }
        else if (track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('produce') === 0) {
            throw new TypeError('no "produce" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Enqueue command.
        return (this._awaitQueue
            .push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
                throw TypeError('encodings must be an array');
            }
            else if (encodings && encodings.length === 0) {
                normalizedEncodings = undefined;
            }
            else if (encodings) {
                normalizedEncodings = encodings.map((encoding) => {
                    const normalizedEncoding = { active: true };
                    if (encoding.active === false) {
                        normalizedEncoding.active = false;
                    }
                    if (typeof encoding.dtx === 'boolean') {
                        normalizedEncoding.dtx = encoding.dtx;
                    }
                    if (typeof encoding.scalabilityMode === 'string') {
                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                    }
                    if (typeof encoding.scaleResolutionDownBy === 'number') {
                        normalizedEncoding.scaleResolutionDownBy =
                            encoding.scaleResolutionDownBy;
                    }
                    if (typeof encoding.maxBitrate === 'number') {
                        normalizedEncoding.maxBitrate = encoding.maxBitrate;
                    }
                    if (typeof encoding.maxFramerate === 'number') {
                        normalizedEncoding.maxFramerate = encoding.maxFramerate;
                    }
                    if (typeof encoding.adaptivePtime === 'boolean') {
                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                    }
                    if (typeof encoding.priority === 'string') {
                        normalizedEncoding.priority = encoding.priority;
                    }
                    if (typeof encoding.networkPriority === 'string') {
                        normalizedEncoding.networkPriority = encoding.networkPriority;
                    }
                    return normalizedEncoding;
                });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
                track,
                encodings: normalizedEncodings,
                codecOptions,
                codec,
                onRtpSender,
            });
            try {
                // This will fill rtpParameters's missing fields with default values.
                ortc.validateRtpParameters(rtpParameters);
                const { id } = await new Promise((resolve, reject) => {
                    this.safeEmit('produce', {
                        kind: track.kind,
                        rtpParameters,
                        appData,
                    }, resolve, reject);
                });
                const producer = new Producer_1.Producer({
                    id,
                    localId,
                    rtpSender,
                    track,
                    rtpParameters,
                    stopTracks,
                    disableTrackOnPause,
                    zeroRtpOnPause,
                    appData,
                });
                this._producers.set(producer.id, producer);
                this.handleProducer(producer);
                // Emit observer event.
                this._observer.safeEmit('newproducer', producer);
                return producer;
            }
            catch (error) {
                this._handler.stopSending(localId).catch(() => { });
                throw error;
            }
        }, 'transport.produce()')
            // This catch is needed to stop the given track if the command above
            // failed due to closed Transport.
            .catch((error) => {
            if (stopTracks) {
                try {
                    track.stop();
                }
                catch (error2) { }
            }
            throw error;
        }));
    }
    /**
     * Create a Consumer to consume a remote Producer.
     */
    async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {}, }) {
        logger.debug('consume()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new errors_1.UnsupportedError('not a receiving Transport');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof producerId !== 'string') {
            throw new TypeError('missing producerId');
        }
        else if (kind !== 'audio' && kind !== 'video') {
            throw new TypeError(`invalid kind '${kind}'`);
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given RTP parameters to not modify input data.
        const clonedRtpParameters = utils.clone(rtpParameters);
        // Ensure the device can consume it.
        const canConsume = ortc.canReceive(clonedRtpParameters, this._extendedRtpCapabilities);
        if (!canConsume) {
            throw new errors_1.UnsupportedError('cannot consume this Producer');
        }
        const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters: clonedRtpParameters,
            streamId,
            onRtpReceiver,
            appData,
        });
        // Store the Consumer creation task.
        this._pendingConsumerTasks.push(consumerCreationTask);
        // There is no Consumer creation in progress, create it now.
        (0, queue_microtask_1.default)(() => {
            if (this._closed) {
                return;
            }
            if (this._consumerCreationInProgress === false) {
                void this.createPendingConsumers();
            }
        });
        return consumerCreationTask.promise;
    }
    /**
     * Create a DataProducer
     */
    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {}, } = {}) {
        logger.debug('produceData()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'send') {
            throw new errors_1.UnsupportedError('not a sending Transport');
        }
        else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('producedata') === 0) {
            throw new TypeError('no "producedata" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        if (maxPacketLifeTime || maxRetransmits) {
            ordered = false;
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
                ordered,
                maxPacketLifeTime,
                maxRetransmits,
                label,
                protocol,
            });
            // This will fill sctpStreamParameters's missing fields with default values.
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id } = await new Promise((resolve, reject) => {
                this.safeEmit('producedata', {
                    sctpStreamParameters,
                    label,
                    protocol,
                    appData,
                }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
                id,
                dataChannel,
                sctpStreamParameters,
                appData,
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            // Emit observer event.
            this._observer.safeEmit('newdataproducer', dataProducer);
            return dataProducer;
        }, 'transport.produceData()');
    }
    /**
     * Create a DataConsumer
     */
    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {}, }) {
        logger.debug('consumeData()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new errors_1.UnsupportedError('not a receiving Transport');
        }
        else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof dataProducerId !== 'string') {
            throw new TypeError('missing dataProducerId');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given SCTP stream parameters to not modify input data.
        const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
        // This may throw.
        ortc.validateSctpStreamParameters(clonedSctpStreamParameters);
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
                sctpStreamParameters: clonedSctpStreamParameters,
                label,
                protocol,
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
                id,
                dataProducerId,
                dataChannel,
                sctpStreamParameters: clonedSctpStreamParameters,
                appData,
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            // Emit observer event.
            this._observer.safeEmit('newdataconsumer', dataConsumer);
            return dataConsumer;
        }, 'transport.consumeData()');
    }
    // This method is guaranteed to never throw.
    async createPendingConsumers() {
        this._consumerCreationInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingConsumerTasks.length === 0) {
                logger.debug('createPendingConsumers() | there is no Consumer to be created');
                return;
            }
            const pendingConsumerTasks = [...this._pendingConsumerTasks];
            // Clear pending Consumer tasks.
            this._pendingConsumerTasks = [];
            // Video Consumer in order to create the probator.
            let videoConsumerForProbator = undefined;
            // Fill options list.
            const optionsList = [];
            for (const task of pendingConsumerTasks) {
                const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
                optionsList.push({
                    trackId: id,
                    kind: kind,
                    rtpParameters,
                    streamId,
                    onRtpReceiver,
                });
            }
            try {
                const results = await this._handler.receive(optionsList);
                for (let idx = 0; idx < results.length; ++idx) {
                    const task = pendingConsumerTasks[idx];
                    const result = results[idx];
                    const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                    const { localId, rtpReceiver, track } = result;
                    const consumer = new Consumer_1.Consumer({
                        id: id,
                        localId,
                        producerId: producerId,
                        rtpReceiver,
                        track,
                        rtpParameters,
                        appData: appData,
                    });
                    this._consumers.set(consumer.id, consumer);
                    this.handleConsumer(consumer);
                    // If this is the first video Consumer and the Consumer for RTP probation
                    // has not yet been created, it's time to create it.
                    if (!this._probatorConsumerCreated &&
                        !videoConsumerForProbator &&
                        kind === 'video') {
                        videoConsumerForProbator = consumer;
                    }
                    // Emit observer event.
                    this._observer.safeEmit('newconsumer', consumer);
                    task.resolve(consumer);
                }
            }
            catch (error) {
                for (const task of pendingConsumerTasks) {
                    task.reject(error);
                }
            }
            // If RTP probation must be handled, do it now.
            if (videoConsumerForProbator) {
                try {
                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                    await this._handler.receive([
                        {
                            trackId: 'probator',
                            kind: 'video',
                            rtpParameters: probatorRtpParameters,
                        },
                    ]);
                    logger.debug('createPendingConsumers() | Consumer for RTP probation created');
                    this._probatorConsumerCreated = true;
                }
                catch (error) {
                    logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);
                }
            }
        }, 'transport.createPendingConsumers()')
            .then(() => {
            this._consumerCreationInProgress = false;
            // There are pending Consumer tasks, enqueue their creation.
            if (this._pendingConsumerTasks.length > 0) {
                void this.createPendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    pausePendingConsumers() {
        this._consumerPauseInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingPauseConsumers.size === 0) {
                logger.debug('pausePendingConsumers() | there is no Consumer to be paused');
                return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            // Clear pending pause Consumer map.
            this._pendingPauseConsumers.clear();
            try {
                const localIds = pendingPauseConsumers.map(consumer => consumer.localId);
                await this._handler.pauseReceiving(localIds);
            }
            catch (error) {
                logger.error('pausePendingConsumers() | failed to pause Consumers:', error);
            }
        }, 'transport.pausePendingConsumers')
            .then(() => {
            this._consumerPauseInProgress = false;
            // There are pending Consumers to be paused, do it.
            if (this._pendingPauseConsumers.size > 0) {
                this.pausePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    resumePendingConsumers() {
        this._consumerResumeInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingResumeConsumers.size === 0) {
                logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');
                return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            // Clear pending resume Consumer map.
            this._pendingResumeConsumers.clear();
            try {
                const localIds = pendingResumeConsumers.map(consumer => consumer.localId);
                await this._handler.resumeReceiving(localIds);
            }
            catch (error) {
                logger.error('resumePendingConsumers() | failed to resume Consumers:', error);
            }
        }, 'transport.resumePendingConsumers')
            .then(() => {
            this._consumerResumeInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingResumeConsumers.size > 0) {
                this.resumePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    closePendingConsumers() {
        this._consumerCloseInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingCloseConsumers.size === 0) {
                logger.debug('closePendingConsumers() | there is no Consumer to be closed');
                return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            // Clear pending close Consumer map.
            this._pendingCloseConsumers.clear();
            try {
                await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));
            }
            catch (error) {
                logger.error('closePendingConsumers() | failed to close Consumers:', error);
            }
        }, 'transport.closePendingConsumers')
            .then(() => {
            this._consumerCloseInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingCloseConsumers.size > 0) {
                this.closePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    handleHandler() {
        const handler = this._handler;
        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
                errback(new errors_1.InvalidStateError('closed'));
                return;
            }
            this.safeEmit('connect', { dtlsParameters }, callback, errback);
        });
        handler.on('@icegatheringstatechange', (iceGatheringState) => {
            if (iceGatheringState === this._iceGatheringState) {
                return;
            }
            logger.debug('ICE gathering state changed to %s', iceGatheringState);
            this._iceGatheringState = iceGatheringState;
            if (!this._closed) {
                this.safeEmit('icegatheringstatechange', iceGatheringState);
            }
        });
        handler.on('@connectionstatechange', (connectionState) => {
            if (connectionState === this._connectionState) {
                return;
            }
            logger.debug('connection state changed to %s', connectionState);
            this._connectionState = connectionState;
            if (!this._closed) {
                this.safeEmit('connectionstatechange', connectionState);
            }
        });
    }
    handleProducer(producer) {
        producer.on('@close', () => {
            this._producers.delete(producer.id);
            if (this._closed) {
                return;
            }
            this._awaitQueue
                .push(async () => await this._handler.stopSending(producer.localId), 'producer @close event')
                .catch((error) => logger.warn('producer.close() failed:%o', error));
        });
        producer.on('@pause', (callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.pauseSending(producer.localId), 'producer @pause event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@resume', (callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.resumeSending(producer.localId), 'producer @resume event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@replacetrack', (track, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setrtpencodingparameters', (params, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@getstats', (callback, errback) => {
            if (this._closed) {
                return errback(new errors_1.InvalidStateError('closed'));
            }
            this._handler
                .getSenderStats(producer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    handleConsumer(consumer) {
        consumer.on('@close', () => {
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) {
                return;
            }
            // Store the Consumer into the close list.
            this._pendingCloseConsumers.set(consumer.id, consumer);
            // There is no Consumer close in progress, do it now.
            if (this._consumerCloseInProgress === false) {
                this.closePendingConsumers();
            }
        });
        consumer.on('@pause', () => {
            // If Consumer is pending to be resumed, remove from pending resume list.
            if (this._pendingResumeConsumers.has(consumer.id)) {
                this._pendingResumeConsumers.delete(consumer.id);
            }
            // Store the Consumer into the pending list.
            this._pendingPauseConsumers.set(consumer.id, consumer);
            // There is no Consumer pause in progress, do it now.
            (0, queue_microtask_1.default)(() => {
                if (this._closed) {
                    return;
                }
                if (this._consumerPauseInProgress === false) {
                    this.pausePendingConsumers();
                }
            });
        });
        consumer.on('@resume', () => {
            // If Consumer is pending to be paused, remove from pending pause list.
            if (this._pendingPauseConsumers.has(consumer.id)) {
                this._pendingPauseConsumers.delete(consumer.id);
            }
            // Store the Consumer into the pending list.
            this._pendingResumeConsumers.set(consumer.id, consumer);
            // There is no Consumer resume in progress, do it now.
            (0, queue_microtask_1.default)(() => {
                if (this._closed) {
                    return;
                }
                if (this._consumerResumeInProgress === false) {
                    this.resumePendingConsumers();
                }
            });
        });
        consumer.on('@getstats', (callback, errback) => {
            if (this._closed) {
                return errback(new errors_1.InvalidStateError('closed'));
            }
            this._handler
                .getReceiverStats(consumer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    handleDataProducer(dataProducer) {
        dataProducer.on('@close', () => {
            this._dataProducers.delete(dataProducer.id);
        });
    }
    handleDataConsumer(dataConsumer) {
        dataConsumer.on('@close', () => {
            this._dataConsumers.delete(dataConsumer.id);
        });
    }
}
exports.Transport = Transport;

},{"./Consumer":30,"./DataConsumer":31,"./DataProducer":32,"./Logger":34,"./Producer":35,"./enhancedEvents":39,"./errors":40,"./ortc":62,"./utils":65,"awaitqueue":4,"queue-microtask":68}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnhancedEventEmitter = void 0;
const npm_events_package_1 = require("npm-events-package");
const Logger_1 = require("./Logger");
const enhancedEventEmitterLogger = new Logger_1.Logger('EnhancedEventEmitter');
class EnhancedEventEmitter extends npm_events_package_1.EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(Infinity);
    }
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * Special addition to the EventEmitter API.
     */
    safeEmit(eventName, ...args) {
        try {
            return super.emit(eventName, ...args);
        }
        catch (error) {
            enhancedEventEmitterLogger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
            try {
                super.emit('listenererror', eventName, error);
            }
            catch (error2) {
                // Ignore it.
            }
            return Boolean(super.listenerCount(eventName));
        }
    }
    on(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    addListener(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    prependListener(eventName, listener) {
        super.prependListener(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        super.once(eventName, listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        super.prependOnceListener(eventName, listener);
        return this;
    }
    removeListener(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    removeAllListeners(eventName) {
        super.removeAllListeners(eventName);
        return this;
    }
    listenerCount(eventName) {
        return super.listenerCount(eventName);
    }
    listeners(eventName) {
        return super.listeners(eventName);
    }
    rawListeners(eventName) {
        return super.rawListeners(eventName);
    }
}
exports.EnhancedEventEmitter = EnhancedEventEmitter;

},{"./Logger":34,"npm-events-package":67}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
class UnsupportedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnsupportedError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            Error.captureStackTrace(this, UnsupportedError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
class InvalidStateError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidStateError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            // Just in V8.
            Error.captureStackTrace(this, InvalidStateError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.InvalidStateError = InvalidStateError;

},{}],41:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome111 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const ortcUtils = __importStar(require("./ortc/utils"));
const errors_1 = require("../errors");
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Chrome111');
const NAME = 'Chrome111';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome111 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome111();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', () => {
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            // Set rid and verify scalabilityMode in each encoding.
            // NOTE: Even if WebRTC allows different scalabilityMode (different number
            // of temporal layers) per simulcast stream, we need that those are the
            // same in all them, so let's pick up the highest value.
            // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
            let maxTemporalLayers = 1;
            for (const encoding of encodings) {
                const temporalLayers = encoding.scalabilityMode
                    ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers
                    : 3;
                if (temporalLayers > maxTemporalLayers) {
                    maxTemporalLayers = temporalLayers;
                }
            }
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
                encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome111 = Chrome111;

},{"../Logger":34,"../errors":40,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./ortc/utils":55,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],42:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome55 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Chrome55');
const NAME = 'Chrome55';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome55 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome55();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track) {
            throw new Error('track not found');
        }
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    track) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async setMaxSpatialLayer(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    spatialLayer) {
        throw new errors_1.UnsupportedError(' not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError('not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const streamId = options.streamId ?? rtpParameters.rtcp.cname;
            const stream = this._pc
                .getRemoteStreams()
                .find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
                throw new Error('remote track not found');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome55 = Chrome55;

},{"../Logger":34,"../errors":40,"../ortc":62,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/planBUtils":59,"sdp-transform":70}],43:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome67 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Chrome67');
const NAME = 'Chrome67';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome67 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome67();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc
            .getSenders()
            .find((s) => s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        this._pc.removeTrack(rtpSender);
        if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
        }
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
        }
        // Add the new track to the local stream.
        if (track) {
            this._sendStream.addTrack(track);
        }
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const rtpReceiver = this._pc
                .getReceivers()
                .find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
                throw new Error('new RTCRtpReceiver not');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver,
            });
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) ?? {};
        if (!rtpReceiver) {
            throw new Error('associated RTCRtpReceiver not found');
        }
        return rtpReceiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome67 = Chrome67;

},{"../Logger":34,"../ortc":62,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/planBUtils":59,"sdp-transform":70}],44:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome70 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Chrome70');
const NAME = 'Chrome70';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome70 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome70();
    }
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // If encodings are given, apply them now.
        if (encodings) {
            logger.debug('send() | applying given encodings');
            const parameters = transceiver.sender.getParameters();
            for (let idx = 0; idx < (parameters.encodings ?? []).length; ++idx) {
                const encoding = parameters.encodings[idx];
                const desiredEncoding = encodings[idx];
                // Should not happen but just in case.
                if (!desiredEncoding) {
                    break;
                }
                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
        }
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // Hack for VP9 SVC.
        if (hackVp9Svc) {
            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome70 = Chrome70;

},{"../Logger":34,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],45:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome74 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const ortcUtils = __importStar(require("./ortc/utils"));
const errors_1 = require("../errors");
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Chrome74');
const NAME = 'Chrome74';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome74 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome74();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', () => {
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome74 = Chrome74;

},{"../Logger":34,"../errors":40,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./ortc/utils":55,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],46:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Edge11 = void 0;
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const edgeUtils = __importStar(require("./ortc/edgeUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const logger = new Logger_1.Logger('Edge11');
const NAME = 'Edge11';
class Edge11 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Edge11();
    }
    constructor() {
        super();
        // Map of RTCRtpSenders indexed by id.
        this._rtpSenders = new Map();
        // Map of RTCRtpReceivers indexed by id.
        this._rtpReceivers = new Map();
        // Next localId for sending tracks.
        this._nextSendLocalId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close the ICE gatherer.
        // NOTE: Not yet implemented by Edge.
        try {
            this._iceGatherer.close();
        }
        catch (error) { }
        // Close the ICE transport.
        try {
            this._iceTransport.stop();
        }
        catch (error) { }
        // Close the DTLS transport.
        try {
            this._dtlsTransport.stop();
        }
        catch (error) { }
        // Close RTCRtpSenders.
        for (const rtpSender of this._rtpSenders.values()) {
            try {
                rtpSender.stop();
            }
            catch (error) { }
        }
        // Close RTCRtpReceivers.
        for (const rtpReceiver of this._rtpReceivers.values()) {
            try {
                rtpReceiver.stop();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        return edgeUtils.getCapabilities();
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: { OS: 0, MIS: 0 },
        };
    }
    run({ direction, // eslint-disable-line @typescript-eslint/no-unused-vars
    iceParameters, iceCandidates, dtlsParameters, sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars
    iceServers, iceTransportPolicy, additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars
    proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars
    extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._remoteIceParameters = iceParameters;
        this._remoteIceCandidates = iceCandidates;
        this._remoteDtlsParameters = dtlsParameters;
        this._cname = `CNAME-${utils.generateRandomNumber()}`;
        this.setIceGatherer({ iceServers, iceTransportPolicy });
        this.setIceTransport();
        this.setDtlsTransport();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        // NOTE: Edge 11 does not implement iceGatherer.gater().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        this._remoteIceParameters = iceParameters;
        if (!this._transportReady) {
            return;
        }
        logger.debug('restartIce() | calling iceTransport.start()');
        this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');
        for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
        }
        this._iceTransport.addRemoteCandidate({});
    }
    async getTransportStats() {
        return this._iceTransport.getStats();
    }
    async send(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    { track, encodings, codecOptions, codec }) {
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'server' });
        }
        logger.debug('send() | calling new RTCRtpSender()');
        const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
        const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
        const useRtx = rtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
        if (!encodings) {
            encodings = [{}];
        }
        for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) {
                encoding.rtx = { ssrc: utils.generateRandomNumber() };
            }
        }
        rtpParameters.encodings = encodings;
        // Fill RTCRtpParameters.rtcp.
        rtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true,
        };
        // NOTE: Convert our standard RTCRtpParameters into those that Edge
        // expects.
        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
        logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
        await rtpSender.send(edgeRtpParameters);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Store it.
        this._rtpSenders.set(localId, rtpSender);
        return { localId, rtpParameters, rtpSender };
    }
    async stopSending(localId) {
        logger.debug('stopSending() [localId:%s]', localId);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        this._rtpSenders.delete(localId);
        try {
            logger.debug('stopSending() | calling rtpSender.stop()');
            rtpSender.stop();
        }
        catch (error) {
            logger.warn('stopSending() | rtpSender.stop() failed:%o', error);
            throw error;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        rtpSender.setTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        return rtpSender.getStats();
    }
    async sendDataChannel(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receive(optionsList) {
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'server' });
        }
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger.debug('receive() | calling new RTCRtpReceiver()');
            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
            rtpReceiver.addEventListener('error', (event) => {
                logger.error('rtpReceiver "error" event [event:%o]', event);
            });
            // NOTE: Convert our standard RTCRtpParameters into those that Edge
            // expects.
            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
            logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
            await rtpReceiver.receive(edgeRtpParameters);
            const localId = trackId;
            // Store it.
            this._rtpReceivers.set(localId, rtpReceiver);
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) {
                throw new Error('RTCRtpReceiver not found');
            }
            this._rtpReceivers.delete(localId);
            try {
                logger.debug('stopReceiving() | calling rtpReceiver.stop()');
                rtpReceiver.stop();
            }
            catch (error) {
                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);
            }
        }
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        const rtpReceiver = this._rtpReceivers.get(localId);
        if (!rtpReceiver) {
            throw new Error('RTCRtpReceiver not found');
        }
        return rtpReceiver.getStats();
    }
    async receiveDataChannel(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    setIceGatherer({ iceServers, iceTransportPolicy, }) {
        // @ts-expect-error --- On purpose
        const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers ?? [],
            gatherPolicy: iceTransportPolicy ?? 'all',
        });
        iceGatherer.addEventListener('error', (event) => {
            logger.error('iceGatherer "error" event [event:%o]', event);
        });
        // NOTE: Not yet implemented by Edge, which starts gathering automatically.
        try {
            iceGatherer.gather();
        }
        catch (error) {
            logger.debug('setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());
        }
        this._iceGatherer = iceGatherer;
    }
    setIceTransport() {
        const iceTransport = new RTCIceTransport(this._iceGatherer);
        // NOTE: Not yet implemented by Edge.
        iceTransport.addEventListener('statechange', () => {
            switch (iceTransport.state) {
                case 'checking': {
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                }
                case 'connected':
                case 'completed': {
                    this.emit('@connectionstatechange', 'connected');
                    break;
                }
                case 'failed': {
                    this.emit('@connectionstatechange', 'failed');
                    break;
                }
                case 'disconnected': {
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                }
                case 'closed': {
                    this.emit('@connectionstatechange', 'closed');
                    break;
                }
            }
        });
        // NOTE: Not standard, but implemented by Edge.
        iceTransport.addEventListener('icestatechange', () => {
            switch (iceTransport.state) {
                case 'checking': {
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                }
                case 'connected':
                case 'completed': {
                    this.emit('@connectionstatechange', 'connected');
                    break;
                }
                case 'failed': {
                    this.emit('@connectionstatechange', 'failed');
                    break;
                }
                case 'disconnected': {
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                }
                case 'closed': {
                    this.emit('@connectionstatechange', 'closed');
                    break;
                }
            }
        });
        iceTransport.addEventListener('candidatepairchange', (event) => {
            logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
        });
        this._iceTransport = iceTransport;
    }
    setDtlsTransport() {
        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
        // NOTE: Not yet implemented by Edge.
        dtlsTransport.addEventListener('statechange', () => {
            logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
        });
        // NOTE: Not standard, but implemented by Edge.
        dtlsTransport.addEventListener('dtlsstatechange', () => {
            logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === 'closed') {
                this.emit('@connectionstatechange', 'closed');
            }
        });
        dtlsTransport.addEventListener('error', (event) => {
            logger.error('dtlsTransport "error" event [event:%o]', event);
        });
        this._dtlsTransport = dtlsTransport;
    }
    async setupTransport({ localDtlsRole, }) {
        logger.debug('setupTransport()');
        // Get our local DTLS parameters.
        const dtlsParameters = this._dtlsTransport.getLocalParameters();
        dtlsParameters.role = localDtlsRole;
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        // Start the RTCIceTransport.
        this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');
        // Add remote ICE candidates.
        for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
        }
        // Also signal a 'complete' candidate as per spec.
        // NOTE: It should be {complete: true} but Edge prefers {}.
        // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
        // won't enter the 'completed' state.
        this._iceTransport.addRemoteCandidate({});
        // NOTE: Edge does not like SHA less than 256.
        this._remoteDtlsParameters.fingerprints =
            this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {
                return (fingerprint.algorithm === 'sha-256' ||
                    fingerprint.algorithm === 'sha-384' ||
                    fingerprint.algorithm === 'sha-512');
            });
        // Start the RTCDtlsTransport.
        this._dtlsTransport.start(this._remoteDtlsParameters);
        this._transportReady = true;
    }
}
exports.Edge11 = Edge11;

},{"../Logger":34,"../errors":40,"../ortc":62,"../utils":65,"./HandlerInterface":49,"./ortc/edgeUtils":54}],47:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Firefox120 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Firefox120');
const NAME = 'Firefox120';
const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
class Firefox120 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Firefox120();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
        });
        // NOTE: We need to add a real video track to get the RID extension mapping,
        // otherwiser Firefox doesn't include it in the SDP.
        const canvas = document.createElement('canvas');
        // NOTE: Otherwise Firefox fails in next line.
        canvas.getContext('2d');
        const fakeStream = canvas.captureStream();
        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
        try {
            pc.addTransceiver('audio', { direction: 'sendrecv' });
            pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv',
                sendEncodings: [
                    { rid: 'r0', maxBitrate: 100000 },
                    { rid: 'r1', maxBitrate: 500000 },
                ],
            });
            const offer = await pc.createOffer();
            try {
                canvas.remove();
            }
            catch (error) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error) { }
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                canvas.remove();
            }
            catch (error2) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error2) { }
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        // NOTE: Cannot use stop() the transceiver due to the the note above in
        // send() method.
        // try
        // {
        // 	transceiver.stop();
        // }
        // catch (error)
        // {}
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp!.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Firefox120 = Firefox120;

},{"../Logger":34,"../errors":40,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],48:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Firefox60 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Firefox60');
const NAME = 'Firefox60';
const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
class Firefox60 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Firefox60();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
        });
        // NOTE: We need to add a real video track to get the RID extension mapping.
        const canvas = document.createElement('canvas');
        // NOTE: Otherwise Firefox fails in next line.
        canvas.getContext('2d');
        const fakeStream = canvas.captureStream();
        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
        try {
            pc.addTransceiver('audio', { direction: 'sendrecv' });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv',
            });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
                { rid: 'r0', maxBitrate: 100000 },
                { rid: 'r1', maxBitrate: 500000 },
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
                canvas.remove();
            }
            catch (error) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error) { }
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                canvas.remove();
            }
            catch (error2) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error2) { }
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings) {
            encodings = utils.clone(encodings);
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
            // Clone the encodings and reverse them because Firefox likes them
            // from high to low.
            encodings.reverse();
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
        // second argument, but Firefox does not support it.
        if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim (but
        // reverse them back since we reversed them above to satisfy Firefox).
        else {
            sendingRtpParameters.encodings = encodings.reverse();
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        // NOTE: Cannot use stop() the transceiver due to the the note above in
        // send() method.
        // try
        // {
        // 	transceiver.stop();
        // }
        // catch (error)
        // {}
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp!.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        // NOTE: We require encodings given from low to high, however Firefox
        // requires them in reverse order, so do magic here.
        spatialLayer = parameters.encodings.length - 1 - spatialLayer;
        parameters.encodings.forEach((encoding, idx) => {
            if (idx >= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Firefox60 = Firefox60;

},{"../Logger":34,"../errors":40,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerInterface = void 0;
const enhancedEvents_1 = require("../enhancedEvents");
class HandlerInterface extends enhancedEvents_1.EnhancedEventEmitter {
    constructor() {
        super();
    }
}
exports.HandlerInterface = HandlerInterface;

},{"../enhancedEvents":39}],50:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactNative = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('ReactNative');
const NAME = 'ReactNative';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class ReactNative extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new ReactNative();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-expect-error --- Proprietary API in react-native-webrtc.
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track) {
            throw new Error('track not found');
        }
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    track) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async setMaxSpatialLayer(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    spatialLayer) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        const mapStreamId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            let streamId = options.streamId ?? rtpParameters.rtcp.cname;
            // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
            // remote tracks. This is because react-native-webrtc does not react on new
            // tracks generated within already existing streams, so force the streamId
            // to be different. See:
            // https://github.com/react-native-webrtc/react-native-webrtc/issues/401
            logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');
            streamId += `-hack-${utils.generateRandomNumber()}`;
            mapStreamId.set(trackId, streamId);
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const streamId = mapStreamId.get(trackId);
            const stream = this._pc
                .getRemoteStreams()
                .find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
                throw new Error('remote track not found');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.ReactNative = ReactNative;

},{"../Logger":34,"../errors":40,"../ortc":62,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/planBUtils":59,"sdp-transform":70}],51:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactNativeUnifiedPlan = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const ortcUtils = __importStar(require("./ortc/utils"));
const errors_1 = require("../errors");
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('ReactNativeUnifiedPlan');
const NAME = 'ReactNativeUnifiedPlan';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new ReactNativeUnifiedPlan();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-expect-error --- Proprietary API in react-native-webrtc.
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
        // because transceiver.mid is not available until setRemoteDescription()
        // is called, so this is best effort.
        // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
        // NOTE: So let's fill MID in sendingRtpParameters later.
        // NOTE: This is fixed in react-native-webrtc 111.0.3.
        let localId = transceiver.mid ?? undefined;
        if (!localId) {
            logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');
        }
        // Set MID.
        // NOTE: As per above, it could be unset yet.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
        // we can read generated MID (if not done above) and fill sendingRtpParameters.
        // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
        // needed starting from that version.
        if (!localId) {
            localId = transceiver.mid;
            sendingRtpParameters.mid = localId;
        }
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
            return;
        }
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;

},{"../Logger":34,"../errors":40,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./ortc/utils":55,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],52:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Safari11 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Safari11');
const NAME = 'Safari11';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari11 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Safari11();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc
            .getSenders()
            .find((s) => s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
        }
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
        }
        // Add the new track to the local stream.
        if (track) {
            this._sendStream.addTrack(track);
        }
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const rtpReceiver = this._pc
                .getReceivers()
                .find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
                throw new Error('new RTCRtpReceiver not');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver,
            });
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) ?? {};
        if (!rtpReceiver) {
            throw new Error('associated RTCRtpReceiver not found');
        }
        return rtpReceiver.getStats();
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari11 = Safari11;

},{"../Logger":34,"../ortc":62,"../utils":65,"./HandlerInterface":49,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/planBUtils":59,"sdp-transform":70}],53:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Safari12 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const ortcUtils = __importStar(require("./ortc/utils"));
const errors_1 = require("../errors");
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Safari12');
const NAME = 'Safari12';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari12 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Safari12();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
            return;
        }
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari12 = Safari12;

},{"../Logger":34,"../errors":40,"../ortc":62,"../scalabilityModes":63,"../utils":65,"./HandlerInterface":49,"./ortc/utils":55,"./sdp/RemoteSdp":57,"./sdp/commonUtils":58,"./sdp/unifiedPlanUtils":60,"sdp-transform":70}],54:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCapabilities = getCapabilities;
exports.mangleRtpParameters = mangleRtpParameters;
const utils = __importStar(require("../../utils"));
/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */
function getCapabilities() {
    const nativeCaps = RTCRtpReceiver.getCapabilities();
    const caps = utils.clone(nativeCaps);
    for (const codec of caps.codecs ?? []) {
        // Rename numChannels to channels.
        // @ts-expect-error --- On purpose.
        codec.channels = codec.numChannels;
        // @ts-expect-error --- On purpose.
        delete codec.numChannels;
        // Add mimeType.
        // @ts-expect-error --- On purpose (due to codec.name).
        codec.mimeType = codec.mimeType ?? `${codec.kind}/${codec.name}`;
        // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
        if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt) {
                parameters.apt = Number(parameters.apt);
            }
            if (parameters['packetization-mode']) {
                parameters['packetization-mode'] = Number(parameters['packetization-mode']);
            }
        }
        // Delete emty parameter String in rtcpFeedback.
        for (const feedback of codec.rtcpFeedback ?? []) {
            if (!feedback.parameter) {
                feedback.parameter = '';
            }
        }
    }
    return caps;
}
/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */
function mangleRtpParameters(rtpParameters) {
    const params = utils.clone(rtpParameters);
    // Rename mid to muxId.
    if (params.mid) {
        // @ts-expect-error --- On purpose (due to muxId).
        params.muxId = params.mid;
        delete params.mid;
    }
    for (const codec of params.codecs) {
        // Rename channels to numChannels.
        if (codec.channels) {
            // @ts-expect-error --- On purpose.
            codec.numChannels = codec.channels;
            delete codec.channels;
        }
        // Add codec.name (requried by Edge).
        // @ts-expect-error --- On purpose (due to name).
        if (codec.mimeType && !codec.name) {
            // @ts-expect-error --- On purpose (due to name).
            codec.name = codec.mimeType.split('/')[1];
        }
        // Remove mimeType.
        // @ts-expect-error --- On purpose.
        delete codec.mimeType;
    }
    return params;
}

},{"../../utils":65}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addNackSuppportForOpus = addNackSuppportForOpus;
/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */
function addNackSuppportForOpus(rtpCapabilities) {
    for (const codec of rtpCapabilities.codecs ?? []) {
        if ((codec.mimeType.toLowerCase() === 'audio/opus' ||
            codec.mimeType.toLowerCase() === 'audio/multiopus') &&
            !codec.rtcpFeedback?.some(fb => fb.type === 'nack' && !fb.parameter)) {
            if (!codec.rtcpFeedback) {
                codec.rtcpFeedback = [];
            }
            codec.rtcpFeedback.push({ type: 'nack' });
        }
    }
}

},{}],56:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const utils = __importStar(require("../../utils"));
class MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false, }) {
        this._mediaObject = {};
        this._planB = planB;
        if (iceParameters) {
            this.setIceParameters(iceParameters);
        }
        if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
                const candidateObject = {};
                // mediasoup does mandates rtcp-mux so candidates component is always
                // RTP (1).
                candidateObject.component = 1;
                candidateObject.foundation = candidate.foundation;
                // Be ready for new candidate.address field in mediasoup server side
                // field and keep backward compatibility with deprecated candidate.ip.
                candidateObject.ip = candidate.address ?? candidate.ip;
                candidateObject.port = candidate.port;
                candidateObject.priority = candidate.priority;
                candidateObject.transport = candidate.protocol;
                candidateObject.type = candidate.type;
                if (candidate.tcpType) {
                    candidateObject.tcptype = candidate.tcpType;
                }
                this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = 'end-of-candidates';
            this._mediaObject.iceOptions = 'renomination';
        }
        if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
        }
    }
    get mid() {
        return String(this._mediaObject.mid);
    }
    get closed() {
        return this._mediaObject.port === 0;
    }
    getObject() {
        return this._mediaObject;
    }
    setIceParameters(iceParameters) {
        this._mediaObject.iceUfrag = iceParameters.usernameFragment;
        this._mediaObject.icePwd = iceParameters.password;
    }
    pause() {
        this._mediaObject.direction = 'inactive';
    }
    disable() {
        this.pause();
        delete this._mediaObject.ext;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
        delete this._mediaObject.extmapAllowMixed;
    }
    close() {
        this.disable();
        this._mediaObject.port = 0;
    }
}
exports.MediaSection = MediaSection;
class AnswerMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false, }) {
        super({ iceParameters, iceCandidates, dtlsParameters, planB });
        this._mediaObject.mid = String(offerMediaObject.mid);
        this._mediaObject.type = offerMediaObject.type;
        this._mediaObject.protocol = offerMediaObject.protocol;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
            };
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (offerMediaObject.type) {
            case 'audio':
            case 'video': {
                this._mediaObject.direction = 'recvonly';
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                for (const codec of answerRtpParameters.codecs) {
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate,
                    };
                    if (codec.channels > 1) {
                        rtp.encoding = codec.channels;
                    }
                    this._mediaObject.rtp.push(rtp);
                    const codecParameters = utils.clone(codec.parameters) ?? {};
                    let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                    if (codecOptions) {
                        const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate, } = codecOptions;
                        const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                        switch (codec.mimeType.toLowerCase()) {
                            case 'audio/opus':
                            case 'audio/multiopus': {
                                if (opusStereo !== undefined) {
                                    offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                                    codecParameters.stereo = opusStereo ? 1 : 0;
                                }
                                if (opusFec !== undefined) {
                                    offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                                    codecParameters.useinbandfec = opusFec ? 1 : 0;
                                }
                                if (opusDtx !== undefined) {
                                    offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                                    codecParameters.usedtx = opusDtx ? 1 : 0;
                                }
                                if (opusMaxPlaybackRate !== undefined) {
                                    codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                                }
                                if (opusMaxAverageBitrate !== undefined) {
                                    codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                                }
                                if (opusPtime !== undefined) {
                                    offerCodec.parameters.ptime = opusPtime;
                                    codecParameters.ptime = opusPtime;
                                }
                                // If opusNack is not set, we must remove NACK support for OPUS.
                                // Otherwise it would be enabled for those handlers that artificially
                                // announce it in their RTP capabilities.
                                if (!opusNack) {
                                    offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);
                                    codecRtcpFeedback = codecRtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);
                                }
                                break;
                            }
                            case 'video/vp8':
                            case 'video/vp9':
                            case 'video/h264':
                            case 'video/h265': {
                                if (videoGoogleStartBitrate !== undefined) {
                                    codecParameters['x-google-start-bitrate'] =
                                        videoGoogleStartBitrate;
                                }
                                if (videoGoogleMaxBitrate !== undefined) {
                                    codecParameters['x-google-max-bitrate'] =
                                        videoGoogleMaxBitrate;
                                }
                                if (videoGoogleMinBitrate !== undefined) {
                                    codecParameters['x-google-min-bitrate'] =
                                        videoGoogleMinBitrate;
                                }
                                break;
                            }
                        }
                    }
                    const fmtp = {
                        payload: codec.payloadType,
                        config: '',
                    };
                    for (const key of Object.keys(codecParameters)) {
                        if (fmtp.config) {
                            fmtp.config += ';';
                        }
                        fmtp.config += `${key}=${codecParameters[key]}`;
                    }
                    if (fmtp.config) {
                        this._mediaObject.fmtp.push(fmtp);
                    }
                    for (const fb of codecRtcpFeedback) {
                        this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter,
                        });
                    }
                }
                this._mediaObject.payloads = answerRtpParameters.codecs
                    .map((codec) => codec.payloadType)
                    .join(' ');
                this._mediaObject.ext = [];
                for (const ext of answerRtpParameters.headerExtensions) {
                    // Don't add a header extension if not present in the offer.
                    const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
                    if (!found) {
                        continue;
                    }
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id,
                    });
                }
                // Allow both 1 byte and 2 bytes length header extensions.
                if (extmapAllowMixed &&
                    offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
                    this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
                }
                // Simulcast.
                if (offerMediaObject.simulcast) {
                    this._mediaObject.simulcast = {
                        dir1: 'recv',
                        list1: offerMediaObject.simulcast.list1,
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids ?? []) {
                        if (rid.direction !== 'send') {
                            continue;
                        }
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: 'recv',
                        });
                    }
                }
                // Simulcast (draft version 03).
                else if (offerMediaObject.simulcast_03) {
                    this._mediaObject.simulcast_03 = {
                        value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv'),
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids ?? []) {
                        if (rid.direction !== 'send') {
                            continue;
                        }
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: 'recv',
                        });
                    }
                }
                this._mediaObject.rtcpMux = 'rtcp-mux';
                this._mediaObject.rtcpRsize = 'rtcp-rsize';
                if (this._planB && this._mediaObject.type === 'video') {
                    this._mediaObject.xGoogleFlag = 'conference';
                }
                break;
            }
            case 'application': {
                // New spec.
                if (typeof offerMediaObject.sctpPort === 'number') {
                    this._mediaObject.payloads = 'webrtc-datachannel';
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                }
                // Old spec.
                else if (offerMediaObject.sctpmap) {
                    this._mediaObject.payloads = sctpParameters.port;
                    this._mediaObject.sctpmap = {
                        app: 'webrtc-datachannel',
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize,
                    };
                }
                break;
            }
        }
    }
    setDtlsRole(role) {
        switch (role) {
            case 'client': {
                this._mediaObject.setup = 'active';
                break;
            }
            case 'server': {
                this._mediaObject.setup = 'passive';
                break;
            }
            case 'auto': {
                this._mediaObject.setup = 'actpass';
                break;
            }
        }
    }
    resume() {
        this._mediaObject.direction = 'recvonly';
    }
    muxSimulcastStreams(encodings) {
        if (!this._mediaObject.simulcast?.list1) {
            return;
        }
        const layers = {};
        for (const encoding of encodings) {
            if (encoding.rid) {
                layers[encoding.rid] = encoding;
            }
        }
        const raw = this._mediaObject.simulcast.list1;
        const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
        for (const simulcastStream of simulcastStreams) {
            for (const simulcastFormat of simulcastStream) {
                simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
            }
        }
        this._mediaObject.simulcast.list1 = simulcastStreams
            .map(simulcastFormats => simulcastFormats.map(f => `${f.paused ? '~' : ''}${f.scid}`).join(','))
            .join(';');
    }
}
exports.AnswerMediaSection = AnswerMediaSection;
class OfferMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false, }) {
        super({ iceParameters, iceCandidates, dtlsParameters, planB });
        this._mediaObject.mid = String(mid);
        this._mediaObject.type = kind;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            if (!sctpParameters) {
                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
            }
            else {
                this._mediaObject.protocol = 'UDP/DTLS/SCTP';
            }
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
            };
            this._mediaObject.protocol = 'RTP/AVP';
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (kind) {
            case 'audio':
            case 'video': {
                this._mediaObject.direction = 'sendonly';
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                if (!this._planB) {
                    this._mediaObject.msid = `${streamId ?? '-'} ${trackId}`;
                }
                for (const codec of offerRtpParameters.codecs) {
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate,
                    };
                    if (codec.channels > 1) {
                        rtp.encoding = codec.channels;
                    }
                    this._mediaObject.rtp.push(rtp);
                    const fmtp = {
                        payload: codec.payloadType,
                        config: '',
                    };
                    for (const key of Object.keys(codec.parameters)) {
                        if (fmtp.config) {
                            fmtp.config += ';';
                        }
                        fmtp.config += `${key}=${codec.parameters[key]}`;
                    }
                    if (fmtp.config) {
                        this._mediaObject.fmtp.push(fmtp);
                    }
                    for (const fb of codec.rtcpFeedback) {
                        this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter,
                        });
                    }
                }
                this._mediaObject.payloads = offerRtpParameters.codecs
                    .map((codec) => codec.payloadType)
                    .join(' ');
                this._mediaObject.ext = [];
                for (const ext of offerRtpParameters.headerExtensions) {
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id,
                    });
                }
                this._mediaObject.rtcpMux = 'rtcp-mux';
                this._mediaObject.rtcpRsize = 'rtcp-rsize';
                const encoding = offerRtpParameters.encodings[0];
                const ssrc = encoding.ssrc;
                const rtxSsrc = encoding.rtx?.ssrc;
                this._mediaObject.ssrcs = [];
                this._mediaObject.ssrcGroups = [];
                if (offerRtpParameters.rtcp.cname) {
                    this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: 'cname',
                        value: offerRtpParameters.rtcp.cname,
                    });
                }
                if (this._planB) {
                    this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: 'msid',
                        value: `${streamId ?? '-'} ${trackId}`,
                    });
                }
                if (rtxSsrc) {
                    if (offerRtpParameters.rtcp.cname) {
                        this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: 'cname',
                            value: offerRtpParameters.rtcp.cname,
                        });
                    }
                    if (this._planB) {
                        this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: 'msid',
                            value: `${streamId ?? '-'} ${trackId}`,
                        });
                    }
                    // Associate original and retransmission SSRCs.
                    this._mediaObject.ssrcGroups.push({
                        semantics: 'FID',
                        ssrcs: `${ssrc} ${rtxSsrc}`,
                    });
                }
                break;
            }
            case 'application': {
                // New spec.
                if (!oldDataChannelSpec) {
                    this._mediaObject.payloads = 'webrtc-datachannel';
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                }
                // Old spec.
                else {
                    this._mediaObject.payloads = sctpParameters.port;
                    this._mediaObject.sctpmap = {
                        app: 'webrtc-datachannel',
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize,
                    };
                }
                break;
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setDtlsRole(role) {
        // Always 'actpass'.
        this._mediaObject.setup = 'actpass';
    }
    resume() {
        this._mediaObject.direction = 'sendonly';
    }
    planBReceive({ offerRtpParameters, streamId, trackId, }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = encoding.rtx?.ssrc;
        const payloads = this._mediaObject.payloads.split(' ');
        for (const codec of offerRtpParameters.codecs) {
            if (payloads.includes(String(codec.payloadType))) {
                continue;
            }
            const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate,
            };
            if (codec.channels > 1) {
                rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
                payload: codec.payloadType,
                config: '',
            };
            for (const key of Object.keys(codec.parameters)) {
                if (fmtp.config) {
                    fmtp.config += ';';
                }
                fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) {
                this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codec.rtcpFeedback) {
                this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter,
                });
            }
        }
        this._mediaObject.payloads += ` ${offerRtpParameters.codecs
            .filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType))
            .map((codec) => codec.payloadType)
            .join(' ')}`;
        this._mediaObject.payloads = this._mediaObject.payloads.trim();
        if (offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
                id: ssrc,
                attribute: 'cname',
                value: offerRtpParameters.rtcp.cname,
            });
        }
        this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId ?? '-'} ${trackId}`,
        });
        if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: 'cname',
                    value: offerRtpParameters.rtcp.cname,
                });
            }
            this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'msid',
                value: `${streamId ?? '-'} ${trackId}`,
            });
            // Associate original and retransmission SSRCs.
            this._mediaObject.ssrcGroups.push({
                semantics: 'FID',
                ssrcs: `${ssrc} ${rtxSsrc}`,
            });
        }
    }
    planBStopReceiving({ offerRtpParameters, }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = encoding.rtx?.ssrc;
        this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
        if (rtxSsrc) {
            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
        }
    }
}
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    return mimeTypeMatch[2];
}

},{"../../utils":65,"sdp-transform":70}],57:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteSdp = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../../Logger");
const MediaSection_1 = require("./MediaSection");
const logger = new Logger_1.Logger('RemoteSdp');
class RemoteSdp {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, }) {
        // MediaSection instances with same order as in the SDP.
        this._mediaSections = [];
        // MediaSection indices indexed by MID.
        this._midToIndex = new Map();
        this._iceParameters = iceParameters;
        this._iceCandidates = iceCandidates;
        this._dtlsParameters = dtlsParameters;
        this._sctpParameters = sctpParameters;
        this._plainRtpParameters = plainRtpParameters;
        this._planB = planB;
        this._sdpObject = {
            version: 0,
            origin: {
                address: '0.0.0.0',
                ipVer: 4,
                netType: 'IN',
                sessionId: 10000,
                sessionVersion: 0,
                username: 'mediasoup-client',
            },
            name: '-',
            timing: { start: 0, stop: 0 },
            media: [],
        };
        // If ICE parameters are given, add ICE-Lite indicator.
        if (iceParameters?.iceLite) {
            this._sdpObject.icelite = 'ice-lite';
        }
        // If DTLS parameters are given, assume WebRTC and BUNDLE.
        if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };
            // NOTE: We take the latest fingerprint.
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
                type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                hash: dtlsParameters.fingerprints[numFingerprints - 1].value,
            };
            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];
        }
        // If there are plain RPT parameters, override SDP origin.
        if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
        }
    }
    updateIceParameters(iceParameters) {
        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
        this._iceParameters = iceParameters;
        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
        }
    }
    updateDtlsRole(role) {
        logger.debug('updateDtlsRole() [role:%s]', role);
        this._dtlsParameters.role = role;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
        }
    }
    getNextMediaSectionIdx() {
        // If a closed media section is found, return its index.
        for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) {
                return { idx, reuseMid: mediaSection.mid };
            }
        }
        // If no closed media section is found, return next one.
        return { idx: this._mediaSections.length };
    }
    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false, }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed,
        });
        // Unified-Plan with closed media section replacement.
        if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
        }
        // Unified-Plan or Plan-B with different media kind.
        else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
        }
        // Plan-B with same media kind.
        else {
            this._replaceMediaSection(mediaSection);
        }
    }
    receive({ mid, kind, offerRtpParameters, streamId, trackId, }) {
        const idx = this._midToIndex.get(mid);
        let mediaSection;
        if (idx !== undefined) {
            mediaSection = this._mediaSections[idx];
        }
        // Unified-Plan or different media kind.
        if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
                iceParameters: this._iceParameters,
                iceCandidates: this._iceCandidates,
                dtlsParameters: this._dtlsParameters,
                plainRtpParameters: this._plainRtpParameters,
                planB: this._planB,
                mid,
                kind,
                offerRtpParameters,
                streamId,
                trackId,
            });
            // Let's try to recycle a closed media section (if any).
            // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
            const oldMediaSection = this._mediaSections.find(m => m.closed);
            if (oldMediaSection) {
                this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            }
            else {
                this._addMediaSection(mediaSection);
            }
        }
        // Plan-B.
        else {
            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
            this._replaceMediaSection(mediaSection);
        }
    }
    pauseMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.pause();
    }
    resumeSendingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    resumeReceivingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    disableMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
    closeMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        // NOTE: Closing the first m section is a pain since it invalidates the
        // bundled transport, so let's avoid it.
        if (mid === this._firstMid) {
            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
            this.disableMediaSection(mid);
            return false;
        }
        mediaSection.close();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
        return true;
    }
    muxMediaSectionSimulcast(mid, encodings) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.muxSimulcastStreams(encodings);
        this._replaceMediaSection(mediaSection);
    }
    planBStopReceiving({ mid, offerRtpParameters, }) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.planBStopReceiving({ offerRtpParameters });
        this._replaceMediaSection(mediaSection);
    }
    sendSctpAssociation({ offerMediaObject }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject,
        });
        this._addMediaSection(mediaSection);
    }
    receiveSctpAssociation({ oldDataChannelSpec = false, } = {}) {
        const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: 'datachannel',
            kind: 'application',
            oldDataChannelSpec,
        });
        this._addMediaSection(mediaSection);
    }
    getSdp() {
        // Increase SDP version.
        this._sdpObject.origin.sessionVersion++;
        return sdpTransform.write(this._sdpObject);
    }
    _addMediaSection(newMediaSection) {
        if (!this._firstMid) {
            this._firstMid = newMediaSection.mid;
        }
        // Add to the vector.
        this._mediaSections.push(newMediaSection);
        // Add to the map.
        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
        // Add to the SDP object.
        this._sdpObject.media.push(newMediaSection.getObject());
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
    }
    _replaceMediaSection(newMediaSection, reuseMid) {
        // Store it in the map.
        if (typeof reuseMid === 'string') {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === undefined) {
                throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the map.
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
        }
        else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === undefined) {
                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
        }
    }
    _findMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) {
            throw new Error(`no media section found with mid '${mid}'`);
        }
        return this._mediaSections[idx];
    }
    _regenerateBundleMids() {
        if (!this._dtlsParameters) {
            return;
        }
        this._sdpObject.groups[0].mids = this._mediaSections
            .filter((mediaSection) => !mediaSection.closed)
            .map((mediaSection) => mediaSection.mid)
            .join(' ');
    }
}
exports.RemoteSdp = RemoteSdp;

},{"../../Logger":34,"./MediaSection":56,"sdp-transform":70}],58:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractRtpCapabilities = extractRtpCapabilities;
exports.extractDtlsParameters = extractDtlsParameters;
exports.getCname = getCname;
exports.applyCodecParameters = applyCodecParameters;
const sdpTransform = __importStar(require("sdp-transform"));
/**
 * This function must be called with an SDP with 1 m=audio and 1 m=video
 * sections.
 */
function extractRtpCapabilities({ sdpObject, }) {
    // Map of RtpCodecParameters indexed by payload type.
    const codecsMap = new Map();
    // Array of RtpHeaderExtensions.
    const headerExtensions = [];
    // Whether a m=audio/video section has been already found.
    let gotAudio = false;
    let gotVideo = false;
    for (const m of sdpObject.media) {
        const kind = m.type;
        switch (kind) {
            case 'audio': {
                if (gotAudio) {
                    continue;
                }
                gotAudio = true;
                break;
            }
            case 'video': {
                if (gotVideo) {
                    continue;
                }
                gotVideo = true;
                break;
            }
            default: {
                continue;
            }
        }
        // Get codecs.
        for (const rtp of m.rtp) {
            const codec = {
                kind: kind,
                mimeType: `${kind}/${rtp.codec}`,
                preferredPayloadType: rtp.payload,
                clockRate: rtp.rate,
                channels: rtp.encoding,
                parameters: {},
                rtcpFeedback: [],
            };
            codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
        for (const fmtp of m.fmtp || []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) {
                continue;
            }
            // Specials case to convert parameter value to string.
            if (parameters?.hasOwnProperty('profile-level-id')) {
                parameters['profile-level-id'] = String(parameters['profile-level-id']);
            }
            codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
        for (const fb of m.rtcpFb || []) {
            const feedback = {
                type: fb.type,
                parameter: fb.subtype,
            };
            if (!feedback.parameter) {
                delete feedback.parameter;
            }
            // rtcp-fb payload is not '*', so just apply it to its corresponding
            // codec.
            if (fb.payload !== '*') {
                const codec = codecsMap.get(fb.payload);
                if (!codec) {
                    continue;
                }
                codec.rtcpFeedback.push(feedback);
            }
            // If rtcp-fb payload is '*' it must be applied to all codecs with same
            // kind (with some exceptions such as RTX codec).
            else {
                for (const codec of codecsMap.values()) {
                    if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                        codec.rtcpFeedback.push(feedback);
                    }
                }
            }
        }
        // Get RTP header extensions.
        for (const ext of m.ext || []) {
            // Ignore encrypted extensions (not yet supported in mediasoup).
            if (ext['encrypt-uri']) {
                continue;
            }
            const headerExtension = {
                kind: kind,
                uri: ext.uri,
                preferredId: ext.value,
            };
            headerExtensions.push(headerExtension);
        }
    }
    const rtpCapabilities = {
        codecs: Array.from(codecsMap.values()),
        headerExtensions: headerExtensions,
    };
    return rtpCapabilities;
}
function extractDtlsParameters({ sdpObject, }) {
    let setup = sdpObject.setup;
    let fingerprint = sdpObject.fingerprint;
    if (!setup || !fingerprint) {
        const mediaObject = (sdpObject.media || []).find((m) => m.port !== 0);
        if (mediaObject) {
            setup ?? (setup = mediaObject.setup);
            fingerprint ?? (fingerprint = mediaObject.fingerprint);
        }
    }
    if (!setup) {
        throw new Error('no a=setup found at SDP session or media level');
    }
    else if (!fingerprint) {
        throw new Error('no a=fingerprint found at SDP session or media level');
    }
    let role;
    switch (setup) {
        case 'active': {
            role = 'client';
            break;
        }
        case 'passive': {
            role = 'server';
            break;
        }
        case 'actpass': {
            role = 'auto';
            break;
        }
    }
    const dtlsParameters = {
        role,
        fingerprints: [
            {
                algorithm: fingerprint.type,
                value: fingerprint.hash,
            },
        ],
    };
    return dtlsParameters;
}
function getCname({ offerMediaObject, }) {
    const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine) {
        return '';
    }
    return ssrcCnameLine.value;
}
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters({ offerRtpParameters, answerMediaObject, }) {
    for (const codec of offerRtpParameters.codecs) {
        const mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus') {
            continue;
        }
        const rtp = (answerMediaObject.rtp || []).find((r) => r.payload === codec.payloadType);
        if (!rtp) {
            continue;
        }
        // Just in case.
        answerMediaObject.fmtp = answerMediaObject.fmtp || [];
        let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
        if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: '' };
            answerMediaObject.fmtp.push(fmtp);
        }
        const parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
            case 'audio/opus': {
                const spropStereo = codec.parameters['sprop-stereo'];
                if (spropStereo !== undefined) {
                    parameters.stereo = Number(spropStereo) ? 1 : 0;
                }
                break;
            }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (const key of Object.keys(parameters)) {
            if (fmtp.config) {
                fmtp.config += ';';
            }
            fmtp.config += `${key}=${parameters[key]}`;
        }
    }
}

},{"sdp-transform":70}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings({ offerMediaObject, track, }) {
    // First media SSRC (or the only one).
    let firstSsrc;
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []) {
        if (line.attribute !== 'msid') {
            continue;
        }
        const trackId = line.value.split(' ')[1];
        if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
            if (!firstSsrc) {
                firstSsrc = ssrc;
            }
        }
    }
    if (ssrcs.size === 0) {
        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    }
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []) {
        if (line.semantics !== 'FID') {
            continue;
        }
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know that they
            // are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, null);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
        }
        encodings.push(encoding);
    }
    return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, track, numStreams, }) {
    if (numStreams <= 1) {
        throw new TypeError('numStreams must be greater than 1');
    }
    let firstSsrc;
    let firstRtxSsrc;
    let streamId;
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {
        if (line.attribute !== 'msid') {
            return false;
        }
        const trackId = line.value.split(' ')[1];
        if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(' ')[0];
            return true;
        }
        else {
            return false;
        }
    });
    if (!ssrcMsidLine) {
        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    }
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || []).some((line) => {
        if (line.semantics !== 'FID') {
            return false;
        }
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === 'cname' && line.id === firstSsrc);
    if (!ssrcCnameLine) {
        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
    }
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
        }
    }
    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' '),
    });
    for (const ssrc of ssrcs) {
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${track.id}`,
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${track.id}`,
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`,
        });
    }
}

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings({ offerMediaObject, }) {
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []) {
        const ssrc = line.id;
        ssrcs.add(ssrc);
    }
    if (ssrcs.size === 0) {
        throw new Error('no a=ssrc lines found');
    }
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []) {
        if (line.semantics !== 'FID') {
            continue;
        }
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know
            // that they are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so
    // take media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, null);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
        }
        encodings.push(encoding);
    }
    return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, numStreams, }) {
    if (numStreams <= 1) {
        throw new TypeError('numStreams must be greater than 1');
    }
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === 'msid');
    if (!ssrcMsidLine) {
        throw new Error('a=ssrc line with msid information not found');
    }
    const [streamId, trackId] = ssrcMsidLine.value.split(' ');
    const firstSsrc = Number(ssrcMsidLine.id);
    let firstRtxSsrc;
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || []).some((line) => {
        if (line.semantics !== 'FID') {
            return false;
        }
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine) {
        throw new Error('a=ssrc line with cname information not found');
    }
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
        }
    }
    offerMediaObject.ssrcGroups = [];
    offerMediaObject.ssrcs = [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' '),
    });
    for (const ssrc of ssrcs) {
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`,
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`,
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`,
        });
    }
}

},{}],61:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
const debug_1 = __importDefault(require("debug"));
exports.debug = debug_1.default;
const Device_1 = require("./Device");
Object.defineProperty(exports, "Device", { enumerable: true, get: function () { return Device_1.Device; } });
Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function () { return Device_1.detectDevice; } });
const types = __importStar(require("./types"));
exports.types = types;
/**
 * Expose mediasoup-client version.
 */
exports.version = '3.8.1';
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = require("./scalabilityModes");
Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function () { return scalabilityModes_1.parse; } });

},{"./Device":33,"./scalabilityModes":63,"./types":64,"debug":5}],62:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRtpCapabilities = validateRtpCapabilities;
exports.validateRtpParameters = validateRtpParameters;
exports.validateSctpStreamParameters = validateSctpStreamParameters;
exports.validateSctpCapabilities = validateSctpCapabilities;
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
exports.getSendingRtpParameters = getSendingRtpParameters;
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
exports.reduceCodecs = reduceCodecs;
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
exports.canSend = canSend;
exports.canReceive = canReceive;
const h264 = __importStar(require("h264-profile-level-id"));
const utils = __importStar(require("./utils"));
const RTP_PROBATOR_MID = 'probator';
const RTP_PROBATOR_SSRC = 1234;
const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // codecs is optional. If unset, fill with an empty array.
    if (caps.codecs && !Array.isArray(caps.codecs)) {
        throw new TypeError('caps.codecs is not an array');
    }
    else if (!caps.codecs) {
        caps.codecs = [];
    }
    for (const codec of caps.codecs) {
        validateRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
        throw new TypeError('caps.headerExtensions is not an array');
    }
    else if (!caps.headerExtensions) {
        caps.headerExtensions = [];
    }
    for (const ext of caps.headerExtensions) {
        validateRtpHeaderExtension(ext);
    }
}
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // mid is optional.
    if (params.mid && typeof params.mid !== 'string') {
        throw new TypeError('params.mid is not a string');
    }
    // codecs is mandatory.
    if (!Array.isArray(params.codecs)) {
        throw new TypeError('missing params.codecs');
    }
    for (const codec of params.codecs) {
        validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
        throw new TypeError('params.headerExtensions is not an array');
    }
    else if (!params.headerExtensions) {
        params.headerExtensions = [];
    }
    for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings && !Array.isArray(params.encodings)) {
        throw new TypeError('params.encodings is not an array');
    }
    else if (!params.encodings) {
        params.encodings = [];
    }
    for (const encoding of params.encodings) {
        validateRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
    if (params.rtcp && typeof params.rtcp !== 'object') {
        throw new TypeError('params.rtcp is not an object');
    }
    else if (!params.rtcp) {
        params.rtcp = {};
    }
    validateRtcpParameters(params.rtcp);
}
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpStreamParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // streamId is mandatory.
    if (typeof params.streamId !== 'number') {
        throw new TypeError('missing params.streamId');
    }
    // ordered is optional.
    let orderedGiven = false;
    if (typeof params.ordered === 'boolean') {
        orderedGiven = true;
    }
    else {
        params.ordered = true;
    }
    // maxPacketLifeTime is optional.
    if (params.maxPacketLifeTime &&
        typeof params.maxPacketLifeTime !== 'number') {
        throw new TypeError('invalid params.maxPacketLifeTime');
    }
    // maxRetransmits is optional.
    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {
        throw new TypeError('invalid params.maxRetransmits');
    }
    if (params.maxPacketLifeTime && params.maxRetransmits) {
        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
    }
    if (orderedGiven &&
        params.ordered &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
    }
    else if (!orderedGiven &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        params.ordered = false;
    }
    // label is optional.
    if (params.label && typeof params.label !== 'string') {
        throw new TypeError('invalid params.label');
    }
    // protocol is optional.
    if (params.protocol && typeof params.protocol !== 'string') {
        throw new TypeError('invalid params.protocol');
    }
}
/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // numStreams is mandatory.
    if (!caps.numStreams || typeof caps.numStreams !== 'object') {
        throw new TypeError('missing caps.numStreams');
    }
    validateNumSctpStreams(caps.numStreams);
}
/**
 * Generate extended RTP capabilities for sending and receiving.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps) {
    const extendedRtpCapabilities = {
        codecs: [],
        headerExtensions: [],
    };
    // Match media codecs and keep the order preferred by remoteCaps.
    for (const remoteCodec of remoteCaps.codecs ?? []) {
        if (isRtxCodec(remoteCodec)) {
            continue;
        }
        const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
        if (!matchingLocalCodec) {
            continue;
        }
        const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
    }
    // Match RTX codecs.
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) &&
            localCodec.parameters.apt === extendedCodec.localPayloadType);
        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) &&
            remoteCodec.parameters.apt === extendedCodec.remotePayloadType);
        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType =
                matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType =
                matchingRemoteRtxCodec.preferredPayloadType;
        }
    }
    // Match header extensions.
    for (const remoteExt of remoteCaps.headerExtensions) {
        const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
        if (!matchingLocalExt) {
            continue;
        }
        const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: 'sendrecv',
        };
        switch (remoteExt.direction) {
            case 'sendrecv': {
                extendedExt.direction = 'sendrecv';
                break;
            }
            case 'recvonly': {
                extendedExt.direction = 'sendonly';
                break;
            }
            case 'sendonly': {
                extendedExt.direction = 'recvonly';
                break;
            }
            case 'inactive': {
                extendedExt.direction = 'inactive';
                break;
            }
        }
        extendedRtpCapabilities.headerExtensions.push(extendedExt);
    }
    return extendedRtpCapabilities;
}
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
    const rtpCapabilities = {
        codecs: [],
        headerExtensions: [],
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpCapabilities.codecs.push(codec);
        // Add RTX codec.
        if (!extendedCodec.remoteRtxPayloadType) {
            continue;
        }
        const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
                apt: extendedCodec.remotePayloadType,
            },
            rtcpFeedback: [],
        };
        rtpCapabilities.codecs.push(rtxCodec);
        // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions not valid for receiving.
        if (extendedExtension.direction !== 'sendrecv' &&
            extendedExtension.direction !== 'recvonly') {
            continue;
        }
        const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction,
        };
        rtpCapabilities.headerExtensions.push(ext);
    }
    return rtpCapabilities;
}
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
            continue;
        }
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {},
        };
        rtpParameters.headerExtensions.push(ext);
    }
    return rtpParameters;
}
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
            continue;
        }
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {},
        };
        rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
    if (rtpParameters.headerExtensions.some(ext => ext.uri ===
        'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'goog-remb');
        }
    }
    else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'transport-cc');
        }
    }
    else {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');
        }
    }
    return rtpParameters;
}
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
    const filteredCodecs = [];
    // If no capability codec is given, take the first one (and RTX).
    if (!capCodec) {
        filteredCodecs.push(codecs[0]);
        if (isRtxCodec(codecs[1])) {
            filteredCodecs.push(codecs[1]);
        }
    }
    // Otherwise look for a compatible set of codecs.
    else {
        for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
                filteredCodecs.push(codecs[idx]);
                if (isRtxCodec(codecs[idx + 1])) {
                    filteredCodecs.push(codecs[idx + 1]);
                }
                break;
            }
        }
        if (filteredCodecs.length === 0) {
            throw new TypeError('no matching codec found');
        }
    }
    return filteredCodecs;
}
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
    // Clone given reference video RTP parameters.
    videoRtpParameters = utils.clone(videoRtpParameters);
    // This may throw.
    validateRtpParameters(videoRtpParameters);
    const rtpParameters = {
        mid: RTP_PROBATOR_MID,
        codecs: [],
        headerExtensions: [],
        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
        rtcp: { cname: 'probator' },
    };
    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
    return rtpParameters;
}
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, extendedRtpCapabilities) {
    return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);
}
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, extendedRtpCapabilities) {
    // This may throw.
    validateRtpParameters(rtpParameters);
    if (rtpParameters.codecs.length === 0) {
        return false;
    }
    const firstMediaCodec = rtpParameters.codecs[0];
    return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
}
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // Just override kind with media component of mimeType.
    codec.kind = mimeTypeMatch[1].toLowerCase();
    // preferredPayloadType is optional.
    if (codec.preferredPayloadType &&
        typeof codec.preferredPayloadType !== 'number') {
        throw new TypeError('invalid codec.preferredPayloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    // channels is optional. If unset, set it to 1 (just if audio).
    if (codec.kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpFeedback(fb) {
    if (typeof fb !== 'object') {
        throw new TypeError('fb is not an object');
    }
    // type is mandatory.
    if (!fb.type || typeof fb.type !== 'string') {
        throw new TypeError('missing fb.type');
    }
    // parameter is optional. If unset set it to an empty string.
    if (!fb.parameter || typeof fb.parameter !== 'string') {
        fb.parameter = '';
    }
}
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtension(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // kind is mandatory.
    if (ext.kind !== 'audio' && ext.kind !== 'video') {
        throw new TypeError('invalid ext.kind');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // preferredId is mandatory.
    if (typeof ext.preferredId !== 'number') {
        throw new TypeError('missing ext.preferredId');
    }
    // preferredEncrypt is optional. If unset set it to false.
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {
        throw new TypeError('invalid ext.preferredEncrypt');
    }
    else if (!ext.preferredEncrypt) {
        ext.preferredEncrypt = false;
    }
    // direction is optional. If unset set it to sendrecv.
    if (ext.direction && typeof ext.direction !== 'string') {
        throw new TypeError('invalid ext.direction');
    }
    else if (!ext.direction) {
        ext.direction = 'sendrecv';
    }
}
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // payloadType is mandatory.
    if (typeof codec.payloadType !== 'number') {
        throw new TypeError('missing codec.payloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    const kind = mimeTypeMatch[1].toLowerCase();
    // channels is optional. If unset, set it to 1 (just if audio).
    if (kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // id is mandatory.
    if (typeof ext.id !== 'number') {
        throw new TypeError('missing ext.id');
    }
    // encrypt is optional. If unset set it to false.
    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {
        throw new TypeError('invalid ext.encrypt');
    }
    else if (!ext.encrypt) {
        ext.encrypt = false;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!ext.parameters || typeof ext.parameters !== 'object') {
        ext.parameters = {};
    }
    for (const key of Object.keys(ext.parameters)) {
        let value = ext.parameters[key];
        if (value === undefined) {
            ext.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError('invalid header extension parameter');
        }
    }
}
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpEncodingParameters(encoding) {
    if (typeof encoding !== 'object') {
        throw new TypeError('encoding is not an object');
    }
    // ssrc is optional.
    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {
        throw new TypeError('invalid encoding.ssrc');
    }
    // rid is optional.
    if (encoding.rid && typeof encoding.rid !== 'string') {
        throw new TypeError('invalid encoding.rid');
    }
    // rtx is optional.
    if (encoding.rtx && typeof encoding.rtx !== 'object') {
        throw new TypeError('invalid encoding.rtx');
    }
    else if (encoding.rtx) {
        // RTX ssrc is mandatory if rtx is present.
        if (typeof encoding.rtx.ssrc !== 'number') {
            throw new TypeError('missing encoding.rtx.ssrc');
        }
    }
    // dtx is optional. If unset set it to false.
    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {
        encoding.dtx = false;
    }
    // scalabilityMode is optional.
    if (encoding.scalabilityMode &&
        typeof encoding.scalabilityMode !== 'string') {
        throw new TypeError('invalid encoding.scalabilityMode');
    }
}
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpParameters(rtcp) {
    if (typeof rtcp !== 'object') {
        throw new TypeError('rtcp is not an object');
    }
    // cname is optional.
    if (rtcp.cname && typeof rtcp.cname !== 'string') {
        throw new TypeError('invalid rtcp.cname');
    }
    // reducedSize is optional. If unset set it to true.
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {
        rtcp.reducedSize = true;
    }
}
/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
    if (typeof numStreams !== 'object') {
        throw new TypeError('numStreams is not an object');
    }
    // OS is mandatory.
    if (typeof numStreams.OS !== 'number') {
        throw new TypeError('missing numStreams.OS');
    }
    // MIS is mandatory.
    if (typeof numStreams.MIS !== 'number') {
        throw new TypeError('missing numStreams.MIS');
    }
}
function isRtxCodec(codec) {
    if (!codec) {
        return false;
    }
    return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType) {
        return false;
    }
    if (aCodec.clockRate !== bCodec.clockRate) {
        return false;
    }
    if (aCodec.channels !== bCodec.channels) {
        return false;
    }
    // Per codec special checks.
    switch (aMimeType) {
        case 'video/h264': {
            if (strict) {
                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;
                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;
                if (aPacketizationMode !== bPacketizationMode) {
                    return false;
                }
                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                    return false;
                }
                let selectedProfileLevelId;
                try {
                    selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
                }
                catch (error) {
                    return false;
                }
                if (modify) {
                    if (selectedProfileLevelId) {
                        aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                        bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                    }
                    else {
                        delete aCodec.parameters['profile-level-id'];
                        delete bCodec.parameters['profile-level-id'];
                    }
                }
            }
            break;
        }
        case 'video/vp9': {
            if (strict) {
                const aProfileId = aCodec.parameters['profile-id'] || 0;
                const bProfileId = bCodec.parameters['profile-id'] || 0;
                if (aProfileId !== bProfileId) {
                    return false;
                }
            }
            break;
        }
    }
    return true;
}
function matchHeaderExtensions(aExt, bExt) {
    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
        return false;
    }
    if (aExt.uri !== bExt.uri) {
        return false;
    }
    return true;
}
function reduceRtcpFeedback(codecA, codecB) {
    const reducedRtcpFeedback = [];
    for (const aFb of codecA.rtcpFeedback ?? []) {
        const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type &&
            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter)));
        if (matchingBFb) {
            reducedRtcpFeedback.push(matchingBFb);
        }
    }
    return reducedRtcpFeedback;
}

},{"./utils":65,"h264-profile-level-id":29}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
const ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode ?? '');
    if (match) {
        return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2]),
        };
    }
    else {
        return {
            spatialLayers: 1,
            temporalLayers: 1,
        };
    }
}

},{}],64:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Device"), exports);
__exportStar(require("./Transport"), exports);
__exportStar(require("./Producer"), exports);
__exportStar(require("./Consumer"), exports);
__exportStar(require("./DataProducer"), exports);
__exportStar(require("./DataConsumer"), exports);
__exportStar(require("./RtpParameters"), exports);
__exportStar(require("./SctpParameters"), exports);
__exportStar(require("./handlers/HandlerInterface"), exports);
__exportStar(require("./errors"), exports);

},{"./Consumer":30,"./DataConsumer":31,"./DataProducer":32,"./Device":33,"./Producer":35,"./RtpParameters":36,"./SctpParameters":37,"./Transport":38,"./errors":40,"./handlers/HandlerInterface":49}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clone = clone;
exports.generateRandomNumber = generateRandomNumber;
exports.deepFreeze = deepFreeze;
/**
 * Clones the given value.
 */
function clone(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return NaN;
    }
    else if (typeof structuredClone === 'function') {
        // Available in Node >= 18.
        return structuredClone(value);
    }
    else {
        return JSON.parse(JSON.stringify(value));
    }
}
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
    return Math.round(Math.random() * 10000000);
}
/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */
function deepFreeze(object) {
    // Retrieve the property names defined on object.
    const propNames = Reflect.ownKeys(object);
    // Freeze properties before freezing self.
    for (const name of propNames) {
        const value = object[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}

},{}],66:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],67:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],68:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding)
          ? 'rtpmap:%d %s/%s/%s'
          : o.rate
            ? 'rtpmap:%d %s/%s'
            : 'rtpmap:%d %s';
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    {
      // a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null)
          ? 'rtcp:%d %s IP%d %s'
          : 'rtcp:%d';
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%s trr-int %d'
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null)
          ? 'rtcp-fb:%s %s %s'
          : 'rtcp-fb:%s %s';
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
      format: function (o) {
        return (
          'extmap:%d' +
          (o.direction ? '/%s' : '%v') +
          (o['encrypt-uri'] ? ' %s' : '%v') +
          ' %s' +
          (o.config ? ' %s' : '')
        );
      }
    },
    {
      // a=extmap-allow-mixed
      name: 'extmapAllowMixed',
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null)
          ? 'crypto:%d %s %s %s'
          : 'crypto:%d %s %s';
      }
    },
    {
      // a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    {
      // a=connection:new
      name: 'connectionType',
      reg: /^connection:(new|existing)/,
      format: 'connection:%s'
    },
    {
      // a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    {
      // a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: 'ptime:%d'
    },
    {
      // a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: 'maxptime:%d'
    },
    {
      // a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    {
      // a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    {
      // a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null)
          ? 'sctpmap:%s %s %s'
          : 'sctpmap:%s %s';
      }
    },
    {
      // a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        // a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        // recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        // a=simulcast:
        '^simulcast:' +
        // send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        // space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        // end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    {
      // a=bundle-only
      name: 'bundleOnly',
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: 'label',
      reg: /^label:(.+)/,
      format: 'label:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: 'sctpPort',
      reg: /^sctp-port:(\d+)$/,
      format: 'sctp-port:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: 'maxMessageSize',
      reg: /^max-message-size:(\d+)$/,
      format: 'max-message-size:%s'
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push:'tsRefClocks',
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ['clksrc', 'clksrcExt'],
      format: function (o) {
        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name:'mediaClk',
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
      format: function (o) {
        var str = 'mediaclk:';
        str += (o.id != null ? 'id=%s %s' : '%v%s');
        str += (o.mediaClockValue != null ? '=%s' : '');
        str += (o.rateNumerator != null ? ' rate=%s' : '');
        str += (o.rateDenominator != null ? '/%s' : '');
        return str;
      }
    },
    {
      // a=keywds:keywords
      name: 'keywords',
      reg: /^keywds:(.+)$/,
      format: 'keywds:%s'
    },
    {
      // a=content:main
      name: 'content',
      reg: /^content:(.+)/,
      format: 'content:%s'
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: 'bfcpFloorCtrl',
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: 'floorctrl:%s'
    },
    {
      // a=confid:1
      name: 'bfcpConfId',
      reg: /^confid:(\d+)/,
      format: 'confid:%s'
    },
    {
      // a=userid:1
      name: 'bfcpUserId',
      reg: /^userid:(\d+)/,
      format: 'userid:%s'
    },
    {
      // a=floorid:1
      name: 'bfcpFloorId',
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ['id', 'mStream'],
      format: 'floorid:%s mstrm:%s'
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

},{}],70:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');
var grammar = require('./grammar');

exports.grammar = grammar;
exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"./grammar":69,"./parser":71,"./writer":72}],71:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

},{"./grammar":69}],72:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":69}],73:[function(require,module,exports){
"use strict";
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backoff = Backoff;
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};

},{}],74:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

},{"./manager.js":75,"./socket.js":77,"./url.js":78,"debug":79,"engine.io-client":11,"socket.io-parser":82}],75:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const engine_io_client_1 = require("engine.io-client");
const socket_js_1 = require("./socket.js");
const parser = __importStar(require("socket.io-parser"));
const on_js_1 = require("./on.js");
const backo2_js_1 = require("./contrib/backo2.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:manager"); // debug()
class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0, engine_io_client_1.installTimerFunctions)(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
            this.skipReconnect = true;
        }
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0, on_js_1.on)(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        const onError = (err) => {
            debug("error");
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = (0, on_js_1.on)(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            // set timer
            const timer = this.setTimeoutFn(() => {
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0, on_js_1.on)(socket, "ping", this.onping.bind(this)), (0, on_js_1.on)(socket, "data", this.ondata.bind(this)), (0, on_js_1.on)(socket, "error", this.onerror.bind(this)), (0, on_js_1.on)(socket, "close", this.onclose.bind(this)), 
        // @ts-ignore
        (0, on_js_1.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0, engine_io_client_1.nextTick)(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_js_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */
    onclose(reason, description) {
        var _a;
        debug("closed due to %s", reason);
        this.cleanup();
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}
exports.Manager = Manager;

},{"./contrib/backo2.js":73,"./on.js":76,"./socket.js":77,"@socket.io/component-emitter":2,"debug":79,"engine.io-client":11,"socket.io-parser":82}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.on = on;
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}

},{}],77:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const socket_io_parser_1 = require("socket.io-parser");
const on_js_1 = require("./on.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class Socket extends component_emitter_1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            (0, on_js_1.on)(io, "open", this.onopen.bind(this)),
            (0, on_js_1.on)(io, "packet", this.onpacket.bind(this)),
            (0, on_js_1.on)(io, "error", this.onerror.bind(this)),
            (0, on_js_1.on)(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        var _a, _b, _c;
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            debug("emitting packet with ack id %d", id);
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        }
        else if (isConnected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    debug("removing packet with ack id %d from the buffer", id);
                    this.sendBuffer.splice(i, 1);
                }
            }
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            const fn = (arg1, arg2) => {
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                debug("packet [%d] was successfully sent", packet.id);
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        debug("draining queue");
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug("sending packet [%d] (try n°%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser_1.PacketType.EVENT:
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            debug("bad ack %s", packet.id);
            return;
        }
        delete this.acks[packet.id];
        debug("calling ack %s with %j", packet.id, packet.data);
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}
exports.Socket = Socket;

},{"./on.js":76,"@socket.io/component-emitter":2,"debug":79,"socket.io-parser":82}],78:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.url = url;
const engine_io_client_1 = require("engine.io-client");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = (0, engine_io_client_1.parse)(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}

},{"debug":79,"engine.io-client":11}],79:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":80,"_process":1}],80:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22,"ms":66}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructPacket = exports.deconstructPacket = void 0;
const is_binary_js_1 = require("./is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}

},{"./is-binary.js":83}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
const component_emitter_1 = require("@socket.io/component-emitter");
const binary_js_1 = require("./binary.js");
const is_binary_js_1 = require("./is-binary.js");
const debug_1 = require("debug"); // debug()
const debug = (0, debug_1.default)("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener", // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0, is_binary_js_1.hasBinary)(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
exports.Encoder = Encoder;
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends component_emitter_1.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        debug("decoded %s as %j", str, p);
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return (Array.isArray(payload) &&
                    (typeof payload[0] === "number" ||
                        (typeof payload[0] === "string" &&
                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
exports.Decoder = Decoder;
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}

},{"./binary.js":81,"./is-binary.js":83,"@socket.io/component-emitter":2,"debug":84}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasBinary = exports.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}
exports.hasBinary = hasBinary;

},{}],84:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":85,"_process":1}],85:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22,"ms":66}],86:[function(require,module,exports){
/* UAParser.js v2.0.1
   Copyright © 2012-2024 Faisal Salman <f@faisalman.com>
   AGPLv3 License */
((i,l)=>{function I(i){for(var e={},t=0;t<i.length;t++)e[i[t].toUpperCase()]=i[t];return e}var M=500,U="user-agent",w="",R="?",V="function",n="undefined",c="object",L="string",u="browser",h="cpu",p="device",m="engine",f="os",g="result",v="name",k="type",x="vendor",y="version",C="architecture",B="major",T="model",G="console",S="mobile",r="tablet",e="smarttv",t="wearable",F="xr",D="embedded",$="inapp",W="brands",_="formFactors",X="fullVersionList",q="platform",K="platformVersion",Q="bitness",o="sec-ch-ua",Z=o+"-full-version-list",Y=o+"-arch",J=o+"-"+Q,ii=o+"-form-factors",ei=o+"-"+S,ti=o+"-"+T,oi=o+"-"+q,ri=oi+"-version",ai=[W,X,S,T,q,K,C,_,Q],si="Amazon",a="Apple",ni="ASUS",wi="BlackBerry",s="Google",bi="Huawei",di="Microsoft",li="Motorola",ci="Nvidia",ui="OnePlus",hi="OPPO",pi="Samsung",mi="Sony",fi="Xiaomi",gi="Zebra",vi="Chromium",b="Chromecast",ki="Firefox",d="Opera",xi="Facebook",z="Mobile ",yi=" Browser",Ci="Windows",Ti=typeof i!==n,A=Ti&&i.navigator?i.navigator:l,O=A&&A.userAgentData?A.userAgentData:l,Si=function(i,e){if(typeof i===c&&0<i.length){for(var t in i)if(j(i[t])==j(e))return!0;return!1}return!!H(i)&&-1!==j(e).indexOf(j(i))},_i=function(i,e){for(var t in i)return/^(browser|cpu|device|engine|os)$/.test(t)||!!e&&_i(i[t])},H=function(i){return typeof i===L},qi=function(i){if(!i)return l;for(var e,t=[],o=Ai(/\\?\"/g,i).split(","),r=0;r<o.length;r++)-1<o[r].indexOf(";")?(e=Hi(o[r]).split(";v="),t[r]={brand:e[0],version:e[1]}):t[r]=Hi(o[r]);return t},j=function(i){return H(i)?i.toLowerCase():i},zi=function(i){return H(i)?Ai(/[^\d\.]/g,i).split(".")[0]:l},N=function(i){for(var e in i){e=i[e];typeof e==c&&2==e.length?this[e[0]]=e[1]:this[e]=l}return this},Ai=function(i,e){return H(e)?e.replace(i,w):e},Oi=function(i){return Ai(/\\?\"/g,i)},Hi=function(i,e){if(H(i))return i=Ai(/^\s\s*/,i),typeof e===n?i:i.substring(0,M)},ji=function(i,e){if(i&&e)for(var t,o,r,a,s,n=0;n<e.length&&!a;){for(var w=e[n],b=e[n+1],d=t=0;d<w.length&&!a&&w[d];)if(a=w[d++].exec(i))for(o=0;o<b.length;o++)s=a[++t],typeof(r=b[o])===c&&0<r.length?2===r.length?typeof r[1]==V?this[r[0]]=r[1].call(this,s):this[r[0]]=r[1]:3===r.length?typeof r[1]!==V||r[1].exec&&r[1].test?this[r[0]]=s?s.replace(r[1],r[2]):l:this[r[0]]=s?r[1].call(this,s,r[2]):l:4===r.length&&(this[r[0]]=s?r[3].call(this,s.replace(r[1],r[2])):l):this[r]=s||l;n+=2}},E=function(i,e){for(var t in e)if(typeof e[t]===c&&0<e[t].length){for(var o=0;o<e[t].length;o++)if(Si(e[t][o],i))return t===R?l:t}else if(Si(e[t],i))return t===R?l:t;return e.hasOwnProperty("*")?e["*"]:i},Ni={ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2e3:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"},Ei={embedded:"Automotive",mobile:"Mobile",tablet:["Tablet","EInk"],smarttv:"TV",wearable:"Watch",xr:["VR","XR"],"?":["Desktop","Unknown"],"*":l},Pi={browser:[[/\b(?:crmo|crios)\/([\w\.]+)/i],[y,[v,z+"Chrome"]],[/edg(?:e|ios|a)?\/([\w\.]+)/i],[y,[v,"Edge"]],[/(opera mini)\/([-\w\.]+)/i,/(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,/(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],[v,y],[/opios[\/ ]+([\w\.]+)/i],[y,[v,d+" Mini"]],[/\bop(?:rg)?x\/([\w\.]+)/i],[y,[v,d+" GX"]],[/\bopr\/([\w\.]+)/i],[y,[v,d]],[/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i],[y,[v,"Baidu"]],[/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i],[y,[v,"Maxthon"]],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,/(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,/(?:ms|\()(ie) ([\w\.]+)/i,/(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,/(heytap|ovi|115)browser\/([\d\.]+)/i,/(weibo)__([\d\.]+)/i],[v,y],[/quark(?:pc)?\/([-\w\.]+)/i],[y,[v,"Quark"]],[/\bddg\/([\w\.]+)/i],[y,[v,"DuckDuckGo"]],[/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],[y,[v,"UCBrowser"]],[/microm.+\bqbcore\/([\w\.]+)/i,/\bqbcore\/([\w\.]+).+microm/i,/micromessenger\/([\w\.]+)/i],[y,[v,"WeChat"]],[/konqueror\/([\w\.]+)/i],[y,[v,"Konqueror"]],[/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],[y,[v,"IE"]],[/ya(?:search)?browser\/([\w\.]+)/i],[y,[v,"Yandex"]],[/slbrowser\/([\w\.]+)/i],[y,[v,"Smart Lenovo"+yi]],[/(avast|avg)\/([\w\.]+)/i],[[v,/(.+)/,"$1 Secure"+yi],y],[/\bfocus\/([\w\.]+)/i],[y,[v,ki+" Focus"]],[/\bopt\/([\w\.]+)/i],[y,[v,d+" Touch"]],[/coc_coc\w+\/([\w\.]+)/i],[y,[v,"Coc Coc"]],[/dolfin\/([\w\.]+)/i],[y,[v,"Dolphin"]],[/coast\/([\w\.]+)/i],[y,[v,d+" Coast"]],[/miuibrowser\/([\w\.]+)/i],[y,[v,"MIUI"+yi]],[/fxios\/([\w\.-]+)/i],[y,[v,z+ki]],[/\bqihoobrowser\/?([\w\.]*)/i],[y,[v,"360"]],[/\b(qq)\/([\w\.]+)/i],[[v,/(.+)/,"$1Browser"],y],[/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i],[[v,/(.+)/,"$1"+yi],y],[/samsungbrowser\/([\w\.]+)/i],[y,[v,pi+" Internet"]],[/metasr[\/ ]?([\d\.]+)/i],[y,[v,"Sogou Explorer"]],[/(sogou)mo\w+\/([\d\.]+)/i],[[v,"Sogou Mobile"],y],[/(electron)\/([\w\.]+) safari/i,/(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,/m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i],[v,y],[/(lbbrowser|rekonq)/i],[v],[/ome\/([\w\.]+) \w* ?(iron) saf/i,/ome\/([\w\.]+).+qihu (360)[es]e/i],[y,v],[/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],[[v,xi],y,[k,$]],[/(Klarna)\/([\w\.]+)/i,/(kakao(?:talk|story))[\/ ]([\w\.]+)/i,/(naver)\(.*?(\d+\.[\w\.]+).*\)/i,/(daum)apps[\/ ]([\w\.]+)/i,/safari (line)\/([\w\.]+)/i,/\b(line)\/([\w\.]+)\/iab/i,/(alipay)client\/([\w\.]+)/i,/(twitter)(?:and| f.+e\/([\w\.]+))/i,/(instagram|snapchat)[\/ ]([-\w\.]+)/i],[v,y,[k,$]],[/\bgsa\/([\w\.]+) .*safari\//i],[y,[v,"GSA"],[k,$]],[/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],[y,[v,"TikTok"],[k,$]],[/\[(linkedin)app\]/i],[v,[k,$]],[/(chromium)[\/ ]([-\w\.]+)/i],[v,y],[/headlesschrome(?:\/([\w\.]+)| )/i],[y,[v,"Chrome Headless"]],[/ wv\).+(chrome)\/([\w\.]+)/i],[[v,"Chrome WebView"],y],[/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],[y,[v,"Android"+yi]],[/chrome\/([\w\.]+) mobile/i],[y,[v,z+"Chrome"]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],[v,y],[/version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i],[y,[v,z+"Safari"]],[/iphone .*mobile(?:\/\w+ | ?)safari/i],[[v,z+"Safari"]],[/version\/([\w\.\,]+) .*(safari)/i],[y,v],[/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],[v,[y,"1"]],[/(webkit|khtml)\/([\w\.]+)/i],[v,y],[/(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i],[[v,z+ki],y],[/(navigator|netscape\d?)\/([-\w\.]+)/i],[[v,"Netscape"],y],[/(wolvic|librewolf)\/([\w\.]+)/i],[v,y],[/mobile vr; rv:([\w\.]+)\).+firefox/i],[y,[v,ki+" Reality"]],[/ekiohf.+(flow)\/([\w\.]+)/i,/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,/(firefox)\/([\w\.]+)/i,/(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,/(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,/\b(links) \(([\w\.]+)/i],[v,[y,/_/g,"."]],[/(cobalt)\/([\w\.]+)/i],[v,[y,/[^\d\.]+./,w]]],cpu:[[/\b((amd|x|x86[-_]?|wow|win)64)\b/i],[[C,"amd64"]],[/(ia32(?=;))/i,/\b((i[346]|x)86)(pc)?\b/i],[[C,"ia32"]],[/\b(aarch64|arm(v?[89]e?l?|_?64))\b/i],[[C,"arm64"]],[/\b(arm(v[67])?ht?n?[fl]p?)\b/i],[[C,"armhf"]],[/( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i],[[C,"arm"]],[/((ppc|powerpc)(64)?)( mac|;|\))/i],[[C,/ower/,w,j]],[/ sun4\w[;\)]/i],[[C,"sparc"]],[/\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i],[[C,j]]],device:[[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],[T,[x,pi],[k,r]],[/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,/samsung[- ]((?!sm-[lr])[-\w]+)/i,/sec-(sgh\w+)/i],[T,[x,pi],[k,S]],[/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],[T,[x,a],[k,S]],[/\((ipad);[-\w\),; ]+apple/i,/applecoremedia\/[\w\.]+ \((ipad)/i,/\b(ipad)\d\d?,\d\d?[;\]].+ios/i],[T,[x,a],[k,r]],[/(macintosh);/i],[T,[x,a]],[/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],[T,[x,"Sharp"],[k,S]],[/\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i],[T,[x,"Honor"],[k,r]],[/honor([-\w ]+)[;\)]/i],[T,[x,"Honor"],[k,S]],[/\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i],[T,[x,bi],[k,r]],[/(?:huawei)([-\w ]+)[;\)]/i,/\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],[T,[x,bi],[k,S]],[/oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,/\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i],[[T,/_/g," "],[x,fi],[k,r]],[/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,/\b; (\w+) build\/hm\1/i,/\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,/\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,/oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,/\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i,/ ([\w ]+) miui\/v?\d/i],[[T,/_/g," "],[x,fi],[k,S]],[/; (\w+) bui.+ oppo/i,/\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],[T,[x,hi],[k,S]],[/\b(opd2(\d{3}a?))(?: bui|\))/i],[T,[x,E,{OnePlus:["304","403","203"],"*":hi}],[k,r]],[/vivo (\w+)(?: bui|\))/i,/\b(v[12]\d{3}\w?[at])(?: bui|;)/i],[T,[x,"Vivo"],[k,S]],[/\b(rmx[1-3]\d{3})(?: bui|;|\))/i],[T,[x,"Realme"],[k,S]],[/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,/\bmot(?:orola)?[- ](\w*)/i,/((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],[T,[x,li],[k,S]],[/\b(mz60\d|xoom[2 ]{0,2}) build\//i],[T,[x,li],[k,r]],[/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],[T,[x,"LG"],[k,r]],[/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,/\blg[-e;\/ ]+((?!browser|netcast|android tv|watch)\w+)/i,/\blg-?([\d\w]+) bui/i],[T,[x,"LG"],[k,S]],[/(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,/lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i],[T,[x,"Lenovo"],[k,r]],[/(nokia) (t[12][01])/i],[x,T,[k,r]],[/(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,/nokia[-_ ]?(([-\w\. ]*))/i],[[T,/_/g," "],[k,S],[x,"Nokia"]],[/(pixel (c|tablet))\b/i],[T,[x,s],[k,r]],[/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],[T,[x,s],[k,S]],[/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[T,[x,mi],[k,S]],[/sony tablet [ps]/i,/\b(?:sony)?sgp\w+(?: bui|\))/i],[[T,"Xperia Tablet"],[x,mi],[k,r]],[/ (kb2005|in20[12]5|be20[12][59])\b/i,/(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],[T,[x,ui],[k,S]],[/(alexa)webm/i,/(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,/(kf[a-z]+)( bui|\)).+silk\//i],[T,[x,si],[k,r]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],[[T,/(.+)/g,"Fire Phone $1"],[x,si],[k,S]],[/(playbook);[-\w\),; ]+(rim)/i],[T,x,[k,r]],[/\b((?:bb[a-f]|st[hv])100-\d)/i,/\(bb10; (\w+)/i],[T,[x,wi],[k,S]],[/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],[T,[x,ni],[k,r]],[/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],[T,[x,ni],[k,S]],[/(nexus 9)/i],[T,[x,"HTC"],[k,r]],[/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,/(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i],[x,[T,/_/g," "],[k,S]],[/tcl (xess p17aa)/i,/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i],[T,[x,"TCL"],[k,r]],[/droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i],[T,[x,"TCL"],[k,S]],[/(itel) ((\w+))/i],[[x,j],T,[k,E,{tablet:["p10001l","w7001"],"*":"mobile"}]],[/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],[T,[x,"Acer"],[k,r]],[/droid.+; (m[1-5] note) bui/i,/\bmz-([-\w]{2,})/i],[T,[x,"Meizu"],[k,S]],[/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i],[T,[x,"Ulefone"],[k,S]],[/; (energy ?\w+)(?: bui|\))/i,/; energizer ([\w ]+)(?: bui|\))/i],[T,[x,"Energizer"],[k,S]],[/; cat (b35);/i,/; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i],[T,[x,"Cat"],[k,S]],[/((?:new )?andromax[\w- ]+)(?: bui|\))/i],[T,[x,"Smartfren"],[k,S]],[/droid.+; (a(?:015|06[35]|142p?))/i],[T,[x,"Nothing"],[k,S]],[/(imo) (tab \w+)/i,/(infinix) (x1101b?)/i],[x,T,[k,r]],[/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,/; (hmd|imo) ([\w ]+?)(?: bui|\))/i,/(hp) ([\w ]+\w)/i,/(microsoft); (lumia[\w ]+)/i,/(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i,/(oppo) ?([\w ]+) bui/i],[x,T,[k,S]],[/(kobo)\s(ereader|touch)/i,/(archos) (gamepad2?)/i,/(hp).+(touchpad(?!.+tablet)|tablet)/i,/(kindle)\/([\w\.]+)/i],[x,T,[k,r]],[/(surface duo)/i],[T,[x,di],[k,r]],[/droid [\d\.]+; (fp\du?)(?: b|\))/i],[T,[x,"Fairphone"],[k,S]],[/((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i],[T,[x,ci],[k,r]],[/(sprint) (\w+)/i],[x,T,[k,S]],[/(kin\.[onetw]{3})/i],[[T,/\./g," "],[x,di],[k,S]],[/droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],[T,[x,gi],[k,r]],[/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],[T,[x,gi],[k,S]],[/smart-tv.+(samsung)/i],[x,[k,e]],[/hbbtv.+maple;(\d+)/i],[[T,/^/,"SmartTV"],[x,pi],[k,e]],[/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],[[x,"LG"],[k,e]],[/(apple) ?tv/i],[x,[T,a+" TV"],[k,e]],[/crkey.*devicetype\/chromecast/i],[[T,b+" Third Generation"],[x,s],[k,e]],[/crkey.*devicetype\/([^/]*)/i],[[T,/^/,"Chromecast "],[x,s],[k,e]],[/fuchsia.*crkey/i],[[T,b+" Nest Hub"],[x,s],[k,e]],[/crkey/i],[[T,b],[x,s],[k,e]],[/droid.+aft(\w+)( bui|\))/i],[T,[x,si],[k,e]],[/(shield \w+ tv)/i],[T,[x,ci],[k,e]],[/\(dtv[\);].+(aquos)/i,/(aquos-tv[\w ]+)\)/i],[T,[x,"Sharp"],[k,e]],[/(bravia[\w ]+)( bui|\))/i],[T,[x,mi],[k,e]],[/(mi(tv|box)-?\w+) bui/i],[T,[x,fi],[k,e]],[/Hbbtv.*(technisat) (.*);/i],[x,T,[k,e]],[/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,/hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i],[[x,Hi],[T,Hi],[k,e]],[/droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i],[T,[k,e]],[/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],[[k,e]],[/(ouya)/i,/(nintendo) (\w+)/i],[x,T,[k,G]],[/droid.+; (shield)( bui|\))/i],[T,[x,ci],[k,G]],[/(playstation \w+)/i],[T,[x,mi],[k,G]],[/\b(xbox(?: one)?(?!; xbox))[\); ]/i],[T,[x,di],[k,G]],[/\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i],[T,[x,pi],[k,t]],[/((pebble))app/i,/(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i],[x,T,[k,t]],[/(ow(?:19|20)?we?[1-3]{1,3})/i],[T,[x,hi],[k,t]],[/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],[T,[x,a],[k,t]],[/(opwwe\d{3})/i],[T,[x,ui],[k,t]],[/(moto 360)/i],[T,[x,li],[k,t]],[/(smartwatch 3)/i],[T,[x,mi],[k,t]],[/(g watch r)/i],[T,[x,"LG"],[k,t]],[/droid.+; (wt63?0{2,3})\)/i],[T,[x,gi],[k,t]],[/droid.+; (glass) \d/i],[T,[x,s],[k,F]],[/(pico) (4|neo3(?: link|pro)?)/i],[x,T,[k,F]],[/; (quest( \d| pro)?)/i],[T,[x,xi],[k,F]],[/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],[x,[k,D]],[/(aeobc)\b/i],[T,[x,si],[k,D]],[/(homepod).+mac os/i],[T,[x,a],[k,D]],[/windows iot/i],[[k,D]],[/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+?(mobile|vr|\d) safari/i],[T,[k,E,{mobile:"Mobile",xr:"VR","*":r}]],[/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],[[k,r]],[/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],[[k,S]],[/droid .+?; ([\w\. -]+)( bui|\))/i],[T,[x,"Generic"]]],engine:[[/windows.+ edge\/([\w\.]+)/i],[y,[v,"EdgeHTML"]],[/(arkweb)\/([\w\.]+)/i],[v,y],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],[y,[v,"Blink"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,/ekioh(flow)\/([\w\.]+)/i,/(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,/(icab)[\/ ]([23]\.[\d\.]+)/i,/\b(libweb)/i],[v,y],[/ladybird\//i],[[v,"LibWeb"]],[/rv\:([\w\.]{1,9})\b.+(gecko)/i],[y,v]],os:[[/microsoft (windows) (vista|xp)/i],[v,y],[/(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i],[v,[y,E,Ni]],[/windows nt 6\.2; (arm)/i,/windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i,/(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i],[[y,E,Ni],[v,Ci]],[/[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,/(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,/cfnetwork\/.+darwin/i],[[y,/_/g,"."],[v,"iOS"]],[/(mac os x) ?([\w\. ]*)/i,/(macintosh|mac_powerpc\b)(?!.+haiku)/i],[[v,"macOS"],[y,/_/g,"."]],[/android ([\d\.]+).*crkey/i],[y,[v,b+" Android"]],[/fuchsia.*crkey\/([\d\.]+)/i],[y,[v,b+" Fuchsia"]],[/crkey\/([\d\.]+).*devicetype\/smartspeaker/i],[y,[v,b+" SmartSpeaker"]],[/linux.*crkey\/([\d\.]+)/i],[y,[v,b+" Linux"]],[/crkey\/([\d\.]+)/i],[y,[v,b]],[/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],[y,v],[/(ubuntu) ([\w\.]+) like android/i],[[v,/(.+)/,"$1 Touch"],y],[/(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/; ]?([\d\.]*)/i],[v,y],[/\(bb(10);/i],[y,[v,wi]],[/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i],[y,[v,"Symbian"]],[/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],[y,[v,ki+" OS"]],[/web0s;.+rt(tv)/i,/\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],[y,[v,"webOS"]],[/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],[y,[v,"watchOS"]],[/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],[[v,"Chrome OS"],y],[/panasonic;(viera)/i,/(netrange)mmh/i,/(nettv)\/(\d+\.[\w\.]+)/i,/(nintendo|playstation) (\w+)/i,/(xbox); +xbox ([^\);]+)/i,/(pico) .+os([\w\.]+)/i,/\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,/(mint)[\/\(\) ]?(\w*)/i,/(mageia|vectorlinux)[; ]/i,/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,/(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i,/(gnu) ?([\w\.]*)/i,/\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,/(haiku) (\w+)/i],[v,y],[/(sunos) ?([\w\.\d]*)/i],[[v,"Solaris"],y],[/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,/(aix) ((\d)(?=\.|\)| )[\w\.])*/i,/\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,/(unix) ?([\w\.]*)/i],[v,y]]},Ii=(d={init:{},isIgnore:{},isIgnoreRgx:{},toString:{}},N.call(d.init,[[u,[v,y,B,k]],[h,[C]],[p,[k,T,x]],[m,[v,y]],[f,[v,y]]]),N.call(d.isIgnore,[[u,[y,B]],[m,[y]],[f,[y]]]),N.call(d.isIgnoreRgx,[[u,/ ?browser$/i],[f,/ ?os$/i]]),N.call(d.toString,[[u,[v,y]],[h,[C]],[p,[x,T]],[m,[v,y]],[f,[v,y]]]),d),Mi=function(e,i){var t=Ii.init[i],o=Ii.isIgnore[i]||0,r=Ii.isIgnoreRgx[i]||0,a=Ii.toString[i]||0;function s(){N.call(this,t)}return s.prototype.getItem=function(){return e},s.prototype.withClientHints=function(){return O?O.getHighEntropyValues(ai).then(function(i){return e.setCH(new Ui(i,!1)).parseCH().get()}):e.parseCH().get()},s.prototype.withFeatureCheck=function(){return e.detectFeature().get()},i!=g&&(s.prototype.is=function(i){var e,t=!1;for(e in this)if(this.hasOwnProperty(e)&&!Si(o,e)&&j(r?Ai(r,this[e]):this[e])==j(r?Ai(r,i):i)){if(t=!0,i!=n)break}else if(i==n&&t){t=!t;break}return t},s.prototype.toString=function(){var i,e=w;for(i in a)typeof this[a[i]]!==n&&(e+=(e?" ":w)+this[a[i]]);return e||n}),O||(s.prototype.then=function(i){function e(){for(var i in t)t.hasOwnProperty(i)&&(this[i]=t[i])}var t=this,o=(e.prototype={is:s.prototype.is,toString:s.prototype.toString},new e);return i(o),o}),new s};function Ui(i,e){if(i=i||{},N.call(this,ai),e)N.call(this,[[W,qi(i[o])],[X,qi(i[Z])],[S,/\?1/.test(i[ei])],[T,Oi(i[ti])],[q,Oi(i[oi])],[K,Oi(i[ri])],[C,Oi(i[Y])],[_,qi(i[ii])],[Q,Oi(i[J])]]);else for(var t in i)this.hasOwnProperty(t)&&typeof i[t]!==n&&(this[t]=i[t])}function Ri(i,e,t,o){return this.get=function(i){return i?this.data.hasOwnProperty(i)?this.data[i]:l:this.data},this.set=function(i,e){return this.data[i]=e,this},this.setCH=function(i){return this.uaCH=i,this},this.detectFeature=function(){if(A&&A.userAgent==this.ua)switch(this.itemType){case u:A.brave&&typeof A.brave.isBrave==V&&this.set(v,"Brave");break;case p:!this.get(k)&&O&&O[S]&&this.set(k,S),"Macintosh"==this.get(T)&&A&&typeof A.standalone!==n&&A.maxTouchPoints&&2<A.maxTouchPoints&&this.set(T,"iPad").set(k,r);break;case f:!this.get(v)&&O&&O[q]&&this.set(v,O[q]);break;case g:var e=this.data,i=function(i){return e[i].getItem().detectFeature().get()};this.set(u,i(u)).set(h,i(h)).set(p,i(p)).set(m,i(m)).set(f,i(f))}return this},this.parseUA=function(){return this.itemType!=g&&ji.call(this.data,this.ua,this.rgxMap),this.itemType==u&&this.set(B,zi(this.get(y))),this},this.parseCH=function(){var i,e=this.uaCH,t=this.rgxMap;switch(this.itemType){case u:case m:var o,r=e[X]||e[W];if(r)for(var a in r){var s=r[a].brand||r[a],a=r[a].version;this.itemType!=u||/not.a.brand/i.test(s)||o&&(!/chrom/i.test(o)||s==vi)||(s=E(s,{Chrome:"Google Chrome",Edge:"Microsoft Edge","Chrome WebView":"Android WebView","Chrome Headless":"HeadlessChrome"}),this.set(v,s).set(y,a).set(B,zi(a)),o=s),this.itemType==m&&s==vi&&this.set(y,a)}break;case h:var n=e[C];n&&("64"==e[Q]&&(n+="64"),ji.call(this.data,n+";",t));break;case p:if(e[S]&&this.set(k,S),e[T]&&(this.set(T,e[T]),this.get(k)&&this.get(x)||(ji.call(n={},"droid 9; "+e[T]+")",t),!this.get(k)&&n.type&&this.set(k,n.type),!this.get(x)&&n.vendor&&this.set(x,n.vendor))),e[_]){if("string"!=typeof e[_])for(var w=0;!i&&w<e[_].length;)i=E(e[_][w++],Ei);else i=E(e[_],Ei);this.set(k,i)}break;case f:var b,n=e[q];n&&(b=e[K],n==Ci&&(b=13<=parseInt(zi(b),10)?"11":"10"),this.set(v,n).set(y,b)),this.get(v)==Ci&&"Xbox"==e[T]&&this.set(v,"Xbox").set(y,l);break;case g:var d=this.data,n=function(i){return d[i].getItem().setCH(e).parseCH().get()};this.set(u,n(u)).set(h,n(h)).set(p,n(p)).set(m,n(m)).set(f,n(f))}return this},N.call(this,[["itemType",i],["ua",e],["uaCH",o],["rgxMap",t],["data",Mi(this,i)]]),this}function P(i,e,t){var o,r,a,s,n;return typeof i===c?(e=_i(i,!0)?(typeof e===c&&(t=e),i):(t=i,l),i=l):typeof i!==L||_i(e,!0)||(t=e,e=l),t&&typeof t.append===V&&(o={},t.forEach(function(i,e){o[e]=i}),t=o),this instanceof P?(r=typeof i===L?i:t&&t[U]?t[U]:A&&A.userAgent?A.userAgent:w,a=new Ui(t,!0),s=e?((i,e)=>{var t,o={},r=e;if(!_i(e))for(var a in r={},e)for(var s in e[a])r[s]=e[a][s].concat(r[s]||[]);for(t in i)o[t]=r[t]&&r[t].length%2==0?r[t].concat(i[t]):i[t];return o})(Pi,e):Pi,N.call(this,[["getBrowser",(n=function(i){return i==g?function(){return new Ri(i,r,s,a).set("ua",r).set(u,this.getBrowser()).set(h,this.getCPU()).set(p,this.getDevice()).set(m,this.getEngine()).set(f,this.getOS()).get()}:function(){return new Ri(i,r,s[i],a).parseUA().get()}})(u)],["getCPU",n(h)],["getDevice",n(p)],["getEngine",n(m)],["getOS",n(f)],["getResult",n(g)],["getUA",function(){return r}],["setUA",function(i){return H(i)&&(r=i.length>M?Hi(i,M):i),this}]]).setUA(r),this):new P(i,e,t).getResult()}P.VERSION="2.0.1",P.BROWSER=I([v,y,B,k]),P.CPU=I([C]),P.DEVICE=I([T,x,k,G,S,e,r,t,D]),P.ENGINE=P.OS=I([v,y]),typeof exports!==n?(exports=typeof module!==n&&module.exports?module.exports=P:exports).UAParser=P:typeof define===V&&define.amd?define(function(){return P}):Ti&&(i.UAParser=P);var Vi,Li=Ti&&(i.jQuery||i.Zepto);Li&&!Li.ua&&(Vi=new P,Li.ua=Vi.getResult(),Li.ua.get=function(){return Vi.getUA()},Li.ua.set=function(i){Vi.setUA(i);var e,t=Vi.getResult();for(e in t)Li.ua[e]=t[e]})})("object"==typeof window?window:this);
},{}],87:[function(require,module,exports){
//index.js
const io = require('socket.io-client')
const mediasoupClient = require('mediasoup-client')

const socket = io("/mediasoup")

socket.on('connection-success', ({ socketId }) => {
  console.log(socketId)
})

let device
let rtpCapabilities
let producerTransport
let consumerTransport
let producer
let consumer

// https://mediasoup.org/documentation/v3/mediasoup-client/api/#ProducerOptions
// https://mediasoup.org/documentation/v3/mediasoup-client/api/#transport-produce
let params = {
  // mediasoup params
  encodings: [
    {
      rid: 'r0',
      maxBitrate: 100000,
      scalabilityMode: 'S1T3',
    },
    {
      rid: 'r1',
      maxBitrate: 300000,
      scalabilityMode: 'S1T3',
    },
    {
      rid: 'r2',
      maxBitrate: 900000,
      scalabilityMode: 'S1T3',
    },
  ],
  // https://mediasoup.org/documentation/v3/mediasoup-client/api/#ProducerCodecOptions
  codecOptions: {
    videoGoogleStartBitrate: 1000
  }
}

const streamSuccess = async (stream) => {
  localVideo.srcObject = stream
  const track = stream.getVideoTracks()[0]
  params = {
    track,
    ...params
  }
}

const getLocalStream = () => {
  navigator.getUserMedia({
    audio: false,
    video: {
      width: {
        min: 640,
        max: 1920,
      },
      height: {
        min: 400,
        max: 1080,
      }
    }
  }, streamSuccess, error => {
    console.log(error.message)
  })
}

// A device is an endpoint connecting to a Router on the 
// server side to send/recive media
const createDevice = async () => {
  try {
    device = new mediasoupClient.Device()

    // https://mediasoup.org/documentation/v3/mediasoup-client/api/#device-load
    // Loads the device with RTP capabilities of the Router (server side)
    await device.load({
      // see getRtpCapabilities() below
      routerRtpCapabilities: rtpCapabilities
    })

    console.log('RTP Capabilities', device.rtpCapabilities)

  } catch (error) {
    console.log(error)
    if (error.name === 'UnsupportedError')
      console.warn('browser not supported')
  }
}

const getRtpCapabilities = () => {
  // make a request to the server for Router RTP Capabilities
  // see server's socket.on('getRtpCapabilities', ...)
  // the server sends back data object which contains rtpCapabilities
  socket.emit('getRtpCapabilities', (data) => {
    console.log(`Router RTP Capabilities... ${data.rtpCapabilities}`)

    // we assign to local variable and will be used when
    // loading the client Device (see createDevice above)
    rtpCapabilities = data.rtpCapabilities
  })
}

const createSendTransport = () => {
  // see server's socket.on('createWebRtcTransport', sender?, ...)
  // this is a call from Producer, so sender = true
  socket.emit('createWebRtcTransport', { sender: true }, ({ params }) => {
    // The server sends back params needed 
    // to create Send Transport on the client side
    if (params.error) {
      console.log(params.error)
      return
    }

    console.log(params)

    // creates a new WebRTC Transport to send media
    // based on the server's producer transport params
    // https://mediasoup.org/documentation/v3/mediasoup-client/api/#TransportOptions
    producerTransport = device.createSendTransport(params)

    // https://mediasoup.org/documentation/v3/communication-between-client-and-server/#producing-media
    // this event is raised when a first call to transport.produce() is made
    // see connectSendTransport() below
    producerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
      try {
        // Signal local DTLS parameters to the server side transport
        // see server's socket.on('transport-connect', ...)
        await socket.emit('transport-connect', {
          dtlsParameters,
        })

        // Tell the transport that parameters were transmitted.
        callback()

      } catch (error) {
        errback(error)
      }
    })

    producerTransport.on('produce', async (parameters, callback, errback) => {
      console.log(parameters)

      try {
        // tell the server to create a Producer
        // with the following parameters and produce
        // and expect back a server side producer id
        // see server's socket.on('transport-produce', ...)
        await socket.emit('transport-produce', {
          kind: parameters.kind,
          rtpParameters: parameters.rtpParameters,
          appData: parameters.appData,
        }, ({ id }) => {
          // Tell the transport that parameters were transmitted and provide it with the
          // server side producer's id.
          callback({ id })
        })
      } catch (error) {
        errback(error)
      }
    })
  })
}

const connectSendTransport = async () => {
  // we now call produce() to instruct the producer transport
  // to send media to the Router
  // https://mediasoup.org/documentation/v3/mediasoup-client/api/#transport-produce
  // this action will trigger the 'connect' and 'produce' events above
  producer = await producerTransport.produce(params)

  producer.on('trackended', () => {
    console.log('track ended')

    // close video track
  })

  producer.on('transportclose', () => {
    console.log('transport ended')

    // close video track
  })
}

const createRecvTransport = async () => {
  // see server's socket.on('consume', sender?, ...)
  // this is a call from Consumer, so sender = false
  await socket.emit('createWebRtcTransport', { sender: false }, ({ params }) => {
    // The server sends back params needed 
    // to create Send Transport on the client side
    if (params.error) {
      console.log(params.error)
      return
    }

    console.log(params)

    // creates a new WebRTC Transport to receive media
    // based on server's consumer transport params
    // https://mediasoup.org/documentation/v3/mediasoup-client/api/#device-createRecvTransport
    consumerTransport = device.createRecvTransport(params)

    // https://mediasoup.org/documentation/v3/communication-between-client-and-server/#producing-media
    // this event is raised when a first call to transport.produce() is made
    // see connectRecvTransport() below
    consumerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
      try {
        // Signal local DTLS parameters to the server side transport
        // see server's socket.on('transport-recv-connect', ...)
        await socket.emit('transport-recv-connect', {
          dtlsParameters,
        })

        // Tell the transport that parameters were transmitted.
        callback()
      } catch (error) {
        // Tell the transport that something was wrong
        errback(error)
      }
    })
  })
}

const connectRecvTransport = async () => {
  // for consumer, we need to tell the server first
  // to create a consumer based on the rtpCapabilities and consume
  // if the router can consume, it will send back a set of params as below
  await socket.emit('consume', {
    rtpCapabilities: device.rtpCapabilities,
  }, async ({ params }) => {
    if (params.error) {
      console.log('Cannot Consume')
      return
    }

    console.log(params)
    // then consume with the local consumer transport
    // which creates a consumer
    consumer = await consumerTransport.consume({
      id: params.id,
      producerId: params.producerId,
      kind: params.kind,
      rtpParameters: params.rtpParameters
    })

    // destructure and retrieve the video track from the producer
    const { track } = consumer

    remoteVideo.srcObject = new MediaStream([track])

    // the server consumer started with media paused
    // so we need to inform the server to resume
    socket.emit('consumer-resume')
  })
}

btnLocalVideo.addEventListener('click', getLocalStream)
btnRtpCapabilities.addEventListener('click', getRtpCapabilities)
btnDevice.addEventListener('click', createDevice)
btnCreateSendTransport.addEventListener('click', createSendTransport)
btnConnectSendTransport.addEventListener('click', connectSendTransport)
btnRecvSendTransport.addEventListener('click', createRecvTransport)
btnConnectRecvTransport.addEventListener('click', connectRecvTransport)
},{"mediasoup-client":61,"socket.io-client":74}]},{},[87])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL0Bzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXIvbGliL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hd2FpdHF1ZXVlL2xpYi9Mb2dnZXIuanMiLCJub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy9jb250cmliL2hhcy1jb3JzLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL2NvbnRyaWIvcGFyc2Vxcy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy9jb250cmliL3BhcnNldXJpLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy90cmFuc3BvcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL3RyYW5zcG9ydHMvcG9sbGluZy1mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvY29tbW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9jb250cmliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9kZWNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9lbmNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oMjY0LXByb2ZpbGUtbGV2ZWwtaWQvbGliL0xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy9oMjY0LXByb2ZpbGUtbGV2ZWwtaWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0NvbnN1bWVyLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RhdGFDb25zdW1lci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9EYXRhUHJvZHVjZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRGV2aWNlLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9Qcm9kdWNlci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9SdHBQYXJhbWV0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1NjdHBQYXJhbWV0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9lbmhhbmNlZEV2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lMTExLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTU1LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTY3LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTcwLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTc0LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0VkZ2UxMS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9GaXJlZm94MTIwLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0ZpcmVmb3g2MC5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9IYW5kbGVySW50ZXJmYWNlLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1JlYWN0TmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1JlYWN0TmF0aXZlVW5pZmllZFBsYW4uanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTEuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvb3J0Yy9lZGdlVXRpbHMuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvb3J0Yy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9zZHAvTWVkaWFTZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9SZW1vdGVTZHAuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL2NvbW1vblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9wbGFuQlV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC91bmlmaWVkUGxhblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL29ydGMuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvc2NhbGFiaWxpdHlNb2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ucG0tZXZlbnRzLXBhY2thZ2UvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXVlLW1pY3JvdGFzay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9ncmFtbWFyLmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9janMvY29udHJpYi9iYWNrbzIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9janMvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2Nqcy9vbi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2Nqcy9zb2NrZXQuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9janMvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYnVpbGQvY2pzL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2Nqcy9pcy1iaW5hcnkuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdWEtcGFyc2VyLWpzL2Rpc3QvdWEtcGFyc2VyLnBhY2suanMiLCJwdWJsaWMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5MkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cbiAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYWxpYXMgdXNlZCBmb3IgcmVzZXJ2ZWQgZXZlbnRzIChwcm90ZWN0ZWQgbWV0aG9kKVxuRW1pdHRlci5wcm90b3R5cGUuZW1pdFJlc2VydmVkID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IExJQl9OQU1FID0gJ2F3YWl0cXVldWUnO1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl93YXJuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7TElCX05BTUV9OldBUk46JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpFUlJPUjoke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoTElCX05BTUUpO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpXQVJOYCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpFUlJPUmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgdGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX3dhcm4ubG9nID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnO1xuICAgIH1cbiAgICBnZXQgd2FybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm47XG4gICAgfVxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF3YWl0UXVldWUgPSBleHBvcnRzLkF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yID0gZXhwb3J0cy5Bd2FpdFF1ZXVlU3RvcHBlZEVycm9yID0gdm9pZCAwO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCk7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBkZXJpdmVkIGNsYXNzIHVzZWQgdG8gcmVqZWN0IHBlbmRpbmcgdGFza3Mgb25jZSBzdG9wKCkgbWV0aG9kXG4gKiBoYXMgYmVlbiBjYWxsZWQuXG4gKi9cbmNsYXNzIEF3YWl0UXVldWVTdG9wcGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdBd2FpdFF1ZXVlIHN0b3BwZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F3YWl0UXVldWVTdG9wcGVkRXJyb3InO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEF3YWl0UXVldWVTdG9wcGVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bd2FpdFF1ZXVlU3RvcHBlZEVycm9yID0gQXdhaXRRdWV1ZVN0b3BwZWRFcnJvcjtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGRlcml2ZWQgY2xhc3MgdXNlZCB0byByZWplY3QgcGVuZGluZyB0YXNrcyBvbmNlIHJlbW92ZVRhc2soKVxuICogbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC5cbiAqL1xuY2xhc3MgQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdBd2FpdFF1ZXVlIHRhc2sgcmVtb3ZlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3InO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IgPSBBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvcjtcbmNsYXNzIEF3YWl0UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBRdWV1ZSBvZiBwZW5kaW5nIHRhc2tzIChtYXAgb2YgUGVuZGluZ1Rhc2tzIGluZGV4ZWQgYnkgaWQpLlxuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gSW5jcmVtZW50aW5nIFBlbmRpbmdUYXNrIGlkLlxuICAgICAgICB0aGlzLm5leHRUYXNrSWQgPSAwO1xuICAgICAgICAvLyBXaGV0aGVyIHN0b3AoKSBtZXRob2QgaXMgc3RvcHBpbmcgYWxsIHBlbmRpbmcgdGFza3MuXG4gICAgICAgIHRoaXMuc3RvcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdUYXNrcy5zaXplO1xuICAgIH1cbiAgICBhc3luYyBwdXNoKHRhc2ssIG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUgPz8gdGFzay5uYW1lO1xuICAgICAgICBsb2dnZXIuZGVidWcoYHB1c2goKSBbbmFtZToke25hbWV9XWApO1xuICAgICAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dpdmVuIHRhc2sgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFzaywgJ25hbWUnLCB7IHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZ1Rhc2sgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMubmV4dFRhc2tJZCsrLFxuICAgICAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVkQXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZ1Rhc2sucmVzb2x2ZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiBleGVjdXRlKCkgbWV0aG9kLiBTaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlKCkgd2FzIGNhbGxlZCBpdCBtZWFucyB0aGF0IHRoZSB0YXNrIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhlIHRhc2sgbWF5IGhhdmUgYmVlbiBzdG9wcGVkIGJlZm9yZSBpdCBjb21wbGV0ZWQgKHZpYVxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wKCkgb3IgcmVtb3ZlKCkpIHNvIGl0cyBjb21wbGV0ZWQgZmxhZyB3YXMgYWxyZWFkeSBzZXQuIElmIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlIGNhc2UsIGFib3J0IGhlcmUgc2luY2UgbmV4dCB0YXNrIChpZiBhbnkpIGlzIGFscmVhZHkgYmVpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVGFzay5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVGFzay5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRhc2sgZnJvbSB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZShwZW5kaW5nVGFzay5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgcmVzb2x2aW5nIHRhc2sgW25hbWU6JHtwZW5kaW5nVGFzay5uYW1lfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFzayB3aXRoIHRoZSBvYnRhaW5lZCByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgbmV4dCBwZW5kaW5nIHRhc2sgKGlmIGFueSkuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtuZXh0UGVuZGluZ1Rhc2tdID0gdGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IER1cmluZyB0aGUgcmVzb2x2ZSgpIGNhbGxiYWNrIHRoZSB1c2VyIGFwcCBtYXkgaGF2ZSBpbnRlcmFjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIHF1ZXVlLiBGb3IgaW5zdGFuY2UsIHRoZSBhcHAgbWF5IGhhdmUgcHVzaGVkIGEgdGFzayB3aGlsZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcXVldWUgd2FzIGVtcHR5IHNvIHN1Y2ggYSB0YXNrIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQuIElmIHNvLFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBleGVjdXRlIGl0IHR3aWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFBlbmRpbmdUYXNrICYmICFuZXh0UGVuZGluZ1Rhc2suZXhlY3V0ZWRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLmV4ZWN1dGUobmV4dFBlbmRpbmdUYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVqZWN0OiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZ1Rhc2sucmVqZWN0KCkgY2FuIGJlIGNhbGxlZCB3aXRoaW4gZXhlY3V0ZSgpIG1ldGhvZCBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFzayBjb21wbGV0ZWQgd2l0aCBlcnJvci4gSG93ZXZlciBpdCBtYXkgaGF2ZSBhbHNvIGJlZW4gY2FsbGVkIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AoKSBvciByZW1vdmUoKSBtZXRob2RzIChiZWZvcmUgb3Igd2hpbGUgYmVpbmcgZXhlY3V0ZWQpIHNvIGl0c1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWQgZmxhZyB3YXMgYWxyZWFkeSBzZXQuIElmIHNvLCBhYm9ydCBoZXJlIHNpbmNlIG5leHQgdGFza1xuICAgICAgICAgICAgICAgICAgICAvLyAoaWYgYW55KSBpcyBhbHJlYWR5IGJlaW5nIGV4ZWN1dGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1Rhc2suY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Rhc2suY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YXNrIGZyb20gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUocGVuZGluZ1Rhc2suaWQpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYHJlamVjdGluZyB0YXNrIFtuYW1lOiR7cGVuZGluZ1Rhc2submFtZX1dOiAlc2AsIFN0cmluZyhlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3QgdGhlIHRhc2sgd2l0aCB0aGUgb2J0YWluZWQgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIG5leHQgcGVuZGluZyB0YXNrIChpZiBhbnkpIHVubGVzcyBzdG9wKCkgaXMgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3BwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbbmV4dFBlbmRpbmdUYXNrXSA9IHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogRHVyaW5nIHRoZSByZWplY3QoKSBjYWxsYmFjayB0aGUgdXNlciBhcHAgbWF5IGhhdmUgaW50ZXJhY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgcXVldWUuIEZvciBpbnN0YW5jZSwgdGhlIGFwcCBtYXkgaGF2ZSBwdXNoZWQgYSB0YXNrIHdoaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcXVldWUgd2FzIGVtcHR5IHNvIHN1Y2ggYSB0YXNrIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQuIElmIHNvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhlY3V0ZSBpdCB0d2ljZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UGVuZGluZ1Rhc2sgJiYgIW5leHRQZW5kaW5nVGFzay5leGVjdXRlZEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLmV4ZWN1dGUobmV4dFBlbmRpbmdUYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBcHBlbmQgdGFzayB0byB0aGUgcXVldWUuXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5zZXQocGVuZGluZ1Rhc2suaWQsIHBlbmRpbmdUYXNrKTtcbiAgICAgICAgICAgIC8vIEFuZCBleGVjdXRlIGl0IGlmIHRoaXMgaXMgdGhlIG9ubHkgdGFzayBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nVGFza3Muc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5leGVjdXRlKHBlbmRpbmdUYXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcCgpJyk7XG4gICAgICAgIHRoaXMuc3RvcHBpbmcgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHBlbmRpbmdUYXNrIG9mIHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYHN0b3AoKSB8IHN0b3BwaW5nIHRhc2sgW25hbWU6JHtwZW5kaW5nVGFzay5uYW1lfV1gKTtcbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChuZXcgQXdhaXRRdWV1ZVN0b3BwZWRFcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BwaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJlbW92ZSh0YXNrSWR4KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgcmVtb3ZlKCkgW3Rhc2tJZHg6JHt0YXNrSWR4fV1gKTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1Rhc2sgPSBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKVt0YXNrSWR4XTtcbiAgICAgICAgaWYgKCFwZW5kaW5nVGFzaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBzdG9wKCkgfCBubyB0YXNrIHdpdGggZ2l2ZW4gaWR4IFt0YXNrSWR4OiR7dGFza0lkeH1dYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1Rhc2sucmVqZWN0KG5ldyBBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvcigpKTtcbiAgICB9XG4gICAgZHVtcCgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKS5tYXAoKHBlbmRpbmdUYXNrKSA9PiAoe1xuICAgICAgICAgICAgaWR4OiBpZHgrKyxcbiAgICAgICAgICAgIHRhc2s6IHBlbmRpbmdUYXNrLnRhc2ssXG4gICAgICAgICAgICBuYW1lOiBwZW5kaW5nVGFzay5uYW1lLFxuICAgICAgICAgICAgZW5xdWV1ZWRUaW1lOiBwZW5kaW5nVGFzay5leGVjdXRlZEF0XG4gICAgICAgICAgICAgICAgPyBwZW5kaW5nVGFzay5leGVjdXRlZEF0IC0gcGVuZGluZ1Rhc2suZW5xdWV1ZWRBdFxuICAgICAgICAgICAgICAgIDogbm93IC0gcGVuZGluZ1Rhc2suZW5xdWV1ZWRBdCxcbiAgICAgICAgICAgIGV4ZWN1dGlvblRpbWU6IHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXRcbiAgICAgICAgICAgICAgICA/IG5vdyAtIHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXRcbiAgICAgICAgICAgICAgICA6IDBcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlKHBlbmRpbmdUYXNrKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgZXhlY3V0ZSgpIFtuYW1lOiR7cGVuZGluZ1Rhc2submFtZX1dYCk7XG4gICAgICAgIGlmIChwZW5kaW5nVGFzay5leGVjdXRlZEF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgYWxyZWFkeSBiZWluZyBleGVjdXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGVuZGluZ1Rhc2sudGFzaygpO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFzayB3aXRoIGl0cyByZXNvbHZlZCByZXN1bHQgKGlmIGFueSkuXG4gICAgICAgICAgICBwZW5kaW5nVGFzay5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZWplY3QgdGhlIHRhc2sgd2l0aCBpdHMgcmVqZWN0ZWQgZXJyb3IuXG4gICAgICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bd2FpdFF1ZXVlID0gQXdhaXRRdWV1ZTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKVxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoJyAnLCAnLCcpXG5cdFx0XHQuc3BsaXQoJywnKVxuXHRcdFx0LmZpbHRlcihCb29sZWFuKTtcblxuXHRcdGZvciAoY29uc3QgbnMgb2Ygc3BsaXQpIHtcblx0XHRcdGlmIChuc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobnMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hdGNoZXMgYSBuYW1lc3BhY2UgdGVtcGxhdGUsIGhvbm9yaW5nXG5cdCAqIGFzdGVyaXNrcyBhcyB3aWxkY2FyZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaGVzVGVtcGxhdGUoc2VhcmNoLCB0ZW1wbGF0ZSkge1xuXHRcdGxldCBzZWFyY2hJbmRleCA9IDA7XG5cdFx0bGV0IHRlbXBsYXRlSW5kZXggPSAwO1xuXHRcdGxldCBzdGFySW5kZXggPSAtMTtcblx0XHRsZXQgbWF0Y2hJbmRleCA9IDA7XG5cblx0XHR3aGlsZSAoc2VhcmNoSW5kZXggPCBzZWFyY2gubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09IHNlYXJjaFtzZWFyY2hJbmRleF0gfHwgdGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykpIHtcblx0XHRcdFx0Ly8gTWF0Y2ggY2hhcmFjdGVyIG9yIHByb2NlZWQgd2l0aCB3aWxkY2FyZFxuXHRcdFx0XHRpZiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykge1xuXHRcdFx0XHRcdHN0YXJJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG5cdFx0XHRcdFx0bWF0Y2hJbmRleCA9IHNlYXJjaEluZGV4O1xuXHRcdFx0XHRcdHRlbXBsYXRlSW5kZXgrKzsgLy8gU2tpcCB0aGUgJyonXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VhcmNoSW5kZXgrKztcblx0XHRcdFx0XHR0ZW1wbGF0ZUluZGV4Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoc3RhckluZGV4ICE9PSAtMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG5cdFx0XHRcdC8vIEJhY2t0cmFjayB0byB0aGUgbGFzdCAnKicgYW5kIHRyeSB0byBtYXRjaCBtb3JlIGNoYXJhY3RlcnNcblx0XHRcdFx0dGVtcGxhdGVJbmRleCA9IHN0YXJJbmRleCArIDE7XG5cdFx0XHRcdG1hdGNoSW5kZXgrKztcblx0XHRcdFx0c2VhcmNoSW5kZXggPSBtYXRjaEluZGV4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBObyBtYXRjaFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSB0cmFpbGluZyAnKicgaW4gdGVtcGxhdGVcblx0XHR3aGlsZSAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiB0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gJyonKSB7XG5cdFx0XHR0ZW1wbGF0ZUluZGV4Kys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRlbXBsYXRlSW5kZXggPT09IHRlbXBsYXRlLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMsXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGZvciAoY29uc3Qgc2tpcCBvZiBjcmVhdGVEZWJ1Zy5za2lwcykge1xuXHRcdFx0aWYgKG1hdGNoZXNUZW1wbGF0ZShuYW1lLCBza2lwKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBucyBvZiBjcmVhdGVEZWJ1Zy5uYW1lcykge1xuXHRcdFx0aWYgKG1hdGNoZXNUZW1wbGF0ZShuYW1lLCBucykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNDT1JTID0gdm9pZCAwO1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L2hhcy1jb3JzXG5sZXQgdmFsdWUgPSBmYWxzZTtcbnRyeSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufVxuY2F0Y2ggKGVycikge1xuICAgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbn1cbmV4cG9ydHMuaGFzQ09SUyA9IHZhbHVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9xdWVyeXN0cmluZ1xuLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShvYmopIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcmJztcbiAgICAgICAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUocXMpIHtcbiAgICBsZXQgcXJ5ID0ge307XG4gICAgbGV0IHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsZXQgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcXJ5O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9wYXJzZXVyaVxuLyoqXG4gKiBQYXJzZXMgYSBVUklcbiAqXG4gKiBOb3RlOiB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCB0aGUgYnVpbHQtaW4gVVJMIG9iamVjdCwgYnV0IGl0IGlzbid0IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLlxuICpcbiAqIFNlZTpcbiAqIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFxuICogLSBodHRwczovL2Nhbml1c2UuY29tL3VybFxuICogLSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NiNhcHBlbmRpeC1CXG4gKlxuICogSGlzdG9yeSBvZiB0aGUgcGFyc2UoKSBtZXRob2Q6XG4gKiAtIGZpcnN0IGNvbW1pdDogaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQvY29tbWl0LzRlZTFkNWQ5NGIzOTA2YTljMDUyYjQ1OWYxYTgxOGIxNWYzOGY5MWNcbiAqIC0gZXhwb3J0IGludG8gaXRzIG93biBtb2R1bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tY2xpZW50L2NvbW1pdC9kZTJjNTYxZTQ1NjRlZmViNzhmMWJkYjFiYTM5ZWY4MWIyODIyY2IzXG4gKiAtIHJlaW1wb3J0OiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLWNsaWVudC9jb21taXQvZGYzMjI3N2MzZjZkNjIyZWVjNWVkMDlmNDkzY2FlM2YzMzkxZDI0MlxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5jb25zdCByZSA9IC9eKD86KD8hW146QFxcLz8jXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QFxcLz8jXSopKD86OihbXjpAXFwvPyNdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuY29uc3QgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiA4MDAwKSB7XG4gICAgICAgIHRocm93IFwiVVJJIHRvbyBsb25nXCI7XG4gICAgfVxuICAgIGNvbnN0IHNyYyA9IHN0ciwgYiA9IHN0ci5pbmRleE9mKCdbJyksIGUgPSBzdHIuaW5kZXhPZignXScpO1xuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IG0gPSByZS5leGVjKHN0ciB8fCAnJyksIHVyaSA9IHt9LCBpID0gMTQ7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG4gICAgdXJpLnBhdGhOYW1lcyA9IHBhdGhOYW1lcyh1cmksIHVyaVsncGF0aCddKTtcbiAgICB1cmkucXVlcnlLZXkgPSBxdWVyeUtleSh1cmksIHVyaVsncXVlcnknXSk7XG4gICAgcmV0dXJuIHVyaTtcbn1cbmZ1bmN0aW9uIHBhdGhOYW1lcyhvYmosIHBhdGgpIHtcbiAgICBjb25zdCByZWd4ID0gL1xcL3syLDl9L2csIG5hbWVzID0gcGF0aC5yZXBsYWNlKHJlZ3gsIFwiL1wiKS5zcGxpdChcIi9cIik7XG4gICAgaWYgKHBhdGguc2xpY2UoMCwgMSkgPT0gJy8nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc2xpY2UoLTEpID09ICcvJykge1xuICAgICAgICBuYW1lcy5zcGxpY2UobmFtZXMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHVyaSwgcXVlcnkpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgcXVlcnkucmVwbGFjZSgvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgZGF0YVskMV0gPSAkMjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRCaW5hcnlUeXBlID0gZXhwb3J0cy5nbG9iYWxUaGlzU2hpbSA9IGV4cG9ydHMubmV4dFRpY2sgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZUNvb2tpZUphciA9IGNyZWF0ZUNvb2tpZUphcjtcbmV4cG9ydHMubmV4dFRpY2sgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGlzUHJvbWlzZUF2YWlsYWJsZSA9IHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFByb21pc2UucmVzb2x2ZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGlmIChpc1Byb21pc2VBdmFpbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIChjYikgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihjYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKGNiLCBzZXRUaW1lb3V0Rm4pID0+IHNldFRpbWVvdXRGbihjYiwgMCk7XG4gICAgfVxufSkoKTtcbmV4cG9ydHMuZ2xvYmFsVGhpc1NoaW0gPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICB9XG59KSgpO1xuZXhwb3J0cy5kZWZhdWx0QmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUNvb2tpZUphcigpIHsgfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlRyYW5zcG9ydCA9IGV4cG9ydHMuV2ViU29ja2V0ID0gZXhwb3J0cy5Ob2RlV2ViU29ja2V0ID0gZXhwb3J0cy5YSFIgPSBleHBvcnRzLk5vZGVYSFIgPSBleHBvcnRzLkZldGNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMucGFyc2UgPSBleHBvcnRzLmluc3RhbGxUaW1lckZ1bmN0aW9ucyA9IGV4cG9ydHMudHJhbnNwb3J0cyA9IGV4cG9ydHMuVHJhbnNwb3J0RXJyb3IgPSBleHBvcnRzLlRyYW5zcG9ydCA9IGV4cG9ydHMucHJvdG9jb2wgPSBleHBvcnRzLlNvY2tldFdpdGhVcGdyYWRlID0gZXhwb3J0cy5Tb2NrZXRXaXRob3V0VXBncmFkZSA9IGV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvY2tldF9qc18xLlNvY2tldDsgfSB9KTtcbnZhciBzb2NrZXRfanNfMiA9IHJlcXVpcmUoXCIuL3NvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFdpdGhvdXRVcGdyYWRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfanNfMi5Tb2NrZXRXaXRob3V0VXBncmFkZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFdpdGhVcGdyYWRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfanNfMi5Tb2NrZXRXaXRoVXBncmFkZTsgfSB9KTtcbmV4cG9ydHMucHJvdG9jb2wgPSBzb2NrZXRfanNfMS5Tb2NrZXQucHJvdG9jb2w7XG52YXIgdHJhbnNwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc3BvcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zcG9ydF9qc18xLlRyYW5zcG9ydDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zcG9ydEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRfanNfMS5UcmFuc3BvcnRFcnJvcjsgfSB9KTtcbnZhciBpbmRleF9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYW5zcG9ydHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEudHJhbnNwb3J0czsgfSB9KTtcbnZhciB1dGlsX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5zdGFsbFRpbWVyRnVuY3Rpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsX2pzXzEuaW5zdGFsbFRpbWVyRnVuY3Rpb25zOyB9IH0pO1xudmFyIHBhcnNldXJpX2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmliL3BhcnNldXJpLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNldXJpX2pzXzEucGFyc2U7IH0gfSk7XG52YXIgZ2xvYmFsc19ub2RlX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzLm5vZGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuZXh0VGlja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFsc19ub2RlX2pzXzEubmV4dFRpY2s7IH0gfSk7XG52YXIgcG9sbGluZ19mZXRjaF9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy9wb2xsaW5nLWZldGNoLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvbGxpbmdfZmV0Y2hfanNfMS5GZXRjaDsgfSB9KTtcbnZhciBwb2xsaW5nX3hocl9ub2RlX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLm5vZGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb2RlWEhSXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwb2xsaW5nX3hocl9ub2RlX2pzXzEuWEhSOyB9IH0pO1xudmFyIHBvbGxpbmdfeGhyX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWEhSXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwb2xsaW5nX3hocl9qc18xLlhIUjsgfSB9KTtcbnZhciB3ZWJzb2NrZXRfbm9kZV9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy93ZWJzb2NrZXQubm9kZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vZGVXZWJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYnNvY2tldF9ub2RlX2pzXzEuV1M7IH0gfSk7XG52YXIgd2Vic29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzL3dlYnNvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlYlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2Vic29ja2V0X2pzXzEuV1M7IH0gfSk7XG52YXIgd2VidHJhbnNwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlYlRyYW5zcG9ydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2VidHJhbnNwb3J0X2pzXzEuV1Q7IH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy5Tb2NrZXRXaXRoVXBncmFkZSA9IGV4cG9ydHMuU29ja2V0V2l0aG91dFVwZ3JhZGUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy9pbmRleC5qc1wiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5jb25zdCBwYXJzZXFzX2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmliL3BhcnNlcXMuanNcIik7XG5jb25zdCBwYXJzZXVyaV9qc18xID0gcmVxdWlyZShcIi4vY29udHJpYi9wYXJzZXVyaS5qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IGVuZ2luZV9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuY29uc3QgZ2xvYmFsc19ub2RlX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzLm5vZGUuanNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7IC8vIGRlYnVnKClcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmUuaW8tY2xpZW50OnNvY2tldFwiKTsgLy8gZGVidWcoKVxuY29uc3Qgd2l0aEV2ZW50TGlzdGVuZXJzID0gdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiByZW1vdmVFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUyA9IFtdO1xuaWYgKHdpdGhFdmVudExpc3RlbmVycykge1xuICAgIC8vIHdpdGhpbiBhIFNlcnZpY2VXb3JrZXIsIGFueSBldmVudCBoYW5kbGVyIGZvciB0aGUgJ29mZmxpbmUnIGV2ZW50IG11c3QgYmUgYWRkZWQgb24gdGhlIGluaXRpYWwgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAvLyBzY3JpcHQsIHNvIHdlIGNyZWF0ZSBvbmUgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIGhlcmUgd2hpY2ggd2lsbCBmb3J3YXJkIHRoZSBldmVudCB0byB0aGUgc29ja2V0IGluc3RhbmNlc1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsICgpID0+IHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nICVkIGNvbm5lY3Rpb24ocykgYmVjYXVzZSB0aGUgbmV0d29yayB3YXMgbG9zdFwiLCBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5sZW5ndGgpO1xuICAgICAgICBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSk7XG4gICAgfSwgZmFsc2UpO1xufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgV2ViU29ja2V0LWxpa2UgaW50ZXJmYWNlIHRvIGNvbm5lY3QgdG8gYW4gRW5naW5lLklPIHNlcnZlci4gVGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZFxuICogd2l0aCBvbmUgb2YgdGhlIGF2YWlsYWJsZSBsb3ctbGV2ZWwgdHJhbnNwb3J0cywgbGlrZSBIVFRQIGxvbmctcG9sbGluZywgV2ViU29ja2V0IG9yIFdlYlRyYW5zcG9ydC5cbiAqXG4gKiBUaGlzIGNsYXNzIGNvbWVzIHdpdGhvdXQgdXBncmFkZSBtZWNoYW5pc20sIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBrZWVwIHRoZSBmaXJzdCBsb3ctbGV2ZWwgdHJhbnNwb3J0IHRoYXRcbiAqIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBJbiBvcmRlciB0byBhbGxvdyB0cmVlLXNoYWtpbmcsIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIGluY2x1ZGVkLCB0aGF0J3Mgd2h5IHRoZSBgdHJhbnNwb3J0c2Agb3B0aW9uIGlzIG1hbmRhdG9yeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0V2l0aG91dFVwZ3JhZGUsIFdlYlNvY2tldCB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG4gKlxuICogY29uc3Qgc29ja2V0ID0gbmV3IFNvY2tldFdpdGhvdXRVcGdyYWRlKHtcbiAqICAgdHJhbnNwb3J0czogW1dlYlNvY2tldF1cbiAqIH0pO1xuICpcbiAqIHNvY2tldC5vbihcIm9wZW5cIiwgKCkgPT4ge1xuICogICBzb2NrZXQuc2VuZChcImhlbGxvXCIpO1xuICogfSk7XG4gKlxuICogQHNlZSBTb2NrZXRXaXRoVXBncmFkZVxuICogQHNlZSBTb2NrZXRcbiAqL1xuY2xhc3MgU29ja2V0V2l0aG91dFVwZ3JhZGUgZXh0ZW5kcyBjb21wb25lbnRfZW1pdHRlcl8xLkVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIC0gdXJpIG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmksIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iaW5hcnlUeXBlID0gZ2xvYmFsc19ub2RlX2pzXzEuZGVmYXVsdEJpbmFyeVR5cGU7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgICAgIHRoaXMuX3BpbmdJbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLl9tYXhQYXlsb2FkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwaXJhdGlvbiB0aW1lc3RhbXAgb2YgdGhlIHtAbGluayBfcGluZ1RpbWVvdXRUaW1lcn0gb2JqZWN0IGlzIHRyYWNrZWQsIGluIGNhc2UgdGhlIHRpbWVyIGlzIHRocm90dGxlZCBhbmQgdGhlXG4gICAgICAgICAqIGNhbGxiYWNrIGlzIG5vdCBmaXJlZCBvbiB0aW1lLiBUaGlzIGNhbiBoYXBwZW4gZm9yIGV4YW1wbGUgd2hlbiBhIGxhcHRvcCBpcyBzdXNwZW5kZWQgb3Igd2hlbiBhIHBob25lIGlzIGxvY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZSA9IEluZmluaXR5O1xuICAgICAgICBpZiAodXJpICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1cmkpIHtcbiAgICAgICAgICAgIG9wdHMgPSB1cmk7XG4gICAgICAgICAgICB1cmkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVyaSA9ICgwLCBwYXJzZXVyaV9qc18xLnBhcnNlKSh1cmkpO1xuICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNlZFVyaS5ob3N0O1xuICAgICAgICAgICAgb3B0cy5zZWN1cmUgPVxuICAgICAgICAgICAgICAgIHBhcnNlZFVyaS5wcm90b2NvbCA9PT0gXCJodHRwc1wiIHx8IHBhcnNlZFVyaS5wcm90b2NvbCA9PT0gXCJ3c3NcIjtcbiAgICAgICAgICAgIG9wdHMucG9ydCA9IHBhcnNlZFVyaS5wb3J0O1xuICAgICAgICAgICAgaWYgKHBhcnNlZFVyaS5xdWVyeSlcbiAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkVXJpLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSA9ICgwLCBwYXJzZXVyaV9qc18xLnBhcnNlKShvcHRzLmhvc3QpLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV0aWxfanNfMS5pbnN0YWxsVGltZXJGdW5jdGlvbnMpKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnNlY3VyZSA9XG4gICAgICAgICAgICBudWxsICE9IG9wdHMuc2VjdXJlXG4gICAgICAgICAgICAgICAgPyBvcHRzLnNlY3VyZVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgICAgICAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogXCJsb2NhbGhvc3RcIik7XG4gICAgICAgIHRoaXMucG9ydCA9XG4gICAgICAgICAgICBvcHRzLnBvcnQgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCI0NDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjgwXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZSA9IHt9O1xuICAgICAgICBvcHRzLnRyYW5zcG9ydHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHQucHJvdG90eXBlLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydHNCeU5hbWVbdHJhbnNwb3J0TmFtZV0gPSB0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBwYXRoOiBcIi9lbmdpbmUuaW9cIixcbiAgICAgICAgICAgIGFnZW50OiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICB1cGdyYWRlOiB0cnVlLFxuICAgICAgICAgICAgdGltZXN0YW1wUGFyYW06IFwidFwiLFxuICAgICAgICAgICAgcmVtZW1iZXJVcGdyYWRlOiBmYWxzZSxcbiAgICAgICAgICAgIGFkZFRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgICAgICAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRydWUsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZToge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNsb3NlT25CZWZvcmV1bmxvYWQ6IGZhbHNlLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgdGhpcy5vcHRzLnBhdGggPVxuICAgICAgICAgICAgdGhpcy5vcHRzLnBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpICtcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRzLmFkZFRyYWlsaW5nU2xhc2ggPyBcIi9cIiA6IFwiXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRzLnF1ZXJ5ID0gKDAsIHBhcnNlcXNfanNfMS5kZWNvZGUpKHRoaXMub3B0cy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpdGhFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbG9zZU9uQmVmb3JldW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gd2hlbiB0aGUgXCJiZWZvcmV1bmxvYWRcIiBldmVudCBpcyBlbWl0dGVkIGJ1dCBub3QgQ2hyb21lLiBUaGlzIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlcyBldmVyeSBicm93c2VyIGJlaGF2ZXMgdGhlIHNhbWUgKG5vIFwiZGlzY29ubmVjdFwiIGV2ZW50IGF0IHRoZSBTb2NrZXQuSU8gbGV2ZWwgd2hlbiB0aGUgcGFnZSBpc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlZC9yZWxvYWRlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbGVudGx5IGNsb3NlIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiYWRkaW5nIGxpc3RlbmVyIGZvciB0aGUgJ29mZmxpbmUnIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIm5ldHdvcmsgY29ubmVjdGlvbiBsb3N0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT0ZGTElORV9FVkVOVF9MSVNURU5FUlMucHVzaCh0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvb2tpZUphciA9ICgwLCBnbG9iYWxzX25vZGVfanNfMS5jcmVhdGVDb29raWVKYXIpKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdHJhbnNwb3J0IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjcmVhdGVUcmFuc3BvcnQobmFtZSkge1xuICAgICAgICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICAgICAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cy5xdWVyeSk7XG4gICAgICAgIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICAgICAgICBxdWVyeS5FSU8gPSBlbmdpbmVfaW9fcGFyc2VyXzEucHJvdG9jb2w7XG4gICAgICAgIC8vIHRyYW5zcG9ydCBuYW1lXG4gICAgICAgIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG4gICAgICAgIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgc29ja2V0OiB0aGlzLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgICAgICAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgICAgICAgICAgcG9ydDogdGhpcy5wb3J0LFxuICAgICAgICB9LCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIGRlYnVnKFwib3B0aW9uczogJWpcIiwgb3B0cyk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZVtuYW1lXShvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSB0aGlzLm9wdHMucmVtZW1iZXJVcGdyYWRlICYmXG4gICAgICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpICE9PSAtMVxuICAgICAgICAgICAgPyBcIndlYnNvY2tldFwiXG4gICAgICAgICAgICA6IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB0cmFuc3BvcnQub3BlbigpO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgdHJhbnNwb3J0ICVzXCIsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlc1wiLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gICAgICAgIHRyYW5zcG9ydFxuICAgICAgICAgICAgLm9uKFwiZHJhaW5cIiwgdGhpcy5fb25EcmFpbi5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLm9uKFwicGFja2V0XCIsIHRoaXMuX29uUGFja2V0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJjbG9zZVwiLCAocmVhc29uKSA9PiB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIsIHJlYXNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IG9wZW5cIik7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPVxuICAgICAgICAgICAgXCJ3ZWJzb2NrZXRcIiA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgICAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb25nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJzZXJ2ZXIgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm1lc3NhZ2VcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBoYW5kc2hha2Ugb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkhhbmRzaGFrZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiaGFuZHNoYWtlXCIsIGRhdGEpO1xuICAgICAgICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICAgICAgICB0aGlzLl9waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICAgICAgICB0aGlzLl9tYXhQYXlsb2FkID0gZGF0YS5tYXhQYXlsb2FkO1xuICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3Jlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbmQgcmVzZXRzIHBpbmcgdGltZW91dCB0aW1lciBiYXNlZCBvbiBzZXJ2ZXIgcGluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFBpbmdUaW1lb3V0KCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRoaXMuX3BpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuX3BpbmdJbnRlcnZhbCArIHRoaXMuX3BpbmdUaW1lb3V0O1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWVyLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRHJhaW4oKSB7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMuX3ByZXZCdWZmZXJMZW4pO1xuICAgICAgICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAgICAgICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMudXBncmFkaW5nICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0cyA9IHRoaXMuX2dldFdyaXRhYmxlUGFja2V0cygpO1xuICAgICAgICAgICAgZGVidWcoXCJmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldFwiLCBwYWNrZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBhY2tldHMpO1xuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgICAgICAgICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gcGFja2V0cy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImZsdXNoXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGUgZW5jb2RlZCBzaXplIG9mIHRoZSB3cml0ZUJ1ZmZlciBpcyBiZWxvdyB0aGUgbWF4UGF5bG9hZCB2YWx1ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgKG9ubHkgZm9yIEhUVFBcbiAgICAgKiBsb25nLXBvbGxpbmcpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRXcml0YWJsZVBhY2tldHMoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrUGF5bG9hZFNpemUgPSB0aGlzLl9tYXhQYXlsb2FkICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5uYW1lID09PSBcInBvbGxpbmdcIiAmJlxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggPiAxO1xuICAgICAgICBpZiAoIXNob3VsZENoZWNrUGF5bG9hZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXlsb2FkU2l6ZSA9IDE7IC8vIGZpcnN0IHBhY2tldCB0eXBlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMud3JpdGVCdWZmZXJbaV0uZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gKDAsIHV0aWxfanNfMS5ieXRlTGVuZ3RoKShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gMCAmJiBwYXlsb2FkU2l6ZSA+IHRoaXMuX21heFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIm9ubHkgc2VuZCAlZCBvdXQgb2YgJWQgcGFja2V0c1wiLCBpLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXIuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSAyOyAvLyBzZXBhcmF0b3IgKyBwYWNrZXQgdHlwZVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwicGF5bG9hZCBzaXplIGlzICVkIChtYXg6ICVkKVwiLCBwYXlsb2FkU2l6ZSwgdGhpcy5fbWF4UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaGVhcnRiZWF0IHRpbWVyIGhhcyBleHBpcmVkIGJ1dCB0aGUgc29ja2V0IGhhcyBub3QgeWV0IGJlZW4gbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwcml2YXRlIGZvciBub3cgYmVjYXVzZSBpdCBkb2VzIG5vdCByZWFsbHkgZml0IHRoZSBXZWJTb2NrZXQgQVBJLCBidXQgaWYgd2UgcHV0IGl0IGluIHRoZVxuICAgICAqIGB3cml0ZSgpYCBtZXRob2QgdGhlbiB0aGUgbWVzc2FnZSB3b3VsZCBub3QgYmUgYnVmZmVyZWQgYnkgdGhlIFNvY2tldC5JTyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLyogcHJpdmF0ZSAqLyBfaGFzUGluZ0V4cGlyZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGluZ1RpbWVvdXRUaW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBEYXRlLm5vdygpID4gdGhpcy5fcGluZ1RpbWVvdXRUaW1lO1xuICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0aHJvdHRsZWQgdGltZXIgZGV0ZWN0ZWQsIHNjaGVkdWxpbmcgY29ubmVjdGlvbiBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZSA9IDA7XG4gICAgICAgICAgICAoMCwgZ2xvYmFsc19ub2RlX2pzXzEubmV4dFRpY2spKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICAgICAgfSwgdGhpcy5zZXRUaW1lb3V0Rm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNFeHBpcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHdyaXRlKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgbXNnLCBvcHRpb25zLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuIEFsaWFzIG9mIHtAbGluayBTb2NrZXQjd3JpdGV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBzZW5kKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgbXNnLCBvcHRpb25zLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlOiBwYWNrZXQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbmRQYWNrZXQodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZuID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8IFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRDcmVhdGVcIiwgcGFja2V0KTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIHRoaXMub25jZShcImZsdXNoXCIsIGZuKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgICAgIGRlYnVnKFwic29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBBbmRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkZVwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRGb3JVcGdyYWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVFcnJvclwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkVycm9yKGVycikge1xuICAgICAgICBkZWJ1ZyhcInNvY2tldCBlcnJvciAlalwiLCBlcnIpO1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy50cnlBbGxUcmFuc3BvcnRzICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5pbmdcIikge1xuICAgICAgICAgICAgZGVidWcoXCJ0cnlpbmcgbmV4dCB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGVycm9yXCIsIGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQ2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgICAgICAgXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgICAgICAgXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLl9waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICh3aXRoRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMuX2JlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5pbmRleE9mKHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlbW92aW5nIGxpc3RlbmVyIGZvciB0aGUgJ29mZmxpbmUnIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgT0ZGTElORV9FVkVOVF9MSVNURU5FUlMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgICAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRXaXRob3V0VXBncmFkZSA9IFNvY2tldFdpdGhvdXRVcGdyYWRlO1xuU29ja2V0V2l0aG91dFVwZ3JhZGUucHJvdG9jb2wgPSBlbmdpbmVfaW9fcGFyc2VyXzEucHJvdG9jb2w7XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBXZWJTb2NrZXQtbGlrZSBpbnRlcmZhY2UgdG8gY29ubmVjdCB0byBhbiBFbmdpbmUuSU8gc2VydmVyLiBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkXG4gKiB3aXRoIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGxvdy1sZXZlbCB0cmFuc3BvcnRzLCBsaWtlIEhUVFAgbG9uZy1wb2xsaW5nLCBXZWJTb2NrZXQgb3IgV2ViVHJhbnNwb3J0LlxuICpcbiAqIFRoaXMgY2xhc3MgY29tZXMgd2l0aCBhbiB1cGdyYWRlIG1lY2hhbmlzbSwgd2hpY2ggbWVhbnMgdGhhdCBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdpdGggdGhlIGZpcnN0XG4gKiBsb3ctbGV2ZWwgdHJhbnNwb3J0LCBpdCB3aWxsIHRyeSB0byB1cGdyYWRlIHRvIGEgYmV0dGVyIHRyYW5zcG9ydC5cbiAqXG4gKiBJbiBvcmRlciB0byBhbGxvdyB0cmVlLXNoYWtpbmcsIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIGluY2x1ZGVkLCB0aGF0J3Mgd2h5IHRoZSBgdHJhbnNwb3J0c2Agb3B0aW9uIGlzIG1hbmRhdG9yeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0V2l0aFVwZ3JhZGUsIFdlYlNvY2tldCB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG4gKlxuICogY29uc3Qgc29ja2V0ID0gbmV3IFNvY2tldFdpdGhVcGdyYWRlKHtcbiAqICAgdHJhbnNwb3J0czogW1dlYlNvY2tldF1cbiAqIH0pO1xuICpcbiAqIHNvY2tldC5vbihcIm9wZW5cIiwgKCkgPT4ge1xuICogICBzb2NrZXQuc2VuZChcImhlbGxvXCIpO1xuICogfSk7XG4gKlxuICogQHNlZSBTb2NrZXRXaXRob3V0VXBncmFkZVxuICogQHNlZSBTb2NrZXRcbiAqL1xuY2xhc3MgU29ja2V0V2l0aFVwZ3JhZGUgZXh0ZW5kcyBTb2NrZXRXaXRob3V0VXBncmFkZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3VwZ3JhZGVzID0gW107XG4gICAgfVxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgc3VwZXIub25PcGVuKCk7XG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMub3B0cy51cGdyYWRlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInN0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91cGdyYWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2JlKHRoaXMuX3VwZ3JhZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRyYW5zcG9ydCBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvYmUobmFtZSkge1xuICAgICAgICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gICAgICAgIGxldCB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lKTtcbiAgICAgICAgbGV0IGZhaWxlZCA9IGZhbHNlO1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb25UcmFuc3BvcnRPcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwicGluZ1wiLCBkYXRhOiBcInByb2JlXCIgfV0pO1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJwYWNrZXRcIiwgKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoXCJwb25nXCIgPT09IG1zZy50eXBlICYmIFwicHJvYmVcIiA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkaW5nXCIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNwb3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3ZWJzb2NrZXRcIiA9PT0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5wYXVzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogXCJ1cGdyYWRlXCIgfV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRlXCIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwicHJvYmUgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVFcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gICAgICAgIGNvbnN0IG9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcInByb2JlIGVycm9yOiBcIiArIGVycik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZUVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICAgICAgICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgICAgICAgICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgICAgICAgZnVuY3Rpb24gb251cGdyYWRlKHRvKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJvcGVuXCIsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgICAgdGhpcy5vbmNlKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICAgIGlmICh0aGlzLl91cGdyYWRlcy5pbmRleE9mKFwid2VidHJhbnNwb3J0XCIpICE9PSAtMSAmJlxuICAgICAgICAgICAgbmFtZSAhPT0gXCJ3ZWJ0cmFuc3BvcnRcIikge1xuICAgICAgICAgICAgLy8gZmF2b3IgV2ViVHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkhhbmRzaGFrZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3VwZ3JhZGVzID0gdGhpcy5fZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gICAgICAgIHN1cGVyLm9uSGFuZHNoYWtlKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHVwZ3JhZGVzIC0gc2VydmVyIHVwZ3JhZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlsdGVyVXBncmFkZXModXBncmFkZXMpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwZ3JhZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAofnRoaXMudHJhbnNwb3J0cy5pbmRleE9mKHVwZ3JhZGVzW2ldKSlcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0V2l0aFVwZ3JhZGUgPSBTb2NrZXRXaXRoVXBncmFkZTtcbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhIFdlYlNvY2tldC1saWtlIGludGVyZmFjZSB0byBjb25uZWN0IHRvIGFuIEVuZ2luZS5JTyBzZXJ2ZXIuIFRoZSBjb25uZWN0aW9uIHdpbGwgYmUgZXN0YWJsaXNoZWRcbiAqIHdpdGggb25lIG9mIHRoZSBhdmFpbGFibGUgbG93LWxldmVsIHRyYW5zcG9ydHMsIGxpa2UgSFRUUCBsb25nLXBvbGxpbmcsIFdlYlNvY2tldCBvciBXZWJUcmFuc3BvcnQuXG4gKlxuICogVGhpcyBjbGFzcyBjb21lcyB3aXRoIGFuIHVwZ3JhZGUgbWVjaGFuaXNtLCB3aGljaCBtZWFucyB0aGF0IG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgd2l0aCB0aGUgZmlyc3RcbiAqIGxvdy1sZXZlbCB0cmFuc3BvcnQsIGl0IHdpbGwgdHJ5IHRvIHVwZ3JhZGUgdG8gYSBiZXR0ZXIgdHJhbnNwb3J0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiZW5naW5lLmlvLWNsaWVudFwiO1xuICpcbiAqIGNvbnN0IHNvY2tldCA9IG5ldyBTb2NrZXQoKTtcbiAqXG4gKiBzb2NrZXQub24oXCJvcGVuXCIsICgpID0+IHtcbiAqICAgc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAqIH0pO1xuICpcbiAqIEBzZWUgU29ja2V0V2l0aG91dFVwZ3JhZGVcbiAqIEBzZWUgU29ja2V0V2l0aFVwZ3JhZGVcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgU29ja2V0V2l0aFVwZ3JhZGUge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG8gPSB0eXBlb2YgdXJpID09PSBcIm9iamVjdFwiID8gdXJpIDogb3B0cztcbiAgICAgICAgaWYgKCFvLnRyYW5zcG9ydHMgfHxcbiAgICAgICAgICAgIChvLnRyYW5zcG9ydHMgJiYgdHlwZW9mIG8udHJhbnNwb3J0c1swXSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIG8udHJhbnNwb3J0cyA9IChvLnRyYW5zcG9ydHMgfHwgW1wicG9sbGluZ1wiLCBcIndlYnNvY2tldFwiLCBcIndlYnRyYW5zcG9ydFwiXSlcbiAgICAgICAgICAgICAgICAubWFwKCh0cmFuc3BvcnROYW1lKSA9PiBpbmRleF9qc18xLnRyYW5zcG9ydHNbdHJhbnNwb3J0TmFtZV0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gISF0KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih1cmksIG8pO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zcG9ydCA9IGV4cG9ydHMuVHJhbnNwb3J0RXJyb3IgPSB2b2lkIDA7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5jb25zdCBwYXJzZXFzX2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmliL3BhcnNlcXMuanNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7IC8vIGRlYnVnKClcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmUuaW8tY2xpZW50OnRyYW5zcG9ydFwiKTsgLy8gZGVidWcoKVxuY2xhc3MgVHJhbnNwb3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVhc29uLCBkZXNjcmlwdGlvbiwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihyZWFzb24pO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiVHJhbnNwb3J0RXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zcG9ydEVycm9yID0gVHJhbnNwb3J0RXJyb3I7XG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBjb21wb25lbnRfZW1pdHRlcl8xLkVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgKDAsIHV0aWxfanNfMS5pbnN0YWxsVGltZXJGdW5jdGlvbnMpKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9ICFvcHRzLmZvcmNlQmFzZTY0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIHRoZSBlcnJvciBjb250ZXh0XG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25FcnJvcihyZWFzb24sIGRlc2NyaXB0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIG5ldyBUcmFuc3BvcnRFcnJvcihyZWFzb24sIGRlc2NyaXB0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICB0aGlzLmRvT3BlbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlbmluZ1wiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBoYXBwZW4gaWYgdGhlIHRyYW5zcG9ydCB3YXMgc2lsZW50bHkgY2xvc2VkIGluIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaXMgbm90IG9wZW4sIGRpc2NhcmRpbmcgcGFja2V0c1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBvcGVuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcIm9wZW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCBwYWNrZXQgPSAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmRlY29kZVBhY2tldCkoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gICAgICAgIHRoaXMub25QYWNrZXQocGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQ2xvc2UoZGV0YWlscykge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJjbG9zZVwiLCBkZXRhaWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSB0cmFuc3BvcnQsIGluIG9yZGVyIG5vdCB0byBsb3NlIHBhY2tldHMgZHVyaW5nIGFuIHVwZ3JhZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25QYXVzZVxuICAgICAqL1xuICAgIHBhdXNlKG9uUGF1c2UpIHsgfVxuICAgIGNyZWF0ZVVyaShzY2hlbWEsIHF1ZXJ5ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIChzY2hlbWEgK1xuICAgICAgICAgICAgXCI6Ly9cIiArXG4gICAgICAgICAgICB0aGlzLl9ob3N0bmFtZSgpICtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQoKSArXG4gICAgICAgICAgICB0aGlzLm9wdHMucGF0aCArXG4gICAgICAgICAgICB0aGlzLl9xdWVyeShxdWVyeSkpO1xuICAgIH1cbiAgICBfaG9zdG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gdGhpcy5vcHRzLmhvc3RuYW1lO1xuICAgICAgICByZXR1cm4gaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xID8gaG9zdG5hbWUgOiBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgfVxuICAgIF9wb3J0KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnBvcnQgJiZcbiAgICAgICAgICAgICgodGhpcy5vcHRzLnNlY3VyZSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQgIT09IDQ0MykpIHx8XG4gICAgICAgICAgICAgICAgKCF0aGlzLm9wdHMuc2VjdXJlICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCkgIT09IDgwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjpcIiArIHRoaXMub3B0cy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3F1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRRdWVyeSA9ICgwLCBwYXJzZXFzX2pzXzEuZW5jb2RlKShxdWVyeSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkUXVlcnkubGVuZ3RoID8gXCI/XCIgKyBlbmNvZGVkUXVlcnkgOiBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYW5zcG9ydHMgPSB2b2lkIDA7XG5jb25zdCBwb2xsaW5nX3hocl9ub2RlX2pzXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nLXhoci5ub2RlLmpzXCIpO1xuY29uc3Qgd2Vic29ja2V0X25vZGVfanNfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldC5ub2RlLmpzXCIpO1xuY29uc3Qgd2VidHJhbnNwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi93ZWJ0cmFuc3BvcnQuanNcIik7XG5leHBvcnRzLnRyYW5zcG9ydHMgPSB7XG4gICAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfbm9kZV9qc18xLldTLFxuICAgIHdlYnRyYW5zcG9ydDogd2VidHJhbnNwb3J0X2pzXzEuV1QsXG4gICAgcG9sbGluZzogcG9sbGluZ194aHJfbm9kZV9qc18xLlhIUixcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmV0Y2ggPSB2b2lkIDA7XG5jb25zdCBwb2xsaW5nX2pzXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nLmpzXCIpO1xuLyoqXG4gKiBIVFRQIGxvbmctcG9sbGluZyBiYXNlZCBvbiB0aGUgYnVpbHQtaW4gYGZldGNoKClgIG1ldGhvZC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlciwgTm9kZS5qcyAoc2luY2UgdjE4KSwgRGVubywgQnVuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZmV0Y2hcbiAqIEBzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS9mZXRjaFxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2dsb2JhbHMuaHRtbCNmZXRjaFxuICovXG5jbGFzcyBGZXRjaCBleHRlbmRzIHBvbGxpbmdfanNfMS5Qb2xsaW5nIHtcbiAgICBkb1BvbGwoKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKClcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImZldGNoIHJlYWQgZXJyb3JcIiwgcmVzLnN0YXR1cywgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy50ZXh0KCkudGhlbigoZGF0YSkgPT4gdGhpcy5vbkRhdGEoZGF0YSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImZldGNoIHJlYWQgZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvV3JpdGUoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goZGF0YSlcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImZldGNoIHdyaXRlIGVycm9yXCIsIHJlcy5zdGF0dXMsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImZldGNoIHdyaXRlIGVycm9yXCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZmV0Y2goZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGlzUG9zdCA9IGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMub3B0cy5leHRyYUhlYWRlcnMpO1xuICAgICAgICBpZiAoaXNQb3N0KSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnNvY2tldC5fY29va2llSmFyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ29va2llcyhoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMudXJpKCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogaXNQb3N0ID8gXCJQT1NUXCIgOiBcIkdFVFwiLFxuICAgICAgICAgICAgYm9keTogaXNQb3N0ID8gZGF0YSA6IG51bGwsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMub3B0cy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwib21pdFwiLFxuICAgICAgICB9KS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgZ2V0U2V0Q29va2llKCkgd2FzIGFkZGVkIGluIE5vZGUuanMgdjE5LjcuMFxuICAgICAgICAgICAgKF9hID0gdGhpcy5zb2NrZXQuX2Nvb2tpZUphcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcnNlQ29va2llcyhyZXMuaGVhZGVycy5nZXRTZXRDb29raWUoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkZldGNoID0gRmV0Y2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWEhSID0gZXhwb3J0cy5SZXF1ZXN0ID0gZXhwb3J0cy5CYXNlWEhSID0gdm9pZCAwO1xuY29uc3QgcG9sbGluZ19qc18xID0gcmVxdWlyZShcIi4vcG9sbGluZy5qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuY29uc3QgZ2xvYmFsc19ub2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFscy5ub2RlLmpzXCIpO1xuY29uc3QgaGFzX2NvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi9jb250cmliL2hhcy1jb3JzLmpzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nXCIpOyAvLyBkZWJ1ZygpXG5mdW5jdGlvbiBlbXB0eSgpIHsgfVxuY2xhc3MgQmFzZVhIUiBleHRlbmRzIHBvbGxpbmdfanNfMS5Qb2xsaW5nIHtcbiAgICAvKipcbiAgICAgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1NTTCA9IFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgbGV0IHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuICAgICAgICAgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgICAgICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IGlzU1NMID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueGQgPVxuICAgICAgICAgICAgICAgICh0eXBlb2YgbG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvV3JpdGUoZGF0YSwgZm4pIHtcbiAgICAgICAgY29uc3QgcmVxID0gdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKFwic3VjY2Vzc1wiLCBmbik7XG4gICAgICAgIHJlcS5vbihcImVycm9yXCIsICh4aHJTdGF0dXMsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInhociBwb3N0IGVycm9yXCIsIHhoclN0YXR1cywgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1BvbGwoKSB7XG4gICAgICAgIGRlYnVnKFwieGhyIHBvbGxcIik7XG4gICAgICAgIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICAgICAgICByZXEub24oXCJkYXRhXCIsIHRoaXMub25EYXRhLmJpbmQodGhpcykpO1xuICAgICAgICByZXEub24oXCJlcnJvclwiLCAoeGhyU3RhdHVzLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ4aHIgcG9sbCBlcnJvclwiLCB4aHJTdGF0dXMsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsWGhyID0gcmVxO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVhIUiA9IEJhc2VYSFI7XG5jbGFzcyBSZXF1ZXN0IGV4dGVuZHMgY29tcG9uZW50X2VtaXR0ZXJfMS5FbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY3JlYXRlUmVxdWVzdCwgdXJpLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3Q7XG4gICAgICAgICgwLCB1dGlsX2pzXzEuaW5zdGFsbFRpbWVyRnVuY3Rpb25zKSh0aGlzLCBvcHRzKTtcbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuX21ldGhvZCA9IG9wdHMubWV0aG9kIHx8IFwiR0VUXCI7XG4gICAgICAgIHRoaXMuX3VyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgdXRpbF9qc18xLnBpY2spKHRoaXMuX29wdHMsIFwiYWdlbnRcIiwgXCJwZnhcIiwgXCJrZXlcIiwgXCJwYXNzcGhyYXNlXCIsIFwiY2VydFwiLCBcImNhXCIsIFwiY2lwaGVyc1wiLCBcInJlamVjdFVuYXV0aG9yaXplZFwiLCBcImF1dG9VbnJlZlwiKTtcbiAgICAgICAgb3B0cy54ZG9tYWluID0gISF0aGlzLl9vcHRzLnhkO1xuICAgICAgICBjb25zdCB4aHIgPSAodGhpcy5feGhyID0gdGhpcy5jcmVhdGVSZXF1ZXN0KG9wdHMpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlYnVnKFwieGhyIG9wZW4gJXM6ICVzXCIsIHRoaXMuX21ldGhvZCwgdGhpcy5fdXJpKTtcbiAgICAgICAgICAgIHhoci5vcGVuKHRoaXMuX21ldGhvZCwgdGhpcy5fdXJpLCB0cnVlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuX29wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0cy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLl9vcHRzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICBpZiAoXCJQT1NUXCIgPT09IHRoaXMuX21ldGhvZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiKi8qXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy5fb3B0cy5jb29raWVKYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDb29raWVzKHhocik7XG4gICAgICAgICAgICAvLyBpZTYgY2hlY2tcbiAgICAgICAgICAgIGlmIChcIndpdGhDcmVkZW50aWFsc1wiIGluIHhocikge1xuICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLl9vcHRzLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLl9vcHRzLnJlcXVlc3RUaW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX29wdHMuY29va2llSmFyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyc2VDb29raWVzKFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRSZXNwb25zZUhlYWRlcihcInNldC1jb29raWVcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKHR5cGVvZiB4aHIuc3RhdHVzID09PSBcIm51bWJlclwiID8geGhyLnN0YXR1cyA6IDApO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVidWcoXCJ4aHIgZGF0YSAlc1wiLCB0aGlzLl9kYXRhKTtcbiAgICAgICAgICAgIHhoci5zZW5kKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgICAgICAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuX2luZGV4XSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkVycm9yKGVycikge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVyciwgdGhpcy5feGhyKTtcbiAgICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGhvdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYW51cChmcm9tRXJyb3IpIHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB0aGlzLl94aHIgfHwgbnVsbCA9PT0gdGhpcy5feGhyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5feGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICAgICAgICBpZiAoZnJvbUVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuX2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94aHIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBsb2FkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25Mb2FkKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5feGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBhdHRhY2hFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbkV2ZW50ID0gXCJvbnBhZ2VoaWRlXCIgaW4gZ2xvYmFsc19ub2RlX2pzXzEuZ2xvYmFsVGhpc1NoaW0gPyBcInBhZ2VoaWRlXCIgOiBcInVubG9hZFwiO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICAgIGZvciAobGV0IGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgICAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeGhyID0gbmV3UmVxdWVzdCh7XG4gICAgICAgIHhkb21haW46IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiB4aHIgJiYgeGhyLnJlc3BvbnNlVHlwZSAhPT0gbnVsbDtcbn0pKCk7XG4vKipcbiAqIEhUVFAgbG9uZy1wb2xsaW5nIGJhc2VkIG9uIHRoZSBidWlsdC1pbiBgWE1MSHR0cFJlcXVlc3RgIG9iamVjdC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlclxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0XG4gKi9cbmNsYXNzIFhIUiBleHRlbmRzIEJhc2VYSFIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGNvbnN0IGZvcmNlQmFzZTY0ID0gb3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0O1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gaGFzWEhSMiAmJiAhZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgeyB4ZDogdGhpcy54ZCB9LCB0aGlzLm9wdHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QobmV3UmVxdWVzdCwgdGhpcy51cmkoKSwgb3B0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5YSFIgPSBYSFI7XG5mdW5jdGlvbiBuZXdSZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICAgIHRyeSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc19jb3JzX2pzXzEuaGFzQ09SUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgaWYgKCF4ZG9tYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdsb2JhbHNfbm9kZV9qc18xLmdsb2JhbFRoaXNTaGltW1tcIkFjdGl2ZVwiXS5jb25jYXQoXCJPYmplY3RcIikuam9pbihcIlhcIildKFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0LmpzXCIpO1xuY29uc3QgdXRpbF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZS5pby1jbGllbnQ6cG9sbGluZ1wiKTsgLy8gZGVidWcoKVxuY2xhc3MgUG9sbGluZyBleHRlbmRzIHRyYW5zcG9ydF9qc18xLlRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3BvbGxpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInBvbGxpbmdcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICAgICAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvT3BlbigpIHtcbiAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcG9sbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUGF1c2UgLSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIHBhdXNlKG9uUGF1c2UpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzaW5nXCI7XG4gICAgICAgIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJwYXVzZWRcIik7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcInBhdXNlZFwiO1xuICAgICAgICAgICAgb25QYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fcG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlXCIpO1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwicG9sbENvbXBsZXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlXCIpO1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiZHJhaW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcG9sbCgpIHtcbiAgICAgICAgZGVidWcoXCJwb2xsaW5nXCIpO1xuICAgICAgICB0aGlzLl9wb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb1BvbGwoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb2xsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBkZWJ1ZyhcInBvbGxpbmcgZ290IGRhdGEgJXNcIiwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgICAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgcGFja2V0LnR5cGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHsgZGVzY3JpcHRpb246IFwidHJhbnNwb3J0IGNsb3NlZCBieSB0aGUgc2VydmVyXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWNvZGUgcGF5bG9hZFxuICAgICAgICAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmRlY29kZVBheWxvYWQpKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgICAgICAgICAgdGhpcy5fcG9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb2xsQ29tcGxldGVcIik7XG4gICAgICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9DbG9zZSgpIHtcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcIndyaXRpbmcgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZShbeyB0eXBlOiBcImNsb3NlXCIgfV0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmdcIik7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAgICAgICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcIm9wZW5cIiwgY2xvc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHMgLSBkYXRhIHBhY2tldHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd3JpdGUocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuZW5jb2RlUGF5bG9hZCkocGFja2V0cywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXJpKCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLm9wdHMuc2VjdXJlID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLm9wdHMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSAoMCwgdXRpbF9qc18xLnJhbmRvbVN0cmluZykoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgICAgICAgICAgcXVlcnkuYjY0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVcmkoc2NoZW1hLCBxdWVyeSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nID0gUG9sbGluZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XUyA9IGV4cG9ydHMuQmFzZVdTID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0LmpzXCIpO1xuY29uc3QgdXRpbF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGdsb2JhbHNfbm9kZV9qc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHMubm9kZS5qc1wiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0XCIpOyAvLyBkZWJ1ZygpXG4vLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcInN0cmluZ1wiICYmXG4gICAgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gXCJyZWFjdG5hdGl2ZVwiO1xuY2xhc3MgQmFzZVdTIGV4dGVuZHMgdHJhbnNwb3J0X2pzXzEuVHJhbnNwb3J0IHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gICAgfVxuICAgIGRvT3BlbigpIHtcbiAgICAgICAgY29uc3QgdXJpID0gdGhpcy51cmkoKTtcbiAgICAgICAgY29uc3QgcHJvdG9jb2xzID0gdGhpcy5vcHRzLnByb3RvY29scztcbiAgICAgICAgLy8gUmVhY3QgTmF0aXZlIG9ubHkgc3VwcG9ydHMgdGhlICdoZWFkZXJzJyBvcHRpb24sIGFuZCB3aWxsIHByaW50IGEgd2FybmluZyBpZiBhbnl0aGluZyBlbHNlIGlzIHBhc3NlZFxuICAgICAgICBjb25zdCBvcHRzID0gaXNSZWFjdE5hdGl2ZVxuICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgOiAoMCwgdXRpbF9qc18xLnBpY2spKHRoaXMub3B0cywgXCJhZ2VudFwiLCBcInBlck1lc3NhZ2VEZWZsYXRlXCIsIFwicGZ4XCIsIFwia2V5XCIsIFwicGFzc3BocmFzZVwiLCBcImNlcnRcIiwgXCJjYVwiLCBcImNpcGhlcnNcIiwgXCJyZWplY3RVbmF1dGhvcml6ZWRcIiwgXCJsb2NhbEFkZHJlc3NcIiwgXCJwcm90b2NvbFZlcnNpb25cIiwgXCJvcmlnaW5cIiwgXCJtYXhQYXlsb2FkXCIsIFwiZmFtaWx5XCIsIFwiY2hlY2tTZXJ2ZXJJZGVudGl0eVwiKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IHRoaXMub3B0cy5leHRyYUhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud3MgPSB0aGlzLmNyZWF0ZVNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLnNvY2tldC5iaW5hcnlUeXBlO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hdXRvVW5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLl9zb2NrZXQudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25PcGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IChjbG9zZUV2ZW50KSA9PiB0aGlzLm9uQ2xvc2Uoe1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwid2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBjbG9zZUV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAoZXYpID0+IHRoaXMub25EYXRhKGV2LmRhdGEpO1xuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZSkgPT4gdGhpcy5vbkVycm9yKFwid2Vic29ja2V0IGVycm9yXCIsIGUpO1xuICAgIH1cbiAgICB3cml0ZShwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgICAgICAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFja2V0ID0gaSA9PT0gcGFja2V0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgKDAsIGVuZ2luZV9pb19wYXJzZXJfMS5lbmNvZGVQYWNrZXQpKHBhY2tldCwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvV3JpdGUocGFja2V0LCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWtlIGRyYWluXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICAgICAgICAgICAgICAgICAgKDAsIGdsb2JhbHNfbm9kZV9qc18xLm5leHRUaWNrKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMud3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwid3NzXCIgOiBcIndzXCI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgICAgICAgaWYgKHRoaXMub3B0cy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgICAgICAgICAgcXVlcnlbdGhpcy5vcHRzLnRpbWVzdGFtcFBhcmFtXSA9ICgwLCB1dGlsX2pzXzEucmFuZG9tU3RyaW5nKSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVdTID0gQmFzZVdTO1xuY29uc3QgV2ViU29ja2V0Q3RvciA9IGdsb2JhbHNfbm9kZV9qc18xLmdsb2JhbFRoaXNTaGltLldlYlNvY2tldCB8fCBnbG9iYWxzX25vZGVfanNfMS5nbG9iYWxUaGlzU2hpbS5Nb3pXZWJTb2NrZXQ7XG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgYmFzZWQgb24gdGhlIGJ1aWx0LWluIGBXZWJTb2NrZXRgIG9iamVjdC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlciwgTm9kZS5qcyAoc2luY2UgdjIxKSwgRGVubywgQnVuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0XG4gKiBAc2VlIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWFwaV93ZWJzb2NrZXRcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9nbG9iYWxzLmh0bWwjd2Vic29ja2V0XG4gKi9cbmNsYXNzIFdTIGV4dGVuZHMgQmFzZVdTIHtcbiAgICBjcmVhdGVTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuICFpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgICAgICAgID8gbmV3IFdlYlNvY2tldEN0b3IodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgICAgICAgOiBuZXcgV2ViU29ja2V0Q3Rvcih1cmkpXG4gICAgICAgICAgICA6IG5ldyBXZWJTb2NrZXRDdG9yKHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgICB9XG4gICAgZG9Xcml0ZShfcGFja2V0LCBkYXRhKSB7XG4gICAgICAgIHRoaXMud3Muc2VuZChkYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLldTID0gV1M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV1QgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfanNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnQuanNcIik7XG5jb25zdCBnbG9iYWxzX25vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzLm5vZGUuanNcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZS5pby1jbGllbnQ6d2VidHJhbnNwb3J0XCIpOyAvLyBkZWJ1ZygpXG4vKipcbiAqIFdlYlRyYW5zcG9ydCB0cmFuc3BvcnQgYmFzZWQgb24gdGhlIGJ1aWx0LWluIGBXZWJUcmFuc3BvcnRgIG9iamVjdC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlciwgTm9kZS5qcyAod2l0aCB0aGUgYEBmYWlscy1jb21wb25lbnRzL3dlYnRyYW5zcG9ydGAgcGFja2FnZSlcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJUcmFuc3BvcnRcbiAqIEBzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS93ZWJ0cmFuc3BvcnRcbiAqL1xuY2xhc3MgV1QgZXh0ZW5kcyB0cmFuc3BvcnRfanNfMS5UcmFuc3BvcnQge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJ0cmFuc3BvcnRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFdlYlRyYW5zcG9ydCh0aGlzLmNyZWF0ZVVyaShcImh0dHBzXCIpLCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1t0aGlzLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZWRcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGNsb3NlZCBncmFjZWZ1bGx5XCIpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgY2xvc2VkIGR1ZSB0byAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwid2VidHJhbnNwb3J0IGVycm9yXCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCBoYXZlIHVzZWQgYXN5bmMvYXdhaXQsIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgc29tZSBhZGRpdGlvbmFsIHBvbHlmaWxsc1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQuY3JlYXRlQmlkaXJlY3Rpb25hbFN0cmVhbSgpLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZXJTdHJlYW0gPSAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmNyZWF0ZVBhY2tldERlY29kZXJTdHJlYW0pKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goZGVjb2RlclN0cmVhbSkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlclN0cmVhbSA9ICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSkoKTtcbiAgICAgICAgICAgICAgICBlbmNvZGVyU3RyZWFtLnJlYWRhYmxlLnBpcGVUbyhzdHJlYW0ud3JpdGFibGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlciA9IGVuY29kZXJTdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVhZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic2Vzc2lvbiBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZWNlaXZlZCBjaHVuazogJW9cIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhY2tldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJhbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZWFkaW5nOiAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXQgPSB7IHR5cGU6IFwib3BlblwiIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuc2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldC5kYXRhID0gYHtcInNpZFwiOlwiJHt0aGlzLnF1ZXJ5LnNpZH1cIn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZXIud3JpdGUocGFja2V0KS50aGVuKCgpID0+IHRoaXMub25PcGVuKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3cml0ZShwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhY2tldCA9IGkgPT09IHBhY2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZShwYWNrZXQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBnbG9iYWxzX25vZGVfanNfMS5uZXh0VGljaykoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9DbG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl90cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV1QgPSBXVDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5waWNrID0gcGljaztcbmV4cG9ydHMuaW5zdGFsbFRpbWVyRnVuY3Rpb25zID0gaW5zdGFsbFRpbWVyRnVuY3Rpb25zO1xuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbmV4cG9ydHMucmFuZG9tU3RyaW5nID0gcmFuZG9tU3RyaW5nO1xuY29uc3QgZ2xvYmFsc19ub2RlX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzLm5vZGUuanNcIik7XG5mdW5jdGlvbiBwaWNrKG9iaiwgLi4uYXR0cikge1xuICAgIHJldHVybiBhdHRyLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGFjY1trXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbi8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHJlYWwgdGltZW91dCBmdW5jdGlvbnMgc28gdGhleSBjYW4gYmUgdXNlZCB3aGVuIG92ZXJyaWRkZW5cbmNvbnN0IE5BVElWRV9TRVRfVElNRU9VVCA9IGdsb2JhbHNfbm9kZV9qc18xLmdsb2JhbFRoaXNTaGltLnNldFRpbWVvdXQ7XG5jb25zdCBOQVRJVkVfQ0xFQVJfVElNRU9VVCA9IGdsb2JhbHNfbm9kZV9qc18xLmdsb2JhbFRoaXNTaGltLmNsZWFyVGltZW91dDtcbmZ1bmN0aW9uIGluc3RhbGxUaW1lckZ1bmN0aW9ucyhvYmosIG9wdHMpIHtcbiAgICBpZiAob3B0cy51c2VOYXRpdmVUaW1lcnMpIHtcbiAgICAgICAgb2JqLnNldFRpbWVvdXRGbiA9IE5BVElWRV9TRVRfVElNRU9VVC5iaW5kKGdsb2JhbHNfbm9kZV9qc18xLmdsb2JhbFRoaXNTaGltKTtcbiAgICAgICAgb2JqLmNsZWFyVGltZW91dEZuID0gTkFUSVZFX0NMRUFSX1RJTUVPVVQuYmluZChnbG9iYWxzX25vZGVfanNfMS5nbG9iYWxUaGlzU2hpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmouc2V0VGltZW91dEZuID0gZ2xvYmFsc19ub2RlX2pzXzEuZ2xvYmFsVGhpc1NoaW0uc2V0VGltZW91dC5iaW5kKGdsb2JhbHNfbm9kZV9qc18xLmdsb2JhbFRoaXNTaGltKTtcbiAgICAgICAgb2JqLmNsZWFyVGltZW91dEZuID0gZ2xvYmFsc19ub2RlX2pzXzEuZ2xvYmFsVGhpc1NoaW0uY2xlYXJUaW1lb3V0LmJpbmQoZ2xvYmFsc19ub2RlX2pzXzEuZ2xvYmFsVGhpc1NoaW0pO1xuICAgIH1cbn1cbi8vIGJhc2U2NCBlbmNvZGVkIGJ1ZmZlcnMgYXJlIGFib3V0IDMzJSBiaWdnZXIgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NClcbmNvbnN0IEJBU0U2NF9PVkVSSEVBRCA9IDEuMzM7XG4vLyB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCBgbmV3IEJsb2IoW29ial0pLnNpemVgLCBidXQgaXQgaXNuJ3Qgc3VwcG9ydGVkIGluIElFOVxuZnVuY3Rpb24gYnl0ZUxlbmd0aChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXRmOExlbmd0aChvYmopO1xuICAgIH1cbiAgICAvLyBhcnJheWJ1ZmZlciBvciBibG9iXG4gICAgcmV0dXJuIE1hdGguY2VpbCgob2JqLmJ5dGVMZW5ndGggfHwgb2JqLnNpemUpICogQkFTRTY0X09WRVJIRUFEKTtcbn1cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgbGV0IGMgPSAwLCBsZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGxlbmd0aCArPSA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSA4LWNoYXJhY3RlcnMgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gICAgcmV0dXJuIChEYXRlLm5vdygpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMykgK1xuICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNSkpO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVSUk9SX1BBQ0tFVCA9IGV4cG9ydHMuUEFDS0VUX1RZUEVTX1JFVkVSU0UgPSBleHBvcnRzLlBBQ0tFVF9UWVBFUyA9IHZvaWQgMDtcbmNvbnN0IFBBQ0tFVF9UWVBFUyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIG5vIE1hcCA9IG5vIHBvbHlmaWxsXG5leHBvcnRzLlBBQ0tFVF9UWVBFUyA9IFBBQ0tFVF9UWVBFUztcblBBQ0tFVF9UWVBFU1tcIm9wZW5cIl0gPSBcIjBcIjtcblBBQ0tFVF9UWVBFU1tcImNsb3NlXCJdID0gXCIxXCI7XG5QQUNLRVRfVFlQRVNbXCJwaW5nXCJdID0gXCIyXCI7XG5QQUNLRVRfVFlQRVNbXCJwb25nXCJdID0gXCIzXCI7XG5QQUNLRVRfVFlQRVNbXCJtZXNzYWdlXCJdID0gXCI0XCI7XG5QQUNLRVRfVFlQRVNbXCJ1cGdyYWRlXCJdID0gXCI1XCI7XG5QQUNLRVRfVFlQRVNbXCJub29wXCJdID0gXCI2XCI7XG5jb25zdCBQQUNLRVRfVFlQRVNfUkVWRVJTRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnRzLlBBQ0tFVF9UWVBFU19SRVZFUlNFID0gUEFDS0VUX1RZUEVTX1JFVkVSU0U7XG5PYmplY3Qua2V5cyhQQUNLRVRfVFlQRVMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIFBBQ0tFVF9UWVBFU19SRVZFUlNFW1BBQ0tFVF9UWVBFU1trZXldXSA9IGtleTtcbn0pO1xuY29uc3QgRVJST1JfUEFDS0VUID0geyB0eXBlOiBcImVycm9yXCIsIGRhdGE6IFwicGFyc2VyIGVycm9yXCIgfTtcbmV4cG9ydHMuRVJST1JfUEFDS0VUID0gRVJST1JfUEFDS0VUO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vYmFzZTY0LWFycmF5YnVmZmVyXG5jb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbi8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbmNvbnN0IGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xufVxuY29uc3QgZW5jb2RlID0gKGFycmF5YnVmZmVyKSA9PiB7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmNvbnN0IGRlY29kZSA9IChiYXNlNjQpID0+IHtcbiAgICBsZXQgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLCBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gJz0nKSB7XG4gICAgICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMildO1xuICAgICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xufTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVBhY2tldCA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbnNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbnMuanNcIik7XG5jb25zdCBiYXNlNjRfYXJyYXlidWZmZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyaWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBkZWNvZGVQYWNrZXQgPSAoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZW5jb2RlZFBhY2tldCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBkYXRhOiBtYXBCaW5hcnkoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBlbmNvZGVkUGFja2V0LmNoYXJBdCgwKTtcbiAgICBpZiAodHlwZSA9PT0gXCJiXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogZGVjb2RlQmFzZTY0UGFja2V0KGVuY29kZWRQYWNrZXQuc3Vic3RyaW5nKDEpLCBiaW5hcnlUeXBlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFja2V0VHlwZSA9IGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXTtcbiAgICBpZiAoIXBhY2tldFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbnNfanNfMS5FUlJPUl9QQUNLRVQ7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkUGFja2V0Lmxlbmd0aCA+IDFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBjb21tb25zX2pzXzEuUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV0sXG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVkUGFja2V0LnN1YnN0cmluZygxKSxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHR5cGU6IGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXSxcbiAgICAgICAgfTtcbn07XG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGRlY29kZVBhY2tldDtcbmNvbnN0IGRlY29kZUJhc2U2NFBhY2tldCA9IChkYXRhLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlcikge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gKDAsIGJhc2U2NF9hcnJheWJ1ZmZlcl9qc18xLmRlY29kZSkoZGF0YSk7XG4gICAgICAgIHJldHVybiBtYXBCaW5hcnkoZGVjb2RlZCwgYmluYXJ5VHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBiYXNlNjQ6IHRydWUsIGRhdGEgfTsgLy8gZmFsbGJhY2sgZm9yIG9sZCBicm93c2Vyc1xuICAgIH1cbn07XG5jb25zdCBtYXBCaW5hcnkgPSAoZGF0YSwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIHN3aXRjaCAoYmluYXJ5VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBXZWJTb2NrZXQgKyBiaW5hcnlUeXBlIFwiYmxvYlwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmcm9tIEhUVFAgbG9uZy1wb2xsaW5nIG9yIFdlYlRyYW5zcG9ydFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbZGF0YV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBmcm9tIEhUVFAgbG9uZy1wb2xsaW5nIChiYXNlNjQpIG9yIFdlYlNvY2tldCArIGJpbmFyeVR5cGUgXCJhcnJheWJ1ZmZlclwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmcm9tIFdlYlRyYW5zcG9ydCAoVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSB2b2lkIDA7XG5leHBvcnRzLmVuY29kZVBhY2tldFRvQmluYXJ5ID0gZW5jb2RlUGFja2V0VG9CaW5hcnk7XG5jb25zdCBjb21tb25zX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb25zLmpzXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gXCJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl1cIik7XG5jb25zdCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIjtcbi8vIEFycmF5QnVmZmVyLmlzVmlldyBtZXRob2QgaXMgbm90IGRlZmluZWQgaW4gSUUxMFxuY29uc3QgaXNWaWV3ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuY29uc3QgZW5jb2RlUGFja2V0ID0gKHsgdHlwZSwgZGF0YSB9LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAod2l0aE5hdGl2ZUJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlQmxvYkFzQmFzZTY0KGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiZcbiAgICAgICAgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcoZGF0YSkpKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0Jhc2U2NChuZXcgQmxvYihbZGF0YV0pLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgcmV0dXJuIGNhbGxiYWNrKGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNbdHlwZV0gKyAoZGF0YSB8fCBcIlwiKSk7XG59O1xuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBlbmNvZGVQYWNrZXQ7XG5jb25zdCBlbmNvZGVCbG9iQXNCYXNlNjQgPSAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZpbGVSZWFkZXIucmVzdWx0LnNwbGl0KFwiLFwiKVsxXTtcbiAgICAgICAgY2FsbGJhY2soXCJiXCIgKyAoY29udGVudCB8fCBcIlwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGRhdGEpO1xufTtcbmZ1bmN0aW9uIHRvQXJyYXkoZGF0YSkge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIH1cbn1cbmxldCBURVhUX0VOQ09ERVI7XG5mdW5jdGlvbiBlbmNvZGVQYWNrZXRUb0JpbmFyeShwYWNrZXQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdpdGhOYXRpdmVCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICByZXR1cm4gcGFja2V0LmRhdGEuYXJyYXlCdWZmZXIoKS50aGVuKHRvQXJyYXkpLnRoZW4oY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiZcbiAgICAgICAgKHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KHBhY2tldC5kYXRhKSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRvQXJyYXkocGFja2V0LmRhdGEpKTtcbiAgICB9XG4gICAgZW5jb2RlUGFja2V0KHBhY2tldCwgZmFsc2UsIChlbmNvZGVkKSA9PiB7XG4gICAgICAgIGlmICghVEVYVF9FTkNPREVSKSB7XG4gICAgICAgICAgICBURVhUX0VOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhURVhUX0VOQ09ERVIuZW5jb2RlKGVuY29kZWQpKTtcbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBleHBvcnRzLmVuY29kZVBheWxvYWQgPSBleHBvcnRzLmVuY29kZVBhY2tldCA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0gPSBjcmVhdGVQYWNrZXRFbmNvZGVyU3RyZWFtO1xuZXhwb3J0cy5jcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtID0gY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbTtcbmNvbnN0IGVuY29kZVBhY2tldF9qc18xID0gcmVxdWlyZShcIi4vZW5jb2RlUGFja2V0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlUGFja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVQYWNrZXRfanNfMS5lbmNvZGVQYWNrZXQ7IH0gfSk7XG5jb25zdCBkZWNvZGVQYWNrZXRfanNfMSA9IHJlcXVpcmUoXCIuL2RlY29kZVBhY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVBhY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlUGFja2V0X2pzXzEuZGVjb2RlUGFja2V0OyB9IH0pO1xuY29uc3QgY29tbW9uc19qc18xID0gcmVxdWlyZShcIi4vY29tbW9ucy5qc1wiKTtcbmNvbnN0IFNFUEFSQVRPUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzApOyAvLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVyI0FTQ0lJX2RlbGltaXRlZF90ZXh0XG5jb25zdCBlbmNvZGVQYXlsb2FkID0gKHBhY2tldHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgLy8gc29tZSBwYWNrZXRzIG1heSBiZSBhZGRlZCB0byB0aGUgYXJyYXkgd2hpbGUgZW5jb2RpbmcsIHNvIHRoZSBpbml0aWFsIGxlbmd0aCBtdXN0IGJlIHNhdmVkXG4gICAgY29uc3QgbGVuZ3RoID0gcGFja2V0cy5sZW5ndGg7XG4gICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHBhY2tldHMuZm9yRWFjaCgocGFja2V0LCBpKSA9PiB7XG4gICAgICAgIC8vIGZvcmNlIGJhc2U2NCBlbmNvZGluZyBmb3IgYmluYXJ5IHBhY2tldHNcbiAgICAgICAgKDAsIGVuY29kZVBhY2tldF9qc18xLmVuY29kZVBhY2tldCkocGFja2V0LCBmYWxzZSwgKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGVuY29kZWRQYWNrZXRzW2ldID0gZW5jb2RlZFBhY2tldDtcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbmNvZGVkUGFja2V0cy5qb2luKFNFUEFSQVRPUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBlbmNvZGVQYXlsb2FkO1xuY29uc3QgZGVjb2RlUGF5bG9hZCA9IChlbmNvZGVkUGF5bG9hZCwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gZW5jb2RlZFBheWxvYWQuc3BsaXQoU0VQQVJBVE9SKTtcbiAgICBjb25zdCBwYWNrZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWNvZGVkUGFja2V0ID0gKDAsIGRlY29kZVBhY2tldF9qc18xLmRlY29kZVBhY2tldCkoZW5jb2RlZFBhY2tldHNbaV0sIGJpbmFyeVR5cGUpO1xuICAgICAgICBwYWNrZXRzLnB1c2goZGVjb2RlZFBhY2tldCk7XG4gICAgICAgIGlmIChkZWNvZGVkUGFja2V0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhY2tldHM7XG59O1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZGVjb2RlUGF5bG9hZDtcbmZ1bmN0aW9uIGNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0oKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0ocGFja2V0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAoMCwgZW5jb2RlUGFja2V0X2pzXzEuZW5jb2RlUGFja2V0VG9CaW5hcnkpKHBhY2tldCwgKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gZW5jb2RlZFBhY2tldC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgICAgICAgICAvLyBpbnNwaXJlZCBieSB0aGUgV2ViU29ja2V0IGZvcm1hdDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldHNfQVBJL1dyaXRpbmdfV2ViU29ja2V0X3NlcnZlcnMjZGVjb2RpbmdfcGF5bG9hZF9sZW5ndGhcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8IDEyNikge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGhlYWRlci5idWZmZXIpLnNldFVpbnQ4KDAsIHBheWxvYWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgoMCwgMTI2KTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MTYoMSwgcGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSg5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OCgwLCAxMjcpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LnNldEJpZ1VpbnQ2NCgxLCBCaWdJbnQocGF5bG9hZExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBiaXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgcGxhaW4gdGV4dCAoMCkgb3IgYmluYXJ5ICgxKVxuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuZGF0YSAmJiB0eXBlb2YgcGFja2V0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyWzBdIHw9IDB4ODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkUGFja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxubGV0IFRFWFRfREVDT0RFUjtcbmZ1bmN0aW9uIHRvdGFsTGVuZ3RoKGNodW5rcykge1xuICAgIHJldHVybiBjaHVua3MucmVkdWNlKChhY2MsIGNodW5rKSA9PiBhY2MgKyBjaHVuay5sZW5ndGgsIDApO1xufVxuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgc2l6ZSkge1xuICAgIGlmIChjaHVua3NbMF0ubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBjaHVua3Muc2hpZnQoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGNodW5rc1swXVtqKytdO1xuICAgICAgICBpZiAoaiA9PT0gY2h1bmtzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCAmJiBqIDwgY2h1bmtzWzBdLmxlbmd0aCkge1xuICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc2xpY2Uoaik7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtKG1heFBheWxvYWQsIGJpbmFyeVR5cGUpIHtcbiAgICBpZiAoIVRFWFRfREVDT0RFUikge1xuICAgICAgICBURVhUX0RFQ09ERVIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgbGV0IHN0YXRlID0gMCAvKiBTdGF0ZS5SRUFEX0hFQURFUiAqLztcbiAgICBsZXQgZXhwZWN0ZWRMZW5ndGggPSAtMTtcbiAgICBsZXQgaXNCaW5hcnkgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDAgLyogU3RhdGUuUkVBRF9IRUFERVIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoKGNodW5rcykgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBjb25jYXRDaHVua3MoY2h1bmtzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaXNCaW5hcnkgPSAoaGVhZGVyWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoID0gaGVhZGVyWzBdICYgMHg3ZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkTGVuZ3RoIDwgMTI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogU3RhdGUuUkVBRF9QQVlMT0FEICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4cGVjdGVkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMSAvKiBTdGF0ZS5SRUFEX0VYVEVOREVEX0xFTkdUSF8xNiAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMiAvKiBTdGF0ZS5SRUFEX0VYVEVOREVEX0xFTkdUSF82NCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMSAvKiBTdGF0ZS5SRUFEX0VYVEVOREVEX0xFTkdUSF8xNiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxMZW5ndGgoY2h1bmtzKSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gY29uY2F0Q2h1bmtzKGNodW5rcywgMik7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoID0gbmV3IERhdGFWaWV3KGhlYWRlckFycmF5LmJ1ZmZlciwgaGVhZGVyQXJyYXkuYnl0ZU9mZnNldCwgaGVhZGVyQXJyYXkubGVuZ3RoKS5nZXRVaW50MTYoMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMyAvKiBTdGF0ZS5SRUFEX1BBWUxPQUQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAyIC8qIFN0YXRlLlJFQURfRVhURU5ERURfTEVOR1RIXzY0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aChjaHVua3MpIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyQXJyYXkgPSBjb25jYXRDaHVua3MoY2h1bmtzLCA4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXJBcnJheS5idWZmZXIsIGhlYWRlckFycmF5LmJ5dGVPZmZzZXQsIGhlYWRlckFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY29tbW9uc19qc18xLkVSUk9SX1BBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IG4gKiBNYXRoLnBvdygyLCAzMikgKyB2aWV3LmdldFVpbnQzMig0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIFN0YXRlLlJFQURfUEFZTE9BRCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aChjaHVua3MpIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjb25jYXRDaHVua3MoY2h1bmtzLCBleHBlY3RlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSgoMCwgZGVjb2RlUGFja2V0X2pzXzEuZGVjb2RlUGFja2V0KShpc0JpbmFyeSA/IGRhdGEgOiBURVhUX0RFQ09ERVIuZGVjb2RlKGRhdGEpLCBiaW5hcnlUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMCAvKiBTdGF0ZS5SRUFEX0hFQURFUiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkTGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGVuZ3RoID4gbWF4UGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY29tbW9uc19qc18xLkVSUk9SX1BBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IEFQUF9OQU1FID0gJ2gyNjQtcHJvZmlsZS1sZXZlbC1pZCc7XG5jbGFzcyBMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0FQUF9OQU1FfToke3ByZWZpeH1gKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtBUFBfTkFNRX06V0FSTjoke3ByZWZpeH1gKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OkVSUk9SOiR7cHJlZml4fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShBUFBfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLl93YXJuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OldBUk5gKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OkVSUk9SYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICB0aGlzLl9kZWJ1Zy5sb2cgPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKTtcbiAgICAgICAgdGhpcy5fd2Fybi5sb2cgPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgICAgdGhpcy5fZXJyb3IubG9nID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB9XG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWc7XG4gICAgfVxuICAgIGdldCB3YXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FybjtcbiAgICB9XG4gICAgZ2V0IGVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlciA9IGV4cG9ydHMuaXNTYW1lUHJvZmlsZSA9IGV4cG9ydHMucGFyc2VTZHBQcm9maWxlTGV2ZWxJZCA9IGV4cG9ydHMubGV2ZWxUb1N0cmluZyA9IGV4cG9ydHMucHJvZmlsZVRvU3RyaW5nID0gZXhwb3J0cy5wcm9maWxlTGV2ZWxJZFRvU3RyaW5nID0gZXhwb3J0cy5wYXJzZVByb2ZpbGVMZXZlbElkID0gZXhwb3J0cy5Qcm9maWxlTGV2ZWxJZCA9IGV4cG9ydHMuTGV2ZWwgPSBleHBvcnRzLlByb2ZpbGUgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoKTtcbi8qKlxuICogU3VwcG9ydGVkIHByb2ZpbGVzLlxuICovXG4vLyBFU0xpbnQgYWJzdXJkbHkgY29tcGxhaW5zIGFib3V0IFwiJ1Byb2ZpbGUnIGlzIGFscmVhZHkgZGVjbGFyZWQgaW5cbi8vIHRoZSB1cHBlciBzY29wZVwiLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xudmFyIFByb2ZpbGU7XG4oZnVuY3Rpb24gKFByb2ZpbGUpIHtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJDb25zdHJhaW5lZEJhc2VsaW5lXCJdID0gMV0gPSBcIkNvbnN0cmFpbmVkQmFzZWxpbmVcIjtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJCYXNlbGluZVwiXSA9IDJdID0gXCJCYXNlbGluZVwiO1xuICAgIFByb2ZpbGVbUHJvZmlsZVtcIk1haW5cIl0gPSAzXSA9IFwiTWFpblwiO1xuICAgIFByb2ZpbGVbUHJvZmlsZVtcIkNvbnN0cmFpbmVkSGlnaFwiXSA9IDRdID0gXCJDb25zdHJhaW5lZEhpZ2hcIjtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJIaWdoXCJdID0gNV0gPSBcIkhpZ2hcIjtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJQcmVkaWN0aXZlSGlnaDQ0NFwiXSA9IDZdID0gXCJQcmVkaWN0aXZlSGlnaDQ0NFwiO1xufSkoUHJvZmlsZSB8fCAoZXhwb3J0cy5Qcm9maWxlID0gUHJvZmlsZSA9IHt9KSk7XG4vKipcbiAqIFN1cHBvcnRlZCBsZXZlbHMuXG4gKi9cbi8vIEVTTGludCBhYnN1cmRseSBjb21wbGFpbnMgYWJvdXQgXCInTGV2ZWwnIGlzIGFscmVhZHkgZGVjbGFyZWQgaW5cbi8vIHRoZSB1cHBlciBzY29wZVwiLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xudmFyIExldmVsO1xuKGZ1bmN0aW9uIChMZXZlbCkge1xuICAgIExldmVsW0xldmVsW1wiTDFfYlwiXSA9IDBdID0gXCJMMV9iXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMMVwiXSA9IDEwXSA9IFwiTDFcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwxXzFcIl0gPSAxMV0gPSBcIkwxXzFcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwxXzJcIl0gPSAxMl0gPSBcIkwxXzJcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwxXzNcIl0gPSAxM10gPSBcIkwxXzNcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwyXCJdID0gMjBdID0gXCJMMlwiO1xuICAgIExldmVsW0xldmVsW1wiTDJfMVwiXSA9IDIxXSA9IFwiTDJfMVwiO1xuICAgIExldmVsW0xldmVsW1wiTDJfMlwiXSA9IDIyXSA9IFwiTDJfMlwiO1xuICAgIExldmVsW0xldmVsW1wiTDNcIl0gPSAzMF0gPSBcIkwzXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMM18xXCJdID0gMzFdID0gXCJMM18xXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMM18yXCJdID0gMzJdID0gXCJMM18yXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMNFwiXSA9IDQwXSA9IFwiTDRcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkw0XzFcIl0gPSA0MV0gPSBcIkw0XzFcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkw0XzJcIl0gPSA0Ml0gPSBcIkw0XzJcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkw1XCJdID0gNTBdID0gXCJMNVwiO1xuICAgIExldmVsW0xldmVsW1wiTDVfMVwiXSA9IDUxXSA9IFwiTDVfMVwiO1xuICAgIExldmVsW0xldmVsW1wiTDVfMlwiXSA9IDUyXSA9IFwiTDVfMlwiO1xufSkoTGV2ZWwgfHwgKGV4cG9ydHMuTGV2ZWwgPSBMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwYXJzZWQgaDI2NCBwcm9maWxlLWxldmVsLWlkIHZhbHVlLlxuICovXG5jbGFzcyBQcm9maWxlTGV2ZWxJZCB7XG4gICAgY29uc3RydWN0b3IocHJvZmlsZSwgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZmlsZUxldmVsSWQgPSBQcm9maWxlTGV2ZWxJZDtcbi8vIERlZmF1bHQgUHJvZmlsZUxldmVsSWQuXG4vL1xuLy8gVE9ETzogVGhlIGRlZmF1bHQgc2hvdWxkIHJlYWxseSBiZSBwcm9maWxlIEJhc2VsaW5lIGFuZCBsZXZlbCAxIGFjY29yZGluZyB0b1xuLy8gdGhlIHNwZWM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MTg0I3NlY3Rpb24tOC4xLiBJbiBvcmRlciB0byBub3Rcbi8vIGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgV2ViUlRDIHdoZXJlIGV4dGVybmFsXG4vLyBjb2RlY3MgZG9uJ3QgaGF2ZSBhbnkgcGFyYW1ldGVycywgdXNlIHByb2ZpbGUgQ29uc3RyYWluZWRCYXNlbGluZSBsZXZlbCAzXzFcbi8vIGluc3RlYWQuIFRoaXMgd29ya2Fyb3VuZCB3aWxsIG9ubHkgYmUgZG9uZSBpbiBhbiBpbnRlcmltIHBlcmlvZCB0byBhbGxvd1xuLy8gZXh0ZXJuYWwgY2xpZW50cyB0byB1cGRhdGUgdGhlaXIgY29kZS5cbi8vXG4vLyBodHRwOi8vY3JidWcvd2VicnRjLzYzMzcuXG5jb25zdCBEZWZhdWx0UHJvZmlsZUxldmVsSWQgPSBuZXcgUHJvZmlsZUxldmVsSWQoUHJvZmlsZS5Db25zdHJhaW5lZEJhc2VsaW5lLCBMZXZlbC5MM18xKTtcbi8qKlxuICogQ2xhc3MgZm9yIG1hdGNoaW5nIGJpdCBwYXR0ZXJucyBzdWNoIGFzIFwieDF4eDAwMDBcIiB3aGVyZSAneCcgaXMgYWxsb3dlZCB0b1xuICogYmUgZWl0aGVyIDAgb3IgMS5cbiAqL1xuY2xhc3MgQml0UGF0dGVybiB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMubWFzayA9IH5ieXRlTWFza1N0cmluZygneCcsIHN0cik7XG4gICAgICAgIHRoaXMubWFza2VkX3ZhbHVlID0gYnl0ZU1hc2tTdHJpbmcoJzEnLCBzdHIpO1xuICAgIH1cbiAgICBpc01hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hc2tlZF92YWx1ZSA9PT0gKHZhbHVlICYgdGhpcy5tYXNrKTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gcHJvZmlsZV9pZGMvcHJvZmlsZV9pb3AgdG8gUHJvZmlsZS5cbiAqL1xuY2xhc3MgUHJvZmlsZVBhdHRlcm4ge1xuICAgIGNvbnN0cnVjdG9yKHByb2ZpbGVfaWRjLCBwcm9maWxlX2lvcCwgcHJvZmlsZSkge1xuICAgICAgICB0aGlzLnByb2ZpbGVfaWRjID0gcHJvZmlsZV9pZGM7XG4gICAgICAgIHRoaXMucHJvZmlsZV9pb3AgPSBwcm9maWxlX2lvcDtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcbiAgICB9XG59XG4vLyBUaGlzIGlzIGZyb20gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxODQjc2VjdGlvbi04LjEuXG5jb25zdCBQcm9maWxlUGF0dGVybnMgPSBbXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4NDIsIG5ldyBCaXRQYXR0ZXJuKCd4MXh4MDAwMCcpLCBQcm9maWxlLkNvbnN0cmFpbmVkQmFzZWxpbmUpLFxuICAgIG5ldyBQcm9maWxlUGF0dGVybigweDRELCBuZXcgQml0UGF0dGVybignMXh4eDAwMDAnKSwgUHJvZmlsZS5Db25zdHJhaW5lZEJhc2VsaW5lKSxcbiAgICBuZXcgUHJvZmlsZVBhdHRlcm4oMHg1OCwgbmV3IEJpdFBhdHRlcm4oJzExeHgwMDAwJyksIFByb2ZpbGUuQ29uc3RyYWluZWRCYXNlbGluZSksXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4NDIsIG5ldyBCaXRQYXR0ZXJuKCd4MHh4MDAwMCcpLCBQcm9maWxlLkJhc2VsaW5lKSxcbiAgICBuZXcgUHJvZmlsZVBhdHRlcm4oMHg1OCwgbmV3IEJpdFBhdHRlcm4oJzEweHgwMDAwJyksIFByb2ZpbGUuQmFzZWxpbmUpLFxuICAgIG5ldyBQcm9maWxlUGF0dGVybigweDRELCBuZXcgQml0UGF0dGVybignMHgweDAwMDAnKSwgUHJvZmlsZS5NYWluKSxcbiAgICBuZXcgUHJvZmlsZVBhdHRlcm4oMHg2NCwgbmV3IEJpdFBhdHRlcm4oJzAwMDAwMDAwJyksIFByb2ZpbGUuSGlnaCksXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4NjQsIG5ldyBCaXRQYXR0ZXJuKCcwMDAwMTEwMCcpLCBQcm9maWxlLkNvbnN0cmFpbmVkSGlnaCksXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4RjQsIG5ldyBCaXRQYXR0ZXJuKCcwMDAwMDAwMCcpLCBQcm9maWxlLlByZWRpY3RpdmVIaWdoNDQ0KVxuXTtcbi8qKlxuICogUGFyc2UgcHJvZmlsZSBsZXZlbCBpZCB0aGF0IGlzIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9mIDMgaGV4IGJ5dGVzLlxuICogTm90aGluZyB3aWxsIGJlIHJldHVybmVkIGlmIHRoZSBzdHJpbmcgaXMgbm90IGEgcmVjb2duaXplZCBIMjY0IHByb2ZpbGVcbiAqIGxldmVsIGlkLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb2ZpbGVMZXZlbElkKHN0cikge1xuICAgIC8vIEZvciBsZXZlbF9pZGM9MTEgYW5kIHByb2ZpbGVfaWRjPTB4NDIsIDB4NEQsIG9yIDB4NTgsIHRoZSBjb25zdHJhaW50IHNldDNcbiAgICAvLyBmbGFnIHNwZWNpZmllcyBpZiBsZXZlbCAxYiBvciBsZXZlbCAxLjEgaXMgdXNlZC5cbiAgICBjb25zdCBDb25zdHJhaW50U2V0M0ZsYWcgPSAweDEwO1xuICAgIC8vIFRoZSBzdHJpbmcgc2hvdWxkIGNvbnNpc3Qgb2YgMyBieXRlcyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IHN0ci5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcHJvZmlsZV9sZXZlbF9pZF9udW1lcmljID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgaWYgKHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBTZXBhcmF0ZSBpbnRvIHRocmVlIGJ5dGVzLlxuICAgIGNvbnN0IGxldmVsX2lkYyA9IChwcm9maWxlX2xldmVsX2lkX251bWVyaWMgJiAweEZGKTtcbiAgICBjb25zdCBwcm9maWxlX2lvcCA9IChwcm9maWxlX2xldmVsX2lkX251bWVyaWMgPj4gOCkgJiAweEZGO1xuICAgIGNvbnN0IHByb2ZpbGVfaWRjID0gKHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA+PiAxNikgJiAweEZGO1xuICAgIC8vIFBhcnNlIGxldmVsIGJhc2VkIG9uIGxldmVsX2lkYyBhbmQgY29uc3RyYWludCBzZXQgMyBmbGFnLlxuICAgIGxldCBsZXZlbDtcbiAgICBzd2l0Y2ggKGxldmVsX2lkYykge1xuICAgICAgICBjYXNlIExldmVsLkwxXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSAocHJvZmlsZV9pb3AgJiBDb25zdHJhaW50U2V0M0ZsYWcpICE9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gTGV2ZWwuTDFfYlxuICAgICAgICAgICAgICAgICAgICA6IExldmVsLkwxXzE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDE6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDFfMjpcbiAgICAgICAgY2FzZSBMZXZlbC5MMV8zOlxuICAgICAgICBjYXNlIExldmVsLkwyOlxuICAgICAgICBjYXNlIExldmVsLkwyXzE6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDJfMjpcbiAgICAgICAgY2FzZSBMZXZlbC5MMzpcbiAgICAgICAgY2FzZSBMZXZlbC5MM18xOlxuICAgICAgICBjYXNlIExldmVsLkwzXzI6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDQ6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDRfMTpcbiAgICAgICAgY2FzZSBMZXZlbC5MNF8yOlxuICAgICAgICBjYXNlIExldmVsLkw1OlxuICAgICAgICBjYXNlIExldmVsLkw1XzE6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDVfMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IGxldmVsX2lkYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVW5yZWNvZ25pemVkIGxldmVsX2lkYy5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcGFyc2VQcm9maWxlTGV2ZWxJZCgpIHwgdW5yZWNvZ25pemVkIGxldmVsX2lkYyBbc3RyOiR7c3RyfSwgbGV2ZWxfaWRjOiR7bGV2ZWxfaWRjfV1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBwcm9maWxlX2lkYy9wcm9maWxlX2lvcCBpbnRvIGEgUHJvZmlsZSBlbnVtLlxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBQcm9maWxlUGF0dGVybnMpIHtcbiAgICAgICAgaWYgKHByb2ZpbGVfaWRjID09PSBwYXR0ZXJuLnByb2ZpbGVfaWRjICYmXG4gICAgICAgICAgICBwYXR0ZXJuLnByb2ZpbGVfaW9wLmlzTWF0Y2gocHJvZmlsZV9pb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb2ZpbGVMZXZlbElkKHBhdHRlcm4ucHJvZmlsZSwgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci53YXJuKGBwYXJzZVByb2ZpbGVMZXZlbElkKCkgfCB1bnJlY29nbml6ZWQgcHJvZmlsZV9pZGMvcHJvZmlsZV9pb3AgY29tYmluYXRpb24gW3N0cjoke3N0cn0sIHByb2ZpbGVfaWRjOiR7cHJvZmlsZV9pZGN9LCBwcm9maWxlX2lvcDoke3Byb2ZpbGVfaW9wfV1gKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5wYXJzZVByb2ZpbGVMZXZlbElkID0gcGFyc2VQcm9maWxlTGV2ZWxJZDtcbi8qKlxuICogUmV0dXJucyBjYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIHRocmVlIGhleCBieXRlcyBvZiB0aGUgcHJvZmlsZVxuICogbGV2ZWwgaWQsIG9yIHJldHVybnMgbm90aGluZyBmb3IgaW52YWxpZCBwcm9maWxlIGxldmVsIGlkcy5cbiAqL1xuZnVuY3Rpb24gcHJvZmlsZUxldmVsSWRUb1N0cmluZyhwcm9maWxlX2xldmVsX2lkKSB7XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBsZXZlbCA9PSAxYi5cbiAgICBpZiAocHJvZmlsZV9sZXZlbF9pZC5sZXZlbCA9PSBMZXZlbC5MMV9iKSB7XG4gICAgICAgIHN3aXRjaCAocHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlKSB7XG4gICAgICAgICAgICBjYXNlIFByb2ZpbGUuQ29uc3RyYWluZWRCYXNlbGluZTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnNDJmMDBiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFByb2ZpbGUuQmFzZWxpbmU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzQyMTAwYic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQcm9maWxlLk1haW46XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzRkMTAwYic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV2ZWwgMV9iIGlzIG5vdCBhbGxvd2VkIGZvciBvdGhlciBwcm9maWxlcy5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcHJvZmlsZUxldmVsSWRUb1N0cmluZygpIHwgTGV2ZWwgMV9iIG5vdCBpcyBhbGxvd2VkIGZvciBwcm9maWxlICR7cHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvZmlsZV9pZGNfaW9wX3N0cmluZztcbiAgICBzd2l0Y2ggKHByb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSkge1xuICAgICAgICBjYXNlIFByb2ZpbGUuQ29uc3RyYWluZWRCYXNlbGluZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzQyZTAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuQmFzZWxpbmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICc0MjAwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLk1haW46XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICc0ZDAwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLkNvbnN0cmFpbmVkSGlnaDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzY0MGMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuSGlnaDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzY0MDAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuUHJlZGljdGl2ZUhpZ2g0NDQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICdmNDAwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcHJvZmlsZUxldmVsSWRUb1N0cmluZygpIHwgdW5yZWNvZ25pemVkIHByb2ZpbGUgJHtwcm9maWxlX2xldmVsX2lkLnByb2ZpbGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxldmVsU3RyID0gKHByb2ZpbGVfbGV2ZWxfaWQubGV2ZWwpLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAobGV2ZWxTdHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGxldmVsU3RyID0gYDAke2xldmVsU3RyfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcm9maWxlX2lkY19pb3Bfc3RyaW5nfSR7bGV2ZWxTdHJ9YDtcbn1cbmV4cG9ydHMucHJvZmlsZUxldmVsSWRUb1N0cmluZyA9IHByb2ZpbGVMZXZlbElkVG9TdHJpbmc7XG4vKipcbiAqIFJldHVybnMgYSBodW1hbiBmcmllbmRseSBuYW1lIGZvciB0aGUgZ2l2ZW4gcHJvZmlsZS5cbiAqL1xuZnVuY3Rpb24gcHJvZmlsZVRvU3RyaW5nKHByb2ZpbGUpIHtcbiAgICBzd2l0Y2ggKHByb2ZpbGUpIHtcbiAgICAgICAgY2FzZSBQcm9maWxlLkNvbnN0cmFpbmVkQmFzZWxpbmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDb25zdHJhaW5lZEJhc2VsaW5lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLkJhc2VsaW5lOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQmFzZWxpbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuTWFpbjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01haW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuQ29uc3RyYWluZWRIaWdoOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ29uc3RyYWluZWRIaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLkhpZ2g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdIaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLlByZWRpY3RpdmVIaWdoNDQ0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnUHJlZGljdGl2ZUhpZ2g0NDQnO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBwcm9maWxlVG9TdHJpbmcoKSB8IHVucmVjb2duaXplZCBwcm9maWxlICR7cHJvZmlsZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucHJvZmlsZVRvU3RyaW5nID0gcHJvZmlsZVRvU3RyaW5nO1xuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4gZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGdpdmVuIGxldmVsLlxuICovXG5mdW5jdGlvbiBsZXZlbFRvU3RyaW5nKGxldmVsKSB7XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlIExldmVsLkwxX2I6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcxYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMV8xOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMS4xJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMV8yOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMS4yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMV8zOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMS4zJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzInO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkwyXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcyLjEnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkwyXzI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcyLjInO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkwzOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDNfMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzMuMSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDNfMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzMuMic7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MNF8xOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnNC4xJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MNF8yOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnNC4yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MNTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzUnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkw1XzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc1LjEnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkw1XzI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc1LjInO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbFRvU3RyaW5nKCkgfCB1bnJlY29nbml6ZWQgbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubGV2ZWxUb1N0cmluZyA9IGxldmVsVG9TdHJpbmc7XG4vKipcbiAqIFBhcnNlIHByb2ZpbGUgbGV2ZWwgaWQgdGhhdCBpcyByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvZiAzIGhleCBieXRlc1xuICogY29udGFpbmVkIGluIGFuIFNEUCBrZXktdmFsdWUgbWFwLiBBIGRlZmF1bHQgcHJvZmlsZSBsZXZlbCBpZCB3aWxsIGJlXG4gKiByZXR1cm5lZCBpZiB0aGUgcHJvZmlsZS1sZXZlbC1pZCBrZXkgaXMgbWlzc2luZy4gTm90aGluZyB3aWxsIGJlIHJldHVybmVkXG4gKiBpZiB0aGUga2V5IGlzIHByZXNlbnQgYnV0IHRoZSBzdHJpbmcgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTZHBQcm9maWxlTGV2ZWxJZChwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWQgPSBwYXJhbXNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICByZXR1cm4gcHJvZmlsZV9sZXZlbF9pZFxuICAgICAgICA/IHBhcnNlUHJvZmlsZUxldmVsSWQocHJvZmlsZV9sZXZlbF9pZClcbiAgICAgICAgOiBEZWZhdWx0UHJvZmlsZUxldmVsSWQ7XG59XG5leHBvcnRzLnBhcnNlU2RwUHJvZmlsZUxldmVsSWQgPSBwYXJzZVNkcFByb2ZpbGVMZXZlbElkO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSB0aGUgc2FtZSBIMjY0IHByb2ZpbGUsIGkuZS4gdGhlIHNhbWVcbiAqIEgyNjQgcHJvZmlsZSAoQmFzZWxpbmUsIEhpZ2gsIGV0YykuXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZVByb2ZpbGUocGFyYW1zMSA9IHt9LCBwYXJhbXMyID0ge30pIHtcbiAgICBjb25zdCBwcm9maWxlX2xldmVsX2lkXzEgPSBwYXJzZVNkcFByb2ZpbGVMZXZlbElkKHBhcmFtczEpO1xuICAgIGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWRfMiA9IHBhcnNlU2RwUHJvZmlsZUxldmVsSWQocGFyYW1zMik7XG4gICAgLy8gQ29tcGFyZSBIMjY0IHByb2ZpbGVzLCBidXQgbm90IGxldmVscy5cbiAgICByZXR1cm4gQm9vbGVhbihwcm9maWxlX2xldmVsX2lkXzEgJiZcbiAgICAgICAgcHJvZmlsZV9sZXZlbF9pZF8yICYmXG4gICAgICAgIHByb2ZpbGVfbGV2ZWxfaWRfMS5wcm9maWxlID09PSBwcm9maWxlX2xldmVsX2lkXzIucHJvZmlsZSk7XG59XG5leHBvcnRzLmlzU2FtZVByb2ZpbGUgPSBpc1NhbWVQcm9maWxlO1xuLyoqXG4gKiBHZW5lcmF0ZSBjb2RlYyBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGFuc3dlciBpbiBhbiBTRFAgbmVnb3RpYXRpb25cbiAqIGJhc2VkIG9uIGxvY2FsIHN1cHBvcnRlZCBwYXJhbWV0ZXJzIGFuZCByZW1vdGUgb2ZmZXJlZCBwYXJhbWV0ZXJzLiBCb3RoXG4gKiBsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zIGFuZCByZW1vdGVfb2ZmZXJlZF9wYXJhbXMgcmVwcmVzZW50IHNlbmRyZWN2IG1lZGlhXG4gKiBkZXNjcmlwdGlvbnMsIGkuZSB0aGV5IGFyZSBhIG1peCBvZiBib3RoIGVuY29kZSBhbmQgZGVjb2RlIGNhcGFiaWxpdGllcy4gSW5cbiAqIHRoZW9yeSwgd2hlbiB0aGUgcHJvZmlsZSBpbiBsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zIHJlcHJlc2VudCBhIHN0cmljdFxuICogc3VwZXJzZXQgb2YgdGhlIHByb2ZpbGUgaW4gcmVtb3RlX29mZmVyZWRfcGFyYW1zLCB3ZSBjb3VsZCBsaW1pdCB0aGUgcHJvZmlsZVxuICogaW4gdGhlIGFuc3dlciB0byB0aGUgcHJvZmlsZSBpbiByZW1vdGVfb2ZmZXJlZF9wYXJhbXMuXG4gKlxuICogSG93ZXZlciwgdG8gc2ltcGxpZnkgdGhlIGNvZGUsIGVhY2ggc3VwcG9ydGVkIEgyNjQgcHJvZmlsZSBzaG91bGQgYmUgbGlzdGVkXG4gKiBleHBsaWNpdGx5IGluIHRoZSBsaXN0IG9mIGxvY2FsIHN1cHBvcnRlZCBjb2RlY3MsIGV2ZW4gaWYgdGhleSBhcmUgcmVkdW5kYW50LlxuICogVGhlbiBlYWNoIGxvY2FsIGNvZGVjIGluIHRoZSBsaXN0IHNob3VsZCBiZSB0ZXN0ZWQgb25lIGF0IGEgdGltZSBhZ2FpbnN0IHRoZVxuICogcmVtb3RlIGNvZGVjLCBhbmQgb25seSB3aGVuIHRoZSBwcm9maWxlcyBhcmUgZXF1YWwgc2hvdWxkIHRoaXMgZnVuY3Rpb24gYmVcbiAqIGNhbGxlZC4gVGhlcmVmb3JlLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gaGFuZGxlIHByb2ZpbGUgaW50ZXJzZWN0aW9uLFxuICogYW5kIHRoZSBwcm9maWxlIG9mIGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMgYW5kIHJlbW90ZV9vZmZlcmVkX3BhcmFtcyBtdXN0IGJlXG4gKiBlcXVhbCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSB1c2VkIHdoZW5cbiAqIG5lZ290aWF0aW5nIGFyZSB0aGUgbGV2ZWwgcGFydCBvZiBwcm9maWxlLWxldmVsLWlkIGFuZFxuICogbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvZmlsZUxldmVsSWRTdHJpbmdGb3JBbnN3ZXIobG9jYWxfc3VwcG9ydGVkX3BhcmFtcyA9IHt9LCByZW1vdGVfb2ZmZXJlZF9wYXJhbXMgPSB7fSkge1xuICAgIC8vIElmIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBwYXJhbXMgZG8gbm90IGNvbnRhaW4gcHJvZmlsZS1sZXZlbC1pZCwgdGhleSBhcmVcbiAgICAvLyBib3RoIHVzaW5nIHRoZSBkZWZhdWx0IHByb2ZpbGUuIEluIHRoaXMgY2FzZSwgZG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICAgIGlmICghbG9jYWxfc3VwcG9ydGVkX3BhcmFtc1sncHJvZmlsZS1sZXZlbC1pZCddICYmXG4gICAgICAgICFyZW1vdGVfb2ZmZXJlZF9wYXJhbXNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSkge1xuICAgICAgICBsb2dnZXIud2FybignZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlcigpIHwgcHJvZmlsZS1sZXZlbC1pZCBtaXNzaW5nIGluIGxvY2FsIGFuZCByZW1vdGUgcGFyYW1zJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIFBhcnNlIHByb2ZpbGUtbGV2ZWwtaWRzLlxuICAgIGNvbnN0IGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQgPSBwYXJzZVNkcFByb2ZpbGVMZXZlbElkKGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMpO1xuICAgIGNvbnN0IHJlbW90ZV9wcm9maWxlX2xldmVsX2lkID0gcGFyc2VTZHBQcm9maWxlTGV2ZWxJZChyZW1vdGVfb2ZmZXJlZF9wYXJhbXMpO1xuICAgIC8vIFRoZSBsb2NhbCBhbmQgcmVtb3RlIGNvZGVjIG11c3QgaGF2ZSB2YWxpZCBhbmQgZXF1YWwgSDI2NCBQcm9maWxlcy5cbiAgICBpZiAoIWxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBsb2NhbF9wcm9maWxlX2xldmVsX2lkJyk7XG4gICAgfVxuICAgIGlmICghcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZCcpO1xuICAgIH1cbiAgICBpZiAobG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlICE9PSByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0gyNjQgUHJvZmlsZSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICAvLyBQYXJzZSBsZXZlbCBpbmZvcm1hdGlvbi5cbiAgICBjb25zdCBsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZCA9IChpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zKSAmJlxuICAgICAgICBpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChyZW1vdGVfb2ZmZXJlZF9wYXJhbXMpKTtcbiAgICBjb25zdCBsb2NhbF9sZXZlbCA9IGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQubGV2ZWw7XG4gICAgY29uc3QgcmVtb3RlX2xldmVsID0gcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQubGV2ZWw7XG4gICAgY29uc3QgbWluX2xldmVsID0gbWluTGV2ZWwobG9jYWxfbGV2ZWwsIHJlbW90ZV9sZXZlbCk7XG4gICAgLy8gRGV0ZXJtaW5lIGFuc3dlciBsZXZlbC4gV2hlbiBsZXZlbCBhc3ltbWV0cnkgaXMgbm90IGFsbG93ZWQsIGxldmVsIHVwZ3JhZGVcbiAgICAvLyBpcyBub3QgYWxsb3dlZCwgaS5lLiwgdGhlIGxldmVsIGluIHRoZSBhbnN3ZXIgbXVzdCBiZSBlcXVhbCB0byBvciBsb3dlclxuICAgIC8vIHRoYW4gdGhlIGxldmVsIGluIHRoZSBvZmZlci5cbiAgICBjb25zdCBhbnN3ZXJfbGV2ZWwgPSBsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZFxuICAgICAgICA/IGxvY2FsX2xldmVsXG4gICAgICAgIDogbWluX2xldmVsO1xuICAgIGxvZ2dlci5kZWJ1ZyhgZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlcigpIHwgcmVzdWx0IFtwcm9maWxlOiR7bG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlfSwgbGV2ZWw6JHthbnN3ZXJfbGV2ZWx9XWApO1xuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHByb2ZpbGUtbGV2ZWwtaWQgZm9yIHRoZSBhbnN3ZXIgcGFyYW1ldGVycy5cbiAgICByZXR1cm4gcHJvZmlsZUxldmVsSWRUb1N0cmluZyhuZXcgUHJvZmlsZUxldmVsSWQobG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlLCBhbnN3ZXJfbGV2ZWwpKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlciA9IGdlbmVyYXRlUHJvZmlsZUxldmVsSWRTdHJpbmdGb3JBbnN3ZXI7XG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgb2YgOCBjaGFyYWN0ZXJzIGludG8gYSBieXRlIHdoZXJlIHRoZSBwb3NpdGlvbnMgY29udGFpbmluZ1xuICogY2hhcmFjdGVyIGMgd2lsbCBoYXZlIHRoZWlyIGJpdCBzZXQuIEZvciBleGFtcGxlLCBjID0gJ3gnLCBzdHIgPSBcIngxeHgwMDAwXCJcbiAqIHdpbGwgcmV0dXJuIDBiMTAxMTAwMDAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVNYXNrU3RyaW5nKGMsIHN0cikge1xuICAgIHJldHVybiAoKE51bWJlcihzdHJbMF0gPT09IGMpIDw8IDcpIHwgKE51bWJlcihzdHJbMV0gPT09IGMpIDw8IDYpIHxcbiAgICAgICAgKE51bWJlcihzdHJbMl0gPT09IGMpIDw8IDUpIHwgKE51bWJlcihzdHJbM10gPT09IGMpIDw8IDQpIHxcbiAgICAgICAgKE51bWJlcihzdHJbNF0gPT09IGMpIDw8IDMpIHwgKE51bWJlcihzdHJbNV0gPT09IGMpIDw8IDIpIHxcbiAgICAgICAgKE51bWJlcihzdHJbNl0gPT09IGMpIDw8IDEpIHwgKE51bWJlcihzdHJbN10gPT09IGMpIDw8IDApKTtcbn1cbi8vIENvbXBhcmUgSDI2NCBsZXZlbHMgYW5kIGhhbmRsZSB0aGUgbGV2ZWwgMWIgY2FzZS5cbmZ1bmN0aW9uIGlzTGVzc0xldmVsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gTGV2ZWwuTDFfYikge1xuICAgICAgICByZXR1cm4gYiAhPT0gTGV2ZWwuTDEgJiYgYiAhPT0gTGV2ZWwuTDFfYjtcbiAgICB9XG4gICAgaWYgKGIgPT09IExldmVsLkwxX2IpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IExldmVsLkwxO1xuICAgIH1cbiAgICByZXR1cm4gYSA8IGI7XG59XG5mdW5jdGlvbiBtaW5MZXZlbChhLCBiKSB7XG4gICAgcmV0dXJuIGlzTGVzc0xldmVsKGEsIGIpID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGxldmVsX2FzeW1tZXRyeV9hbGxvd2VkID0gcGFyYW1zWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddO1xuICAgIHJldHVybiAobGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09IHRydWUgfHxcbiAgICAgICAgbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09IDEgfHxcbiAgICAgICAgbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09ICcxJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uc3VtZXIgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGVuaGFuY2VkRXZlbnRzXzEgPSByZXF1aXJlKFwiLi9lbmhhbmNlZEV2ZW50c1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignQ29uc3VtZXInKTtcbmNsYXNzIENvbnN1bWVyIGV4dGVuZHMgZW5oYW5jZWRFdmVudHNfMS5FbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoeyBpZCwgbG9jYWxJZCwgcHJvZHVjZXJJZCwgcnRwUmVjZWl2ZXIsIHRyYWNrLCBydHBQYXJhbWV0ZXJzLCBhcHBEYXRhLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gT2JzZXJ2ZXIgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IGVuaGFuY2VkRXZlbnRzXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpJyk7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2xvY2FsSWQgPSBsb2NhbElkO1xuICAgICAgICB0aGlzLl9wcm9kdWNlcklkID0gcHJvZHVjZXJJZDtcbiAgICAgICAgdGhpcy5fcnRwUmVjZWl2ZXIgPSBydHBSZWNlaXZlcjtcbiAgICAgICAgdGhpcy5fdHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy5fcnRwUGFyYW1ldGVycyA9IHJ0cFBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9ICF0cmFjay5lbmFibGVkO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YSA/PyB7fTtcbiAgICAgICAgdGhpcy5vblRyYWNrRW5kZWQgPSB0aGlzLm9uVHJhY2tFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRyYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2NhbCBpZC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZWQgUHJvZHVjZXIgaWQuXG4gICAgICovXG4gICAgZ2V0IHByb2R1Y2VySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9kdWNlcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBDb25zdW1lciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVkaWEga2luZC5cbiAgICAgKi9cbiAgICBnZXQga2luZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrLmtpbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZWQgUlRDUnRwUmVjZWl2ZXIuXG4gICAgICovXG4gICAgZ2V0IHJ0cFJlY2VpdmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRwUmVjZWl2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhc3NvY2lhdGVkIHRyYWNrLlxuICAgICAqL1xuICAgIGdldCB0cmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVFAgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXQgcnRwUGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cFBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIENvbnN1bWVyIGlzIHBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEgc2V0dGVyLlxuICAgICAqL1xuICAgIHNldCBhcHBEYXRhKGFwcERhdGEpIHtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGE7XG4gICAgfVxuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIENvbnN1bWVyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVzdHJveVRyYWNrKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYW5zcG9ydENsb3NlZCgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVzdHJveVRyYWNrKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBzdGF0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGdldHN0YXRzJywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyByZWNlaXZpbmcgbWVkaWEuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2UoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3BhdXNlKCkgfCBDb25zdW1lciBjbG9zZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlKCkgfCBDb25zdW1lciBpcyBhbHJlYWR5IHBhdXNlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdAcGF1c2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3BhdXNlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgcmVjZWl2aW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWUoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3Jlc3VtZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lKCkgfCBDb25zdW1lciBpcyBhbHJlYWR5IHJlc3VtZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnQHJlc3VtZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgncmVzdW1lJyk7XG4gICAgfVxuICAgIG9uVHJhY2tFbmRlZCgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFjayBcImVuZGVkXCIgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5zYWZlRW1pdCgndHJhY2tlbmRlZCcpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgndHJhY2tlbmRlZCcpO1xuICAgIH1cbiAgICBoYW5kbGVUcmFjaygpIHtcbiAgICAgICAgdGhpcy5fdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9uVHJhY2tFbmRlZCk7XG4gICAgfVxuICAgIGRlc3Ryb3lUcmFjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vblRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhY2suc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxufVxuZXhwb3J0cy5Db25zdW1lciA9IENvbnN1bWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFDb25zdW1lciA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgZW5oYW5jZWRFdmVudHNfMSA9IHJlcXVpcmUoXCIuL2VuaGFuY2VkRXZlbnRzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGF0YUNvbnN1bWVyJyk7XG5jbGFzcyBEYXRhQ29uc3VtZXIgZXh0ZW5kcyBlbmhhbmNlZEV2ZW50c18xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBkYXRhUHJvZHVjZXJJZCwgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBhcHBEYXRhLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gT2JzZXJ2ZXIgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IGVuaGFuY2VkRXZlbnRzXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpJyk7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2RhdGFQcm9kdWNlcklkID0gZGF0YVByb2R1Y2VySWQ7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsID0gZGF0YUNoYW5uZWw7XG4gICAgICAgIHRoaXMuX3NjdHBTdHJlYW1QYXJhbWV0ZXJzID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhID8/IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFubmVsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDb25zdW1lciBpZC5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCBEYXRhUHJvZHVjZXIgaWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGFQcm9kdWNlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVByb2R1Y2VySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIERhdGFDb25zdW1lciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU0NUUCBzdHJlYW0gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXQgc2N0cFN0cmVhbVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgcmVhZHlTdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLnJlYWR5U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGxhYmVsLlxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBwcm90b2NvbC5cbiAgICAgKi9cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5wcm90b2NvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgYmluYXJ5VHlwZS5cbiAgICAgKi9cbiAgICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmJpbmFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBEYXRhQ2hhbm5lbCBiaW5hcnlUeXBlLlxuICAgICAqL1xuICAgIHNldCBiaW5hcnlUeXBlKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYXBwRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YSBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICB9XG4gICAgZ2V0IG9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgRGF0YUNvbnN1bWVyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYW5zcG9ydENsb3NlZCgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0RhdGFDaGFubmVsIFwib3BlblwiIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdvcGVuJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGVycm9yIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigndW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yRGV0YWlsID09PSAnc2N0cC1mYWlsdXJlJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRGF0YUNoYW5uZWwgU0NUUCBlcnJvciBbc2N0cENhdXNlQ29kZTolc106ICVzJywgZXJyb3Iuc2N0cENhdXNlQ29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFwiZXJyb3JcIiBldmVudDogJW8nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdEYXRhQ2hhbm5lbCBcImNsb3NlXCIgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUNvbnN1bWVyID0gRGF0YUNvbnN1bWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFQcm9kdWNlciA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgZW5oYW5jZWRFdmVudHNfMSA9IHJlcXVpcmUoXCIuL2VuaGFuY2VkRXZlbnRzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdEYXRhUHJvZHVjZXInKTtcbmNsYXNzIERhdGFQcm9kdWNlciBleHRlbmRzIGVuaGFuY2VkRXZlbnRzXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycywgYXBwRGF0YSwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBlbmhhbmNlZEV2ZW50c18xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycyA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YSA/PyB7fTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhUHJvZHVjZXIgaWQuXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIERhdGFQcm9kdWNlciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU0NUUCBzdHJlYW0gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXQgc2N0cFN0cmVhbVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgcmVhZHlTdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLnJlYWR5U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGxhYmVsLlxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBwcm90b2NvbC5cbiAgICAgKi9cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5wcm90b2NvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgYnVmZmVyZWRBbW91bnQuXG4gICAgICovXG4gICAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwuYnVmZmVyZWRBbW91bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkLlxuICAgICAqL1xuICAgIGdldCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgRGF0YUNoYW5uZWwgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQuXG4gICAgICovXG4gICAgc2V0IGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkKGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYXBwRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YSBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICB9XG4gICAgZ2V0IG9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgRGF0YVByb2R1Y2VyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYW5zcG9ydENsb3NlZCgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBkYXRhLlxuICAgICAqL1xuICAgIHNlbmQoZGF0YSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLnNlbmQoZGF0YSk7XG4gICAgfVxuICAgIGhhbmRsZURhdGFDaGFubmVsKCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRGF0YUNoYW5uZWwgXCJvcGVuXCIgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ29wZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgZXJyb3IgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCd1bmtub3duIERhdGFDaGFubmVsIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IuZXJyb3JEZXRhaWwgPT09ICdzY3RwLWZhaWx1cmUnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdEYXRhQ2hhbm5lbCBTQ1RQIGVycm9yIFtzY3RwQ2F1c2VDb2RlOiVzXTogJXMnLCBlcnJvci5zY3RwQ2F1c2VDb2RlLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRGF0YUNoYW5uZWwgXCJlcnJvclwiIGV2ZW50OiAlbycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0RhdGFDaGFubmVsIFwiY2xvc2VcIiBldmVudCcpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIud2FybignRGF0YUNoYW5uZWwgXCJtZXNzYWdlXCIgZXZlbnQgaW4gYSBEYXRhUHJvZHVjZXIsIG1lc3NhZ2UgZGlzY2FyZGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdidWZmZXJlZGFtb3VudGxvdycsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdidWZmZXJlZGFtb3VudGxvdycpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFQcm9kdWNlciA9IERhdGFQcm9kdWNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRldmljZSA9IHZvaWQgMDtcbmV4cG9ydHMuZGV0ZWN0RGV2aWNlID0gZGV0ZWN0RGV2aWNlO1xuY29uc3QgdWFfcGFyc2VyX2pzXzEgPSByZXF1aXJlKFwidWEtcGFyc2VyLWpzXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBlbmhhbmNlZEV2ZW50c18xID0gcmVxdWlyZShcIi4vZW5oYW5jZWRFdmVudHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Y1wiKSk7XG5jb25zdCBUcmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL1RyYW5zcG9ydFwiKTtcbmNvbnN0IENocm9tZTExMV8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lMTExXCIpO1xuY29uc3QgQ2hyb21lNzRfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0Nocm9tZTc0XCIpO1xuY29uc3QgQ2hyb21lNzBfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0Nocm9tZTcwXCIpO1xuY29uc3QgQ2hyb21lNjdfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0Nocm9tZTY3XCIpO1xuY29uc3QgQ2hyb21lNTVfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0Nocm9tZTU1XCIpO1xuY29uc3QgRmlyZWZveDEyMF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvRmlyZWZveDEyMFwiKTtcbmNvbnN0IEZpcmVmb3g2MF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvRmlyZWZveDYwXCIpO1xuY29uc3QgU2FmYXJpMTJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1NhZmFyaTEyXCIpO1xuY29uc3QgU2FmYXJpMTFfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1NhZmFyaTExXCIpO1xuY29uc3QgRWRnZTExXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9FZGdlMTFcIik7XG5jb25zdCBSZWFjdE5hdGl2ZVVuaWZpZWRQbGFuXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuXCIpO1xuY29uc3QgUmVhY3ROYXRpdmVfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1JlYWN0TmF0aXZlXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGV2aWNlJyk7XG5mdW5jdGlvbiBkZXRlY3REZXZpY2UodXNlckFnZW50KSB7XG4gICAgLy8gUmVhY3QtTmF0aXZlLlxuICAgIC8vIE5PVEU6IHJlYWN0LW5hdGl2ZS13ZWJydGMgPj0gMS43NS4wIGlzIHJlcXVpcmVkLlxuICAgIC8vIE5PVEU6IHJlYWN0LW5hdGl2ZS13ZWJydGMgd2l0aCBVbmlmaWVkIFBsYW4gcmVxdWlyZXMgdmVyc2lvbiA+PSAxMDYuMC4wLlxuICAgIGlmICghdXNlckFnZW50ICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZGV0ZWN0RGV2aWNlKCkgfCBSZWFjdC1OYXRpdmUgZGV0ZWN0ZWQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdkZXRlY3REZXZpY2UoKSB8IHVuc3VwcG9ydGVkIHJlYWN0LW5hdGl2ZS13ZWJydGMgd2l0aG91dCBSVENQZWVyQ29ubmVjdGlvbiwgZm9yZ290IHRvIGNhbGwgcmVnaXN0ZXJHbG9iYWxzKCk/Jyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgUlRDUnRwVHJhbnNjZWl2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2RldGVjdERldmljZSgpIHwgUmVhY3ROYXRpdmUgVW5pZmllZFBsYW4gaGFuZGxlciBjaG9zZW4nKTtcbiAgICAgICAgICAgIHJldHVybiAnUmVhY3ROYXRpdmVVbmlmaWVkUGxhbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2RldGVjdERldmljZSgpIHwgUmVhY3ROYXRpdmUgUGxhbkIgaGFuZGxlciBjaG9zZW4nKTtcbiAgICAgICAgICAgIHJldHVybiAnUmVhY3ROYXRpdmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJyb3dzZXIuXG4gICAgZWxzZSBpZiAodXNlckFnZW50IHx8XG4gICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHVzZXJBZ2VudCA/PyAodXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGNvbnN0IHVhUGFyc2VyID0gbmV3IHVhX3BhcnNlcl9qc18xLlVBUGFyc2VyKHVzZXJBZ2VudCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZGV0ZWN0RGV2aWNlKCkgfCBicm93c2VyIGRldGVjdGVkIFt1c2VyQWdlbnQ6JXMsIHBhcnNlZDolb10nLCB1c2VyQWdlbnQsIHVhUGFyc2VyLmdldFJlc3VsdCgpKTtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IHVhUGFyc2VyLmdldEJyb3dzZXIoKTtcbiAgICAgICAgY29uc3QgYnJvd3Nlck5hbWUgPSBicm93c2VyLm5hbWU/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci5tYWpvciA/PyAnMCcpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB1YVBhcnNlci5nZXRFbmdpbmUoKTtcbiAgICAgICAgY29uc3QgZW5naW5lTmFtZSA9IGVuZ2luZS5uYW1lPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBvcyA9IHVhUGFyc2VyLmdldE9TKCk7XG4gICAgICAgIGNvbnN0IG9zTmFtZSA9IG9zLm5hbWU/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG9zVmVyc2lvbiA9IHBhcnNlRmxvYXQob3MudmVyc2lvbiA/PyAnMCcpO1xuICAgICAgICBjb25zdCBkZXZpY2UgPSB1YVBhcnNlci5nZXREZXZpY2UoKTtcbiAgICAgICAgY29uc3QgZGV2aWNlTW9kZWwgPSBkZXZpY2UubW9kZWw/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGlzSU9TID0gb3NOYW1lID09PSAnaW9zJyB8fCBkZXZpY2VNb2RlbCA9PT0gJ2lwYWQnO1xuICAgICAgICBjb25zdCBpc0Nocm9tZSA9IGJyb3dzZXJOYW1lICYmXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2Nocm9tZScsXG4gICAgICAgICAgICAgICAgJ2Nocm9taXVtJyxcbiAgICAgICAgICAgICAgICAnbW9iaWxlIGNocm9tZScsXG4gICAgICAgICAgICAgICAgJ2Nocm9tZSB3ZWJ2aWV3JyxcbiAgICAgICAgICAgICAgICAnY2hyb21lIGhlYWRsZXNzJyxcbiAgICAgICAgICAgIF0uaW5jbHVkZXMoYnJvd3Nlck5hbWUpO1xuICAgICAgICBjb25zdCBpc0ZpcmVmb3ggPSBicm93c2VyTmFtZSAmJlxuICAgICAgICAgICAgWydmaXJlZm94JywgJ21vYmlsZSBmaXJlZm94JywgJ21vYmlsZSBmb2N1cyddLmluY2x1ZGVzKGJyb3dzZXJOYW1lKTtcbiAgICAgICAgY29uc3QgaXNTYWZhcmkgPSBicm93c2VyTmFtZSAmJiBbJ3NhZmFyaScsICdtb2JpbGUgc2FmYXJpJ10uaW5jbHVkZXMoYnJvd3Nlck5hbWUpO1xuICAgICAgICBjb25zdCBpc0VkZ2UgPSBicm93c2VyTmFtZSAmJiBbJ2VkZ2UnXS5pbmNsdWRlcyhicm93c2VyTmFtZSk7XG4gICAgICAgIC8vIENocm9tZSwgQ2hyb21pdW0sIGFuZCBFZGdlLlxuICAgICAgICBpZiAoKGlzQ2hyb21lIHx8IGlzRWRnZSkgJiYgIWlzSU9TICYmIGJyb3dzZXJWZXJzaW9uID49IDExMSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUxMTEnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChpc0Nocm9tZSAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gNzQpIHx8XG4gICAgICAgICAgICAoaXNFZGdlICYmICFpc0lPUyAmJiBicm93c2VyVmVyc2lvbiA+PSA4OCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hyb21lICYmICFpc0lPUyAmJiBicm93c2VyVmVyc2lvbiA+PSA3MCkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaHJvbWUgJiYgIWlzSU9TICYmIGJyb3dzZXJWZXJzaW9uID49IDY3KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTY3JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Nocm9tZSAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gNTUpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNTUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3guXG4gICAgICAgIGVsc2UgaWYgKGlzRmlyZWZveCAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gMTIwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3gxMjAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRmlyZWZveCAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gNjApIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveDYwJztcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IG9uIGlPUyAoc28gU2FmYXJpKS5cbiAgICAgICAgZWxzZSBpZiAoaXNGaXJlZm94ICYmIGlzSU9TICYmIG9zVmVyc2lvbiA+PSAxNC4zKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaTEyJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgd2l0aCBVbmlmaWVkLVBsYW4gc3VwcG9ydCBlbmFibGVkLlxuICAgICAgICBlbHNlIGlmIChpc1NhZmFyaSAmJlxuICAgICAgICAgICAgYnJvd3NlclZlcnNpb24gPj0gMTIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBSVENSdHBUcmFuc2NlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIFJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudERpcmVjdGlvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaTEyJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgd2l0aCBQbGFiLUIgc3VwcG9ydC5cbiAgICAgICAgZWxzZSBpZiAoaXNTYWZhcmkgJiYgYnJvd3NlclZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpMTEnO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9sZCBFZGdlIHdpdGggT1JUQyBzdXBwb3J0LlxuICAgICAgICBlbHNlIGlmIChpc0VkZ2UgJiYgIWlzSU9TICYmIGJyb3dzZXJWZXJzaW9uID49IDExICYmIGJyb3dzZXJWZXJzaW9uIDw9IDE4KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0VkZ2UxMSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVzdCBlZmZvcnQgZm9yIFdlYktpdCBiYXNlZCBicm93c2VycyBpbiBpT1MuXG4gICAgICAgIGVsc2UgaWYgKGVuZ2luZU5hbWUgPT09ICd3ZWJraXQnICYmXG4gICAgICAgICAgICBpc0lPUyAmJlxuICAgICAgICAgICAgdHlwZW9mIFJUQ1J0cFRyYW5zY2VpdmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjdXJyZW50RGlyZWN0aW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpMTInO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlc3QgZWZmb3J0IGZvciBDaHJvbWl1bSBiYXNlZCBicm93c2Vycy5cbiAgICAgICAgZWxzZSBpZiAoZW5naW5lTmFtZSA9PT0gJ2JsaW5rJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcmVnZXhwLWV4ZWNcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC8oPzooPzpDaHJvbWV8Q2hyb21pdW0pKVsgL10oXFx3KykvaSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gTnVtYmVyKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA+PSAxMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUxMTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2ZXJzaW9uID49IDc0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2ZXJzaW9uID49IDcwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2ZXJzaW9uID49IDY3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNjcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU1NSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUxMTEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVuc3VwcG9ydGVkIGJyb3dzZXIuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2RldGVjdERldmljZSgpIHwgYnJvd3NlciBub3Qgc3VwcG9ydGVkIFtuYW1lOiVzLCB2ZXJzaW9uOiVzXScsIGJyb3dzZXJOYW1lLCBicm93c2VyVmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVua25vd24gZGV2aWNlLlxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignZGV0ZWN0RGV2aWNlKCkgfCB1bmtub3duIGRldmljZScpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIERldmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IERldmljZSB0byBjb25uZWN0IHRvIG1lZGlhc291cCBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtVbnN1cHBvcnRlZEVycm9yfSBpZiBkZXZpY2UgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGhhbmRsZXJOYW1lLCBoYW5kbGVyRmFjdG9yeSB9ID0ge30pIHtcbiAgICAgICAgLy8gTG9hZGVkIGZsYWcuXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgZW5oYW5jZWRFdmVudHNfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgaWYgKGhhbmRsZXJOYW1lICYmIGhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqdXN0IG9uZSBvZiBoYW5kbGVyTmFtZSBvciBoYW5kbGVySW50ZXJmYWNlIGNhbiBiZSBnaXZlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBoYW5kbGVyRmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSB8IGhhbmRsZXIgZ2l2ZW46ICVzJywgaGFuZGxlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlck5hbWUgPSBkZXRlY3REZXZpY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpIHwgZGV0ZWN0ZWQgaGFuZGxlcjogJXMnLCBoYW5kbGVyTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignZGV2aWNlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ2hyb21lMTExJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTExMV8xLkNocm9tZTExMS5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdDaHJvbWU3NCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBDaHJvbWU3NF8xLkNocm9tZTc0LmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ0Nocm9tZTcwJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTcwXzEuQ2hyb21lNzAuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnQ2hyb21lNjcnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gQ2hyb21lNjdfMS5DaHJvbWU2Ny5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdDaHJvbWU1NSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBDaHJvbWU1NV8xLkNocm9tZTU1LmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ0ZpcmVmb3gxMjAnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gRmlyZWZveDEyMF8xLkZpcmVmb3gxMjAuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRmlyZWZveDYwJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IEZpcmVmb3g2MF8xLkZpcmVmb3g2MC5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdTYWZhcmkxMic6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBTYWZhcmkxMl8xLlNhZmFyaTEyLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ1NhZmFyaTExJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFNhZmFyaTExXzEuU2FmYXJpMTEuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRWRnZTExJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IEVkZ2UxMV8xLkVkZ2UxMS5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdSZWFjdE5hdGl2ZVVuaWZpZWRQbGFuJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFJlYWN0TmF0aXZlVW5pZmllZFBsYW5fMS5SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWN0TmF0aXZlJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFJlYWN0TmF0aXZlXzEuUmVhY3ROYXRpdmUuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bmtub3duIGhhbmRsZXJOYW1lIFwiJHtoYW5kbGVyTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhbCBoYW5kbGVyIHRvIGdldCBpdHMgbmFtZS5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXJGYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJOYW1lID0gaGFuZGxlci5uYW1lO1xuICAgICAgICBoYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgdmlkZW86IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zY3RwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgUlRDIGhhbmRsZXIgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgRGV2aWNlIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVFAgY2FwYWJpbGl0aWVzIG9mIHRoZSBEZXZpY2UgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldCBydHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ25vdCBsb2FkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU0NUUCBjYXBhYmlsaXRpZXMgb2YgdGhlIERldmljZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldCBzY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjdHBDYXBhYmlsaXRpZXM7XG4gICAgfVxuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBEZXZpY2UuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZCh7IHJvdXRlclJ0cENhcGFiaWxpdGllcywgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSBbcm91dGVyUnRwQ2FwYWJpbGl0aWVzOiVvXScsIHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgIC8vIFRlbXBvcmFsIGhhbmRsZXIgdG8gZ2V0IGl0cyBjYXBhYmlsaXRpZXMuXG4gICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignYWxyZWFkeSBsb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsb25lIGdpdmVuIHJvdXRlciBSVFAgY2FwYWJpbGl0aWVzIHRvIG5vdCBtb2RpZnkgaW5wdXQgZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFJvdXRlclJ0cENhcGFiaWxpdGllcyA9IHV0aWxzLmNsb25lKHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVSdHBDYXBhYmlsaXRpZXMoY2xvbmVkUm91dGVyUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyRmFjdG9yeSgpO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gYXdhaXQgaGFuZGxlci5nZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHwgZ290IG5hdGl2ZSBSVFAgY2FwYWJpbGl0aWVzOiVvJywgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIC8vIENsb25lIG9idGFpbmVkIG5hdGl2ZSBSVFAgY2FwYWJpbGl0aWVzIHRvIG5vdCBtb2RpZnkgaW5wdXQgZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IGNsb25lZE5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHV0aWxzLmNsb25lKG5hdGl2ZVJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVSdHBDYXBhYmlsaXRpZXMoY2xvbmVkTmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIC8vIEdldCBleHRlbmRlZCBSVFAgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMgPSBvcnRjLmdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKGNsb25lZE5hdGl2ZVJ0cENhcGFiaWxpdGllcywgY2xvbmVkUm91dGVyUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHwgZ290IGV4dGVuZGVkIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHdlIGNhbiBwcm9kdWNlIGF1ZGlvL3ZpZGVvLlxuICAgICAgICAgICAgdGhpcy5fY2FuUHJvZHVjZUJ5S2luZC5hdWRpbyA9IG9ydGMuY2FuU2VuZCgnYXVkaW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kLnZpZGVvID0gb3J0Yy5jYW5TZW5kKCd2aWRlbycsIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIG91ciByZWNlaXZpbmcgUlRQIGNhcGFiaWxpdGllcyBmb3IgcmVjZWl2aW5nIG1lZGlhLlxuICAgICAgICAgICAgdGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcyA9IG9ydGMuZ2V0UmVjdlJ0cENhcGFiaWxpdGllcyh0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVSdHBDYXBhYmlsaXRpZXModGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSB8IGdvdCByZWNlaXZpbmcgUlRQIGNhcGFiaWxpdGllczolbycsIHRoaXMuX3JlY3ZSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgb3VyIFNDVFAgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgdGhpcy5fc2N0cENhcGFiaWxpdGllcyA9IGF3YWl0IGhhbmRsZXIuZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgfCBnb3QgbmF0aXZlIFNDVFAgY2FwYWJpbGl0aWVzOiVvJywgdGhpcy5fc2N0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVTY3RwQ2FwYWJpbGl0aWVzKHRoaXMuX3NjdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgc3VjY2VlZGVkJyk7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaGFuZGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHdlIGNhbiBwcm9kdWNlIGF1ZGlvL3ZpZGVvLlxuICAgICAqXG4gICAgICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBsb2FkZWQuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiB3cm9uZyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgY2FuUHJvZHVjZShraW5kKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ25vdCBsb2FkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChraW5kICE9PSAnYXVkaW8nICYmIGtpbmQgIT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQga2luZCBcIiR7a2luZH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kW2tpbmRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVHJhbnNwb3J0IGZvciBzZW5kaW5nIG1lZGlhLlxuICAgICAqXG4gICAgICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBsb2FkZWQuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiB3cm9uZyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgY3JlYXRlU2VuZFRyYW5zcG9ydCh7IGlkLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBhcHBEYXRhLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlU2VuZFRyYW5zcG9ydCgpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kJyxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzOiBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnM6IGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnM6IHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5LFxuICAgICAgICAgICAgYWRkaXRpb25hbFNldHRpbmdzOiBhZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzOiBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgYXBwRGF0YTogYXBwRGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUcmFuc3BvcnQgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGNyZWF0ZVJlY3ZUcmFuc3BvcnQoeyBpZCwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgYXBwRGF0YSwgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NyZWF0ZVJlY3ZUcmFuc3BvcnQoKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAncmVjdicsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzOiBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzOiBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzOiBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5nczogYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50czogcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGFwcERhdGE6IGFwcERhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUcmFuc3BvcnQoeyBkaXJlY3Rpb24sIGlkLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBhcHBEYXRhLCB9KSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ25vdCBsb2FkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGljZVBhcmFtZXRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGljZVBhcmFtZXRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpY2VDYW5kaWRhdGVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpY2VDYW5kaWRhdGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGR0bHNQYXJhbWV0ZXJzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBkdGxzUGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjdHBQYXJhbWV0ZXJzICYmIHR5cGVvZiBzY3RwUGFyYW1ldGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dyb25nIHNjdHBQYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lmIGdpdmVuLCBhcHBEYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFRyYW5zcG9ydC5cbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydF8xLlRyYW5zcG9ydCh7XG4gICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3ksXG4gICAgICAgICAgICBhZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgIGhhbmRsZXJGYWN0b3J5OiB0aGlzLl9oYW5kbGVyRmFjdG9yeSxcbiAgICAgICAgICAgIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgIGNhblByb2R1Y2VCeUtpbmQ6IHRoaXMuX2NhblByb2R1Y2VCeUtpbmQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnbmV3dHJhbnNwb3J0JywgdHJhbnNwb3J0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG59XG5leHBvcnRzLkRldmljZSA9IERldmljZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBBUFBfTkFNRSA9ICdtZWRpYXNvdXAtY2xpZW50JztcbmNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0FQUF9OQU1FfTpXQVJOOiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtBUFBfTkFNRX06RVJST1I6JHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKEFQUF9OQU1FKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtBUFBfTkFNRX06V0FSTmApO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtBUFBfTkFNRX06RVJST1JgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIHRoaXMuX2RlYnVnLmxvZyA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH1cbiAgICBnZXQgZGVidWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1ZztcbiAgICB9XG4gICAgZ2V0IHdhcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXJuO1xuICAgIH1cbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9kdWNlciA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgZW5oYW5jZWRFdmVudHNfMSA9IHJlcXVpcmUoXCIuL2VuaGFuY2VkRXZlbnRzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdQcm9kdWNlcicpO1xuY2xhc3MgUHJvZHVjZXIgZXh0ZW5kcyBlbmhhbmNlZEV2ZW50c18xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBsb2NhbElkLCBydHBTZW5kZXIsIHRyYWNrLCBydHBQYXJhbWV0ZXJzLCBzdG9wVHJhY2tzLCBkaXNhYmxlVHJhY2tPblBhdXNlLCB6ZXJvUnRwT25QYXVzZSwgYXBwRGF0YSwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBlbmhhbmNlZEV2ZW50c18xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9sb2NhbElkID0gbG9jYWxJZDtcbiAgICAgICAgdGhpcy5fcnRwU2VuZGVyID0gcnRwU2VuZGVyO1xuICAgICAgICB0aGlzLl90cmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLl9raW5kID0gdHJhY2sua2luZDtcbiAgICAgICAgdGhpcy5fcnRwUGFyYW1ldGVycyA9IHJ0cFBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGRpc2FibGVUcmFja09uUGF1c2UgPyAhdHJhY2suZW5hYmxlZCA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9tYXhTcGF0aWFsTGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N0b3BUcmFja3MgPSBzdG9wVHJhY2tzO1xuICAgICAgICB0aGlzLl9kaXNhYmxlVHJhY2tPblBhdXNlID0gZGlzYWJsZVRyYWNrT25QYXVzZTtcbiAgICAgICAgdGhpcy5femVyb1J0cE9uUGF1c2UgPSB6ZXJvUnRwT25QYXVzZTtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGEgPz8ge307XG4gICAgICAgIHRoaXMub25UcmFja0VuZGVkID0gdGhpcy5vblRyYWNrRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gTk9URTogTWlub3IgaXNzdWUuIElmIHplcm9SdHBPblBhdXNlIGlzIHRydWUsIHdlIGNhbm5vdCBlbWl0IHRoZVxuICAgICAgICAvLyAnQHJlcGxhY2V0cmFjaycgZXZlbnQgaGVyZSwgc28gUlRDUnRwU2VuZGVyLnRyYWNrIHdvbid0IGJlIG51bGwuXG4gICAgICAgIHRoaXMuaGFuZGxlVHJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXIgaWQuXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvY2FsIGlkLlxuICAgICAqL1xuICAgIGdldCBsb2NhbElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgUHJvZHVjZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lZGlhIGtpbmQuXG4gICAgICovXG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9raW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIFJUQ1J0cFNlbmRlci5cbiAgICAgKi9cbiAgICBnZXQgcnRwU2VuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRwU2VuZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYXNzb2NpYXRlZCB0cmFjay5cbiAgICAgKi9cbiAgICBnZXQgdHJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUlRQIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0IHJ0cFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydHBQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBQcm9kdWNlciBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF4IHNwYXRpYWwgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBtYXhTcGF0aWFsTGF5ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhTcGF0aWFsTGF5ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYXBwRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YSBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICB9XG4gICAgZ2V0IG9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgUHJvZHVjZXIuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZXN0cm95VHJhY2soKTtcbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCB3YXMgY2xvc2VkLlxuICAgICAqL1xuICAgIHRyYW5zcG9ydENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhbnNwb3J0Q2xvc2VkKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZXN0cm95VHJhY2soKTtcbiAgICAgICAgdGhpcy5zYWZlRW1pdCgndHJhbnNwb3J0Y2xvc2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBzdGF0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGdldHN0YXRzJywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyBzZW5kaW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdwYXVzZSgpIHwgUHJvZHVjZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrICYmIHRoaXMuX2Rpc2FibGVUcmFja09uUGF1c2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5femVyb1J0cE9uUGF1c2UpIHtcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAcGF1c2UnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgncGF1c2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBzZW5kaW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWUoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3Jlc3VtZSgpIHwgUHJvZHVjZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl90cmFjayAmJiB0aGlzLl9kaXNhYmxlVHJhY2tPblBhdXNlKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5femVyb1J0cE9uUGF1c2UpIHtcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAcmVzdW1lJywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3Jlc3VtZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCB0cmFjayB3aXRoIGEgbmV3IG9uZSBvciBudWxsLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcGxhY2VUcmFjayh7IHRyYWNrLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW3RyYWNrOiVvXScsIHRyYWNrKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGJlIGRvbmUgaGVyZS4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIGNoYW5jZSB0byBzdG9wIHRoZSBnaXZlblxuICAgICAgICAgICAgLy8gdHJhY2suXG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdGhpcy5fc3RvcFRyYWNrcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhY2sgJiYgdHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCd0cmFjayBlbmRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhpcyBpcyB0aGUgc2FtZSB0cmFjayBhcyB0aGUgY3VycmVudCBoYW5kbGVkIG9uZS5cbiAgICAgICAgaWYgKHRyYWNrID09PSB0aGlzLl90cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSB8IHNhbWUgdHJhY2ssIGlnbm9yZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAcmVwbGFjZXRyYWNrJywgdHJhY2ssIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEZXN0cm95IHRoZSBwcmV2aW91cyB0cmFjay5cbiAgICAgICAgdGhpcy5kZXN0cm95VHJhY2soKTtcbiAgICAgICAgLy8gU2V0IHRoZSBuZXcgdHJhY2suXG4gICAgICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG4gICAgICAgIC8vIElmIHRoaXMgUHJvZHVjZXIgd2FzIHBhdXNlZC9yZXN1bWVkIGFuZCB0aGUgc3RhdGUgb2YgdGhlIG5ld1xuICAgICAgICAvLyB0cmFjayBkb2VzIG5vdCBtYXRjaCwgZml4IGl0LlxuICAgICAgICBpZiAodGhpcy5fdHJhY2sgJiYgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGVmZmVjdGl2ZSB0cmFjay5cbiAgICAgICAgdGhpcy5oYW5kbGVUcmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aWRlbyBtYXggc3BhdGlhbCBsYXllciB0byBiZSBzZW50LlxuICAgICAqL1xuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9raW5kICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGEgdmlkZW8gUHJvZHVjZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3BhdGlhbExheWVyICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzcGF0aWFsTGF5ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BhdGlhbExheWVyID09PSB0aGlzLl9tYXhTcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAc2V0bWF4c3BhdGlhbGxheWVyJywgc3BhdGlhbExheWVyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLl9tYXhTcGF0aWFsTGF5ZXIgPSBzcGF0aWFsTGF5ZXI7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAc2V0cnRwZW5jb2RpbmdwYXJhbWV0ZXJzJywgcGFyYW1zLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25UcmFja0VuZGVkKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYWNrIFwiZW5kZWRcIiBldmVudCcpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFja2VuZGVkJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCd0cmFja2VuZGVkJyk7XG4gICAgfVxuICAgIGhhbmRsZVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9uVHJhY2tFbmRlZCk7XG4gICAgfVxuICAgIGRlc3Ryb3lUcmFjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub25UcmFja0VuZGVkKTtcbiAgICAgICAgICAgIC8vIEp1c3Qgc3RvcCB0aGUgdHJhY2sgdW5sZXNzIHRoZSBhcHAgc2V0IHN0b3BUcmFja3M6IGZhbHNlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BUcmFja3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5leHBvcnRzLlByb2R1Y2VyID0gUHJvZHVjZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhlIFJUUCBjYXBhYmlsaXRpZXMgZGVmaW5lIHdoYXQgbWVkaWFzb3VwIG9yIGFuIGVuZHBvaW50IGNhbiByZWNlaXZlIGF0XG4gKiBtZWRpYSBsZXZlbC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc3BvcnQgPSB2b2lkIDA7XG5jb25zdCBhd2FpdHF1ZXVlXzEgPSByZXF1aXJlKFwiYXdhaXRxdWV1ZVwiKTtcbmNvbnN0IHF1ZXVlX21pY3JvdGFza18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJxdWV1ZS1taWNyb3Rhc2tcIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBlbmhhbmNlZEV2ZW50c18xID0gcmVxdWlyZShcIi4vZW5oYW5jZWRFdmVudHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Y1wiKSk7XG5jb25zdCBQcm9kdWNlcl8xID0gcmVxdWlyZShcIi4vUHJvZHVjZXJcIik7XG5jb25zdCBDb25zdW1lcl8xID0gcmVxdWlyZShcIi4vQ29uc3VtZXJcIik7XG5jb25zdCBEYXRhUHJvZHVjZXJfMSA9IHJlcXVpcmUoXCIuL0RhdGFQcm9kdWNlclwiKTtcbmNvbnN0IERhdGFDb25zdW1lcl8xID0gcmVxdWlyZShcIi4vRGF0YUNvbnN1bWVyXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignVHJhbnNwb3J0Jyk7XG5jbGFzcyBDb25zdW1lckNyZWF0aW9uVGFzayB7XG4gICAgY29uc3RydWN0b3IoY29uc3VtZXJPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZXJPcHRpb25zID0gY29uc3VtZXJPcHRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIGVuaGFuY2VkRXZlbnRzXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgZGlyZWN0aW9uLCBpZCwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgYXBwRGF0YSwgaGFuZGxlckZhY3RvcnksIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBjYW5Qcm9kdWNlQnlLaW5kLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVHJhbnNwb3J0IElDRSBnYXRoZXJpbmcgc3RhdGUuXG4gICAgICAgIHRoaXMuX2ljZUdhdGhlcmluZ1N0YXRlID0gJ25ldyc7XG4gICAgICAgIC8vIFRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSAnbmV3JztcbiAgICAgICAgLy8gTWFwIG9mIFByb2R1Y2VycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9wcm9kdWNlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcCBvZiBDb25zdW1lcnMgaW5kZXhlZCBieSBpZC5cbiAgICAgICAgdGhpcy5fY29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBNYXAgb2YgRGF0YVByb2R1Y2VycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBNYXAgb2YgRGF0YUNvbnN1bWVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9kYXRhQ29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIHRoZSBDb25zdW1lciBmb3IgUlRQIHByb2JhdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9wcm9iYXRvckNvbnN1bWVyQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBBd2FpdFF1ZXVlIGluc3RhbmNlIHRvIG1ha2UgYXN5bmMgdGFza3MgaGFwcGVuIHNlcXVlbnRpYWxseS5cbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZSA9IG5ldyBhd2FpdHF1ZXVlXzEuQXdhaXRRdWV1ZSgpO1xuICAgICAgICAvLyBDb25zdW1lciBjcmVhdGlvbiB0YXNrcyBhd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzID0gW107XG4gICAgICAgIC8vIENvbnN1bWVyIGNyZWF0aW9uIGluIHByb2dyZXNzIGZsYWcuXG4gICAgICAgIHRoaXMuX2NvbnN1bWVyQ3JlYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIC8vIENvbnN1bWVycyBwZW5kaW5nIHRvIGJlIHBhdXNlZC5cbiAgICAgICAgdGhpcy5fcGVuZGluZ1BhdXNlQ29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBDb25zdW1lciBwYXVzZSBpbiBwcm9ncmVzcyBmbGFnLlxuICAgICAgICB0aGlzLl9jb25zdW1lclBhdXNlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAvLyBDb25zdW1lcnMgcGVuZGluZyB0byBiZSByZXN1bWVkLlxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVzdW1lQ29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBDb25zdW1lciByZXN1bWUgaW4gcHJvZ3Jlc3MgZmxhZy5cbiAgICAgICAgdGhpcy5fY29uc3VtZXJSZXN1bWVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIC8vIENvbnN1bWVycyBwZW5kaW5nIHRvIGJlIGNsb3NlZC5cbiAgICAgICAgdGhpcy5fcGVuZGluZ0Nsb3NlQ29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBDb25zdW1lciBjbG9zZSBpbiBwcm9ncmVzcyBmbGFnLlxuICAgICAgICB0aGlzLl9jb25zdW1lckNsb3NlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgZW5oYW5jZWRFdmVudHNfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgW2lkOiVzLCBkaXJlY3Rpb246JXNdJywgaWQsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMgPSBleHRlbmRlZFJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgdGhpcy5fY2FuUHJvZHVjZUJ5S2luZCA9IGNhblByb2R1Y2VCeUtpbmQ7XG4gICAgICAgIHRoaXMuX21heFNjdHBNZXNzYWdlU2l6ZSA9IHNjdHBQYXJhbWV0ZXJzXG4gICAgICAgICAgICA/IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vIENsb25lIGFuZCBzYW5pdGl6ZSBhZGRpdGlvbmFsU2V0dGluZ3MuXG4gICAgICAgIGNvbnN0IGNsb25lZEFkZGl0aW9uYWxTZXR0aW5ncyA9IHV0aWxzLmNsb25lKGFkZGl0aW9uYWxTZXR0aW5ncykgPz8ge307XG4gICAgICAgIGRlbGV0ZSBjbG9uZWRBZGRpdGlvbmFsU2V0dGluZ3MuaWNlU2VydmVycztcbiAgICAgICAgZGVsZXRlIGNsb25lZEFkZGl0aW9uYWxTZXR0aW5ncy5pY2VUcmFuc3BvcnRQb2xpY3k7XG4gICAgICAgIGRlbGV0ZSBjbG9uZWRBZGRpdGlvbmFsU2V0dGluZ3MuYnVuZGxlUG9saWN5O1xuICAgICAgICBkZWxldGUgY2xvbmVkQWRkaXRpb25hbFNldHRpbmdzLnJ0Y3BNdXhQb2xpY3k7XG4gICAgICAgIGRlbGV0ZSBjbG9uZWRBZGRpdGlvbmFsU2V0dGluZ3Muc2RwU2VtYW50aWNzO1xuICAgICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlckZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlci5ydW4oe1xuICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlU2VydmVycyxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5nczogY2xvbmVkQWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGEgPz8ge307XG4gICAgICAgIHRoaXMuaGFuZGxlSGFuZGxlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgaWQuXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFRyYW5zcG9ydCBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVEMgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElDRSBnYXRoZXJpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGljZUdhdGhlcmluZ1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWNlR2F0aGVyaW5nU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3Rpb24gc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgIH1cbiAgICBnZXQgb2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIFRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBTdG9wIHRoZSBBd2FpdFF1ZXVlLlxuICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlLnN0b3AoKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGhhbmRsZXIuXG4gICAgICAgIHRoaXMuX2hhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgLy8gQ2hhbmdlIGNvbm5lY3Rpb24gc3RhdGUgdG8gJ2Nsb3NlZCcgc2luY2UgdGhlIGhhbmRsZXIgbWF5IG5vdCBlbWl0XG4gICAgICAgIC8vICdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJyBldmVudC5cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgIC8vIENsb3NlIGFsbCBQcm9kdWNlcnMuXG4gICAgICAgIGZvciAoY29uc3QgcHJvZHVjZXIgb2YgdGhpcy5fcHJvZHVjZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBwcm9kdWNlci50cmFuc3BvcnRDbG9zZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9kdWNlcnMuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIENvbnN1bWVycy5cbiAgICAgICAgZm9yIChjb25zdCBjb25zdW1lciBvZiB0aGlzLl9jb25zdW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN1bWVyLnRyYW5zcG9ydENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnN1bWVycy5jbGVhcigpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgRGF0YVByb2R1Y2Vycy5cbiAgICAgICAgZm9yIChjb25zdCBkYXRhUHJvZHVjZXIgb2YgdGhpcy5fZGF0YVByb2R1Y2Vycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZGF0YVByb2R1Y2VyLnRyYW5zcG9ydENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGFQcm9kdWNlcnMuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIERhdGFDb25zdW1lcnMuXG4gICAgICAgIGZvciAoY29uc3QgZGF0YUNvbnN1bWVyIG9mIHRoaXMuX2RhdGFDb25zdW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGRhdGFDb25zdW1lci50cmFuc3BvcnRDbG9zZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhQ29uc3VtZXJzLmNsZWFyKCk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXNzb2NpYXRlZCBUcmFuc3BvcnQgKFJUQ1BlZXJDb25uZWN0aW9uKSBzdGF0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSVENTdGF0c1JlcG9ydH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRUcmFuc3BvcnRTdGF0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0IElDRSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3RhcnRJY2UoeyBpY2VQYXJhbWV0ZXJzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlUGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9oYW5kbGVyLnJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycyksICd0cmFuc3BvcnQucmVzdGFydEljZSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBJQ0Ugc2VydmVycy5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKHsgaWNlU2VydmVycywgfSA9IHt9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaWNlU2VydmVycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlU2VydmVycycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB0aGlzLl9oYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycyksICd0cmFuc3BvcnQudXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFByb2R1Y2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2R1Y2UoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCBzdG9wVHJhY2tzID0gdHJ1ZSwgZGlzYWJsZVRyYWNrT25QYXVzZSA9IHRydWUsIHplcm9SdHBPblBhdXNlID0gZmFsc2UsIG9uUnRwU2VuZGVyLCBhcHBEYXRhID0ge30sIH0gPSB7fSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Byb2R1Y2UoKSBbdHJhY2s6JW9dJywgdHJhY2spO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyB0cmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGEgc2VuZGluZyBUcmFuc3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fY2FuUHJvZHVjZUJ5S2luZFt0cmFjay5raW5kXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoYGNhbm5vdCBwcm9kdWNlICR7dHJhY2sua2luZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ3RyYWNrIGVuZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdjb25uZWN0JykgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwiY29ubmVjdFwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdwcm9kdWNlJykgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwicHJvZHVjZVwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lmIGdpdmVuLCBhcHBEYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gKHRoaXMuX2F3YWl0UXVldWVcbiAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkRW5jb2RpbmdzO1xuICAgICAgICAgICAgaWYgKGVuY29kaW5ncyAmJiAhQXJyYXkuaXNBcnJheShlbmNvZGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmNvZGluZ3MgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5ncyA9IGVuY29kaW5ncy5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFbmNvZGluZyA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5kdHggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLmR0eCA9IGVuY29kaW5nLmR0eDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5tYXhCaXRyYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcubWF4RnJhbWVyYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLmFkYXB0aXZlUHRpbWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLmFkYXB0aXZlUHRpbWUgPSBlbmNvZGluZy5hZGFwdGl2ZVB0aW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcucHJpb3JpdHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcucHJpb3JpdHkgPSBlbmNvZGluZy5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLm5ldHdvcmtQcmlvcml0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFbmNvZGluZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbG9jYWxJZCwgcnRwUGFyYW1ldGVycywgcnRwU2VuZGVyIH0gPSBhd2FpdCB0aGlzLl9oYW5kbGVyLnNlbmQoe1xuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIGVuY29kaW5nczogbm9ybWFsaXplZEVuY29kaW5ncyxcbiAgICAgICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICAgICAgb25SdHBTZW5kZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgcnRwUGFyYW1ldGVycydzIG1pc3NpbmcgZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdwcm9kdWNlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBEYXRhLFxuICAgICAgICAgICAgICAgICAgICB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y2VyID0gbmV3IFByb2R1Y2VyXzEuUHJvZHVjZXIoe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgcnRwU2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFRyYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVRyYWNrT25QYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgemVyb1J0cE9uUGF1c2UsXG4gICAgICAgICAgICAgICAgICAgIGFwcERhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZHVjZXJzLnNldChwcm9kdWNlci5pZCwgcHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvZHVjZXIocHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ25ld3Byb2R1Y2VyJywgcHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuc3RvcFNlbmRpbmcobG9jYWxJZCkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5wcm9kdWNlKCknKVxuICAgICAgICAgICAgLy8gVGhpcyBjYXRjaCBpcyBuZWVkZWQgdG8gc3RvcCB0aGUgZ2l2ZW4gdHJhY2sgaWYgdGhlIGNvbW1hbmQgYWJvdmVcbiAgICAgICAgICAgIC8vIGZhaWxlZCBkdWUgdG8gY2xvc2VkIFRyYW5zcG9ydC5cbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIENvbnN1bWVyIHRvIGNvbnN1bWUgYSByZW1vdGUgUHJvZHVjZXIuXG4gICAgICovXG4gICAgYXN5bmMgY29uc3VtZSh7IGlkLCBwcm9kdWNlcklkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgb25SdHBSZWNlaXZlciwgYXBwRGF0YSA9IHt9LCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3VtZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgYSByZWNlaXZpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcm9kdWNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwcm9kdWNlcklkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2luZCAhPT0gJ2F1ZGlvJyAmJiBraW5kICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGtpbmQgJyR7a2luZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdjb25uZWN0JykgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwiY29ubmVjdFwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lmIGdpdmVuLCBhcHBEYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvbmUgZ2l2ZW4gUlRQIHBhcmFtZXRlcnMgdG8gbm90IG1vZGlmeSBpbnB1dCBkYXRhLlxuICAgICAgICBjb25zdCBjbG9uZWRSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUocnRwUGFyYW1ldGVycyk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGV2aWNlIGNhbiBjb25zdW1lIGl0LlxuICAgICAgICBjb25zdCBjYW5Db25zdW1lID0gb3J0Yy5jYW5SZWNlaXZlKGNsb25lZFJ0cFBhcmFtZXRlcnMsIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgaWYgKCFjYW5Db25zdW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignY2Fubm90IGNvbnN1bWUgdGhpcyBQcm9kdWNlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnN1bWVyQ3JlYXRpb25UYXNrID0gbmV3IENvbnN1bWVyQ3JlYXRpb25UYXNrKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcHJvZHVjZXJJZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBjbG9uZWRSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBvblJ0cFJlY2VpdmVyLFxuICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBDb25zdW1lciBjcmVhdGlvbiB0YXNrLlxuICAgICAgICB0aGlzLl9wZW5kaW5nQ29uc3VtZXJUYXNrcy5wdXNoKGNvbnN1bWVyQ3JlYXRpb25UYXNrKTtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gQ29uc3VtZXIgY3JlYXRpb24gaW4gcHJvZ3Jlc3MsIGNyZWF0ZSBpdCBub3cuXG4gICAgICAgICgwLCBxdWV1ZV9taWNyb3Rhc2tfMS5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN1bWVyQ3JlYXRpb25JblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5jcmVhdGVQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29uc3VtZXJDcmVhdGlvblRhc2sucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRGF0YVByb2R1Y2VyXG4gICAgICovXG4gICAgYXN5bmMgcHJvZHVjZURhdGEoeyBvcmRlcmVkID0gdHJ1ZSwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCA9ICcnLCBwcm90b2NvbCA9ICcnLCBhcHBEYXRhID0ge30sIH0gPSB7fSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Byb2R1Y2VEYXRhKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHNlbmRpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX21heFNjdHBNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ1NDVFAgbm90IGVuYWJsZWQgYnkgcmVtb3RlIFRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnY29ubmVjdCcpID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcImNvbm5lY3RcIiBsaXN0ZW5lciBzZXQgaW50byB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgncHJvZHVjZWRhdGEnKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJwcm9kdWNlZGF0YVwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lmIGdpdmVuLCBhcHBEYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFBhY2tldExpZmVUaW1lIHx8IG1heFJldHJhbnNtaXRzKSB7XG4gICAgICAgICAgICBvcmRlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH0gPSBhd2FpdCB0aGlzLl9oYW5kbGVyLnNlbmREYXRhQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgc2N0cFN0cmVhbVBhcmFtZXRlcnMncyBtaXNzaW5nIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdwcm9kdWNlZGF0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2N0cFN0cmVhbVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgICAgICB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhUHJvZHVjZXIgPSBuZXcgRGF0YVByb2R1Y2VyXzEuRGF0YVByb2R1Y2VyKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhcHBEYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLnNldChkYXRhUHJvZHVjZXIuaWQsIGRhdGFQcm9kdWNlcik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFQcm9kdWNlcihkYXRhUHJvZHVjZXIpO1xuICAgICAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCduZXdkYXRhcHJvZHVjZXInLCBkYXRhUHJvZHVjZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQcm9kdWNlcjtcbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5wcm9kdWNlRGF0YSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERhdGFDb25zdW1lclxuICAgICAqL1xuICAgIGFzeW5jIGNvbnN1bWVEYXRhKHsgaWQsIGRhdGFQcm9kdWNlcklkLCBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwgPSAnJywgcHJvdG9jb2wgPSAnJywgYXBwRGF0YSA9IHt9LCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3VtZURhdGEoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGEgcmVjZWl2aW5nIFRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9tYXhTY3RwTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdTQ1RQIG5vdCBlbmFibGVkIGJ5IHJlbW90ZSBUcmFuc3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGFQcm9kdWNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBkYXRhUHJvZHVjZXJJZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnY29ubmVjdCcpID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcImNvbm5lY3RcIiBsaXN0ZW5lciBzZXQgaW50byB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwcERhdGEgJiYgdHlwZW9mIGFwcERhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb25lIGdpdmVuIFNDVFAgc3RyZWFtIHBhcmFtZXRlcnMgdG8gbm90IG1vZGlmeSBpbnB1dCBkYXRhLlxuICAgICAgICBjb25zdCBjbG9uZWRTY3RwU3RyZWFtUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIG9ydGMudmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycyhjbG9uZWRTY3RwU3RyZWFtUGFyYW1ldGVycyk7XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFDaGFubmVsIH0gPSBhd2FpdCB0aGlzLl9oYW5kbGVyLnJlY2VpdmVEYXRhQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgc2N0cFN0cmVhbVBhcmFtZXRlcnM6IGNsb25lZFNjdHBTdHJlYW1QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ29uc3VtZXIgPSBuZXcgRGF0YUNvbnN1bWVyXzEuRGF0YUNvbnN1bWVyKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvZHVjZXJJZCxcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVyczogY2xvbmVkU2N0cFN0cmVhbVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNvbnN1bWVycy5zZXQoZGF0YUNvbnN1bWVyLmlkLCBkYXRhQ29uc3VtZXIpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ29uc3VtZXIoZGF0YUNvbnN1bWVyKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnbmV3ZGF0YWNvbnN1bWVyJywgZGF0YUNvbnN1bWVyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhQ29uc3VtZXI7XG4gICAgICAgIH0sICd0cmFuc3BvcnQuY29uc3VtZURhdGEoKScpO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBndWFyYW50ZWVkIHRvIG5ldmVyIHRocm93LlxuICAgIGFzeW5jIGNyZWF0ZVBlbmRpbmdDb25zdW1lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVyQ3JlYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlUGVuZGluZ0NvbnN1bWVycygpIHwgdGhlcmUgaXMgbm8gQ29uc3VtZXIgdG8gYmUgY3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdDb25zdW1lclRhc2tzID0gWy4uLnRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzXTtcbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgQ29uc3VtZXIgdGFza3MuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ29uc3VtZXJUYXNrcyA9IFtdO1xuICAgICAgICAgICAgLy8gVmlkZW8gQ29uc3VtZXIgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBwcm9iYXRvci5cbiAgICAgICAgICAgIGxldCB2aWRlb0NvbnN1bWVyRm9yUHJvYmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBGaWxsIG9wdGlvbnMgbGlzdC5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgcGVuZGluZ0NvbnN1bWVyVGFza3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgb25SdHBSZWNlaXZlciB9ID0gdGFzay5jb25zdW1lck9wdGlvbnM7XG4gICAgICAgICAgICAgICAgb3B0aW9uc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICAgICAgb25SdHBSZWNlaXZlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZShvcHRpb25zTGlzdCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmVzdWx0cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBwZW5kaW5nQ29uc3VtZXJUYXNrc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHByb2R1Y2VySWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIGFwcERhdGEgfSA9IHRhc2suY29uc3VtZXJPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxvY2FsSWQsIHJ0cFJlY2VpdmVyLCB0cmFjayB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdW1lciA9IG5ldyBDb25zdW1lcl8xLkNvbnN1bWVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWNlcklkOiBwcm9kdWNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBEYXRhOiBhcHBEYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJzLnNldChjb25zdW1lci5pZCwgY29uc3VtZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNvbnN1bWVyKGNvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdmlkZW8gQ29uc3VtZXIgYW5kIHRoZSBDb25zdW1lciBmb3IgUlRQIHByb2JhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbm90IHlldCBiZWVuIGNyZWF0ZWQsIGl0J3MgdGltZSB0byBjcmVhdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvYmF0b3JDb25zdW1lckNyZWF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF2aWRlb0NvbnN1bWVyRm9yUHJvYmF0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvQ29uc3VtZXJGb3JQcm9iYXRvciA9IGNvbnN1bWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCduZXdjb25zdW1lcicsIGNvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKGNvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgcGVuZGluZ0NvbnN1bWVyVGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIFJUUCBwcm9iYXRpb24gbXVzdCBiZSBoYW5kbGVkLCBkbyBpdCBub3cuXG4gICAgICAgICAgICBpZiAodmlkZW9Db25zdW1lckZvclByb2JhdG9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvYmF0b3JSdHBQYXJhbWV0ZXJzID0gb3J0Yy5nZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyh2aWRlb0NvbnN1bWVyRm9yUHJvYmF0b3IucnRwUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZShbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tJZDogJ3Byb2JhdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHByb2JhdG9yUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NyZWF0ZVBlbmRpbmdDb25zdW1lcnMoKSB8IENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uIGNyZWF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvYmF0b3JDb25zdW1lckNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdjcmVhdGVQZW5kaW5nQ29uc3VtZXJzKCkgfCBmYWlsZWQgdG8gY3JlYXRlIENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uOiVvJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5jcmVhdGVQZW5kaW5nQ29uc3VtZXJzKCknKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJDcmVhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwZW5kaW5nIENvbnN1bWVyIHRhc2tzLCBlbnF1ZXVlIHRoZWlyIGNyZWF0aW9uLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuY3JlYXRlUGVuZGluZ0NvbnN1bWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gTk9URTogV2Ugb25seSBnZXQgaGVyZSB3aGVuIHRoZSBhd2FpdCBxdWV1ZSBpcyBjbG9zZWQuXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICB9XG4gICAgcGF1c2VQZW5kaW5nQ29uc3VtZXJzKCkge1xuICAgICAgICB0aGlzLl9jb25zdW1lclBhdXNlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2F3YWl0UXVldWVcbiAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VQZW5kaW5nQ29uc3VtZXJzKCkgfCB0aGVyZSBpcyBubyBDb25zdW1lciB0byBiZSBwYXVzZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nUGF1c2VDb25zdW1lcnMgPSBBcnJheS5mcm9tKHRoaXMuX3BlbmRpbmdQYXVzZUNvbnN1bWVycy52YWx1ZXMoKSk7XG4gICAgICAgICAgICAvLyBDbGVhciBwZW5kaW5nIHBhdXNlIENvbnN1bWVyIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQYXVzZUNvbnN1bWVycy5jbGVhcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbElkcyA9IHBlbmRpbmdQYXVzZUNvbnN1bWVycy5tYXAoY29uc3VtZXIgPT4gY29uc3VtZXIubG9jYWxJZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlci5wYXVzZVJlY2VpdmluZyhsb2NhbElkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3BhdXNlUGVuZGluZ0NvbnN1bWVycygpIHwgZmFpbGVkIHRvIHBhdXNlIENvbnN1bWVyczonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICd0cmFuc3BvcnQucGF1c2VQZW5kaW5nQ29uc3VtZXJzJylcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVyUGF1c2VJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcGVuZGluZyBDb25zdW1lcnMgdG8gYmUgcGF1c2VkLCBkbyBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlUGVuZGluZ0NvbnN1bWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gTk9URTogV2Ugb25seSBnZXQgaGVyZSB3aGVuIHRoZSBhd2FpdCBxdWV1ZSBpcyBjbG9zZWQuXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICB9XG4gICAgcmVzdW1lUGVuZGluZ0NvbnN1bWVycygpIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZXJSZXN1bWVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUGVuZGluZ0NvbnN1bWVycygpIHwgdGhlcmUgaXMgbm8gQ29uc3VtZXIgdG8gYmUgcmVzdW1lZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdSZXN1bWVDb25zdW1lcnMgPSBBcnJheS5mcm9tKHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMudmFsdWVzKCkpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgcGVuZGluZyByZXN1bWUgQ29uc3VtZXIgbWFwLlxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc3VtZUNvbnN1bWVycy5jbGVhcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbElkcyA9IHBlbmRpbmdSZXN1bWVDb25zdW1lcnMubWFwKGNvbnN1bWVyID0+IGNvbnN1bWVyLmxvY2FsSWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZXIucmVzdW1lUmVjZWl2aW5nKGxvY2FsSWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcigncmVzdW1lUGVuZGluZ0NvbnN1bWVycygpIHwgZmFpbGVkIHRvIHJlc3VtZSBDb25zdW1lcnM6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAndHJhbnNwb3J0LnJlc3VtZVBlbmRpbmdDb25zdW1lcnMnKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJSZXN1bWVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcGVuZGluZyBDb25zdW1lciB0byBiZSByZXN1bWVkLCBkbyBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzdW1lQ29uc3VtZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWVQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBOT1RFOiBXZSBvbmx5IGdldCBoZXJlIHdoZW4gdGhlIGF3YWl0IHF1ZXVlIGlzIGNsb3NlZC5cbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBjbG9zZVBlbmRpbmdDb25zdW1lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVyQ2xvc2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDbG9zZUNvbnN1bWVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZVBlbmRpbmdDb25zdW1lcnMoKSB8IHRoZXJlIGlzIG5vIENvbnN1bWVyIHRvIGJlIGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdDbG9zZUNvbnN1bWVycyA9IEFycmF5LmZyb20odGhpcy5fcGVuZGluZ0Nsb3NlQ29uc3VtZXJzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgY2xvc2UgQ29uc3VtZXIgbWFwLlxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0Nsb3NlQ29uc3VtZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZXIuc3RvcFJlY2VpdmluZyhwZW5kaW5nQ2xvc2VDb25zdW1lcnMubWFwKGNvbnN1bWVyID0+IGNvbnN1bWVyLmxvY2FsSWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignY2xvc2VQZW5kaW5nQ29uc3VtZXJzKCkgfCBmYWlsZWQgdG8gY2xvc2UgQ29uc3VtZXJzOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5jbG9zZVBlbmRpbmdDb25zdW1lcnMnKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJDbG9zZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwZW5kaW5nIENvbnN1bWVyIHRvIGJlIHJlc3VtZWQsIGRvIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDbG9zZUNvbnN1bWVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBOT1RFOiBXZSBvbmx5IGdldCBoZXJlIHdoZW4gdGhlIGF3YWl0IHF1ZXVlIGlzIGNsb3NlZC5cbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBoYW5kbGVIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgaGFuZGxlci5vbignQGNvbm5lY3QnLCAoeyBkdGxzUGFyYW1ldGVycyB9LCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIGVycmJhY2sobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlci5vbignQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgKGljZUdhdGhlcmluZ1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaWNlR2F0aGVyaW5nU3RhdGUgPT09IHRoaXMuX2ljZUdhdGhlcmluZ1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdJQ0UgZ2F0aGVyaW5nIHN0YXRlIGNoYW5nZWQgdG8gJXMnLCBpY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9pY2VHYXRoZXJpbmdTdGF0ZSA9IGljZUdhdGhlcmluZ1N0YXRlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIGljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIub24oJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSB0aGlzLl9jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2Nvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAlcycsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSBjb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVQcm9kdWNlcihwcm9kdWNlcikge1xuICAgICAgICBwcm9kdWNlci5vbignQGNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvZHVjZXJzLmRlbGV0ZShwcm9kdWNlci5pZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX2hhbmRsZXIuc3RvcFNlbmRpbmcocHJvZHVjZXIubG9jYWxJZCksICdwcm9kdWNlciBAY2xvc2UgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGxvZ2dlci53YXJuKCdwcm9kdWNlci5jbG9zZSgpIGZhaWxlZDolbycsIGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQHBhdXNlJywgKGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlXG4gICAgICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5faGFuZGxlci5wYXVzZVNlbmRpbmcocHJvZHVjZXIubG9jYWxJZCksICdwcm9kdWNlciBAcGF1c2UgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAcmVzdW1lJywgKGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlXG4gICAgICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5faGFuZGxlci5yZXN1bWVTZW5kaW5nKHByb2R1Y2VyLmxvY2FsSWQpLCAncHJvZHVjZXIgQHJlc3VtZSBldmVudCcpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvZHVjZXIub24oJ0ByZXBsYWNldHJhY2snLCAodHJhY2ssIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlXG4gICAgICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5faGFuZGxlci5yZXBsYWNlVHJhY2socHJvZHVjZXIubG9jYWxJZCwgdHJhY2spLCAncHJvZHVjZXIgQHJlcGxhY2V0cmFjayBldmVudCcpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvZHVjZXIub24oJ0BzZXRtYXhzcGF0aWFsbGF5ZXInLCAoc3BhdGlhbExheWVyLCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX2hhbmRsZXIuc2V0TWF4U3BhdGlhbExheWVyKHByb2R1Y2VyLmxvY2FsSWQsIHNwYXRpYWxMYXllciksICdwcm9kdWNlciBAc2V0bWF4c3BhdGlhbGxheWVyIGV2ZW50JylcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQHNldHJ0cGVuY29kaW5ncGFyYW1ldGVycycsIChwYXJhbXMsIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlXG4gICAgICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5faGFuZGxlci5zZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMocHJvZHVjZXIubG9jYWxJZCwgcGFyYW1zKSwgJ3Byb2R1Y2VyIEBzZXRydHBlbmNvZGluZ3BhcmFtZXRlcnMgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAZ2V0c3RhdHMnLCAoY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyYmFjayhuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJcbiAgICAgICAgICAgICAgICAuZ2V0U2VuZGVyU3RhdHMocHJvZHVjZXIubG9jYWxJZClcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVDb25zdW1lcihjb25zdW1lcikge1xuICAgICAgICBjb25zdW1lci5vbignQGNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgQ29uc3VtZXIgaW50byB0aGUgY2xvc2UgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDbG9zZUNvbnN1bWVycy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVyKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIENvbnN1bWVyIGNsb3NlIGluIHByb2dyZXNzLCBkbyBpdCBub3cuXG4gICAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZXJDbG9zZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBlbmRpbmdDb25zdW1lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVyLm9uKCdAcGF1c2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBDb25zdW1lciBpcyBwZW5kaW5nIHRvIGJlIHJlc3VtZWQsIHJlbW92ZSBmcm9tIHBlbmRpbmcgcmVzdW1lIGxpc3QuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1Jlc3VtZUNvbnN1bWVycy5oYXMoY29uc3VtZXIuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc3VtZUNvbnN1bWVycy5kZWxldGUoY29uc3VtZXIuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIENvbnN1bWVyIGludG8gdGhlIHBlbmRpbmcgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQYXVzZUNvbnN1bWVycy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVyKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIENvbnN1bWVyIHBhdXNlIGluIHByb2dyZXNzLCBkbyBpdCBub3cuXG4gICAgICAgICAgICAoMCwgcXVldWVfbWljcm90YXNrXzEuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZXJQYXVzZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lci5vbignQHJlc3VtZScsICgpID0+IHtcbiAgICAgICAgICAgIC8vIElmIENvbnN1bWVyIGlzIHBlbmRpbmcgdG8gYmUgcGF1c2VkLCByZW1vdmUgZnJvbSBwZW5kaW5nIHBhdXNlIGxpc3QuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1BhdXNlQ29uc3VtZXJzLmhhcyhjb25zdW1lci5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBDb25zdW1lciBpbnRvIHRoZSBwZW5kaW5nIGxpc3QuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzdW1lQ29uc3VtZXJzLnNldChjb25zdW1lci5pZCwgY29uc3VtZXIpO1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gQ29uc3VtZXIgcmVzdW1lIGluIHByb2dyZXNzLCBkbyBpdCBub3cuXG4gICAgICAgICAgICAoMCwgcXVldWVfbWljcm90YXNrXzEuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZXJSZXN1bWVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZVBlbmRpbmdDb25zdW1lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVyLm9uKCdAZ2V0c3RhdHMnLCAoY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyYmFjayhuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJcbiAgICAgICAgICAgICAgICAuZ2V0UmVjZWl2ZXJTdGF0cyhjb25zdW1lci5sb2NhbElkKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZURhdGFQcm9kdWNlcihkYXRhUHJvZHVjZXIpIHtcbiAgICAgICAgZGF0YVByb2R1Y2VyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLmRlbGV0ZShkYXRhUHJvZHVjZXIuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRGF0YUNvbnN1bWVyKGRhdGFDb25zdW1lcikge1xuICAgICAgICBkYXRhQ29uc3VtZXIub24oJ0BjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDb25zdW1lcnMuZGVsZXRlKGRhdGFDb25zdW1lci5pZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVuaGFuY2VkRXZlbnRFbWl0dGVyID0gdm9pZCAwO1xuY29uc3QgbnBtX2V2ZW50c19wYWNrYWdlXzEgPSByZXF1aXJlKFwibnBtLWV2ZW50cy1wYWNrYWdlXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBlbmhhbmNlZEV2ZW50RW1pdHRlckxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5jbGFzcyBFbmhhbmNlZEV2ZW50RW1pdHRlciBleHRlbmRzIG5wbV9ldmVudHNfcGFja2FnZV8xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBhZGRpdGlvbiB0byB0aGUgRXZlbnRFbWl0dGVyIEFQSS5cbiAgICAgKi9cbiAgICBzYWZlRW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50TmFtZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlbmhhbmNlZEV2ZW50RW1pdHRlckxvZ2dlci5lcnJvcignc2FmZUVtaXQoKSB8IGV2ZW50IGxpc3RlbmVyIHRocmV3IGFuIGVycm9yIFtldmVudE5hbWU6JXNdOiVvJywgZXZlbnROYW1lLCBlcnJvcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN1cGVyLmVtaXQoJ2xpc3RlbmVyZXJyb3InLCBldmVudE5hbWUsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaXQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihzdXBlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIH1cbiAgICByYXdMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yYXdMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLkVuaGFuY2VkRXZlbnRFbWl0dGVyID0gRW5oYW5jZWRFdmVudEVtaXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFN0YXRlRXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkRXJyb3IgPSB2b2lkIDA7XG4vKipcbiAqIEVycm9yIGluZGljYXRpbmcgbm90IHN1cHBvcnQgZm9yIHNvbWV0aGluZy5cbiAqL1xuY2xhc3MgVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdXBwb3J0ZWRFcnJvcic7XG4gICAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVW5zdXBwb3J0ZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VbnN1cHBvcnRlZEVycm9yID0gVW5zdXBwb3J0ZWRFcnJvcjtcbi8qKlxuICogRXJyb3IgcHJvZHVjZWQgd2hlbiBjYWxsaW5nIGEgbWV0aG9kIGluIGFuIGludmFsaWQgc3RhdGUuXG4gKi9cbmNsYXNzIEludmFsaWRTdGF0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkU3RhdGVFcnJvcic7XG4gICAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgICAgICAgLy8gSnVzdCBpbiBWOC5cbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRTdGF0ZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWUxMTEgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3VuaWZpZWRQbGFuVXRpbHNcIikpO1xuY29uc3Qgb3J0Y1V0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29ydGMvdXRpbHNcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IHNjYWxhYmlsaXR5TW9kZXNfMSA9IHJlcXVpcmUoXCIuLi9zY2FsYWJpbGl0eU1vZGVzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignQ2hyb21lMTExJyk7XG5jb25zdCBOQU1FID0gJ0Nocm9tZTExMSc7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWUxMTEgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgQ2hyb21lMTExKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE1hcCBvZiBSVENUcmFuc2NlaXZlcnMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbGlid2VicnRjIHN1cHBvcnRzIE5BQ0sgZm9yIE9QVVMgYnV0IGRvZXNuJ3QgYW5ub3VuY2UgaXQuXG4gICAgICAgICAgICBvcnRjVXRpbHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzID8/IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgPz8gJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdydW4oKSB8IHBjLmNvbm5lY3Rpb25TdGF0ZSBub3Qgc3VwcG9ydGVkLCB1c2luZyBwYy5pY2VDb25uZWN0aW9uU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgb25SdHBTZW5kZXIsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFNldCByaWQgYW5kIHZlcmlmeSBzY2FsYWJpbGl0eU1vZGUgaW4gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgICAgIC8vIE5PVEU6IEV2ZW4gaWYgV2ViUlRDIGFsbG93cyBkaWZmZXJlbnQgc2NhbGFiaWxpdHlNb2RlIChkaWZmZXJlbnQgbnVtYmVyXG4gICAgICAgICAgICAvLyBvZiB0ZW1wb3JhbCBsYXllcnMpIHBlciBzaW11bGNhc3Qgc3RyZWFtLCB3ZSBuZWVkIHRoYXQgdGhvc2UgYXJlIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBpbiBhbGwgdGhlbSwgc28gbGV0J3MgcGljayB1cCB0aGUgaGlnaGVzdCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHNjYWxhYmlsaXR5TW9kZSBpcyBub3QgZ2l2ZW4sIENocm9tZSB3aWxsIHVzZSBMMVQzLlxuICAgICAgICAgICAgbGV0IG1heFRlbXBvcmFsTGF5ZXJzID0gMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcG9yYWxMYXllcnMgPSBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlKShlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpLnRlbXBvcmFsTGF5ZXJzXG4gICAgICAgICAgICAgICAgICAgIDogMztcbiAgICAgICAgICAgICAgICBpZiAodGVtcG9yYWxMYXllcnMgPiBtYXhUZW1wb3JhbExheWVycykge1xuICAgICAgICAgICAgICAgICAgICBtYXhUZW1wb3JhbExheWVycyA9IHRlbXBvcmFsTGF5ZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucmlkID0gYHIke2lkeH1gO1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGBMMVQke21heFRlbXBvcmFsTGF5ZXJzfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiBlbmNvZGluZ3MsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25SdHBTZW5kZXIpIHtcbiAgICAgICAgICAgIG9uUnRwU2VuZGVyKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VuY29kaW5nc1swXSwgZW5jb2RpbmdzWzBdKTtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbkNsb3NlZCA9IHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBpZiAobWVkaWFTZWN0aW9uQ2xvc2VkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgIH1cbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVTZW5kaW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwTG9jYWxJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgPz8gU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICAgICAgbWFwTG9jYWxJZC5zZXQodHJhY2tJZCwgbG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCA/PyBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBvblJ0cFJlY2VpdmVyIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9uUnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uUnRwUmVjZWl2ZXIodHJhbnNjZWl2ZXIucmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgICAgICB0cmFjazogdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wYXVzZU1lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXN1bWVSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdyZWN2b25seSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVzdW1lUmVjZWl2aW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ21ldGhvZCBjYWxsZWQgaW4gYSBjbG9zZWQgaGFuZGxlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DaHJvbWUxMTEgPSBDaHJvbWUxMTE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWU1NSA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwUGxhbkJVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignQ2hyb21lNTUnKTtcbmNvbnN0IE5BTUUgPSAnQ2hyb21lNTUnO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgQ2hyb21lNTUgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgQ2hyb21lNTUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2Ygc2VuZGluZyBNZWRpYVN0cmVhbVRyYWNrcyBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2sgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoe1xuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7XG4gICAgICAgICAgICAgICAgc2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNUyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3J1bigpJyk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwID0gbmV3IFJlbW90ZVNkcF8xLlJlbW90ZVNkcCh7XG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFuQjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyA/PyBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5ID8/ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3J1bigpIHwgcGMuY29ubmVjdGlvblN0YXRlIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIHBjLmljZUNvbm5lY3Rpb25TdGF0ZScpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzZW5kKCkgfCBjb2RlYyBzZWxlY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiAlcyBoYW5kbGVyJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkU3RyZWFtKHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nICYmIGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAndmlkZW8nKTtcbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09IHRyYWNrLmtpbmQpO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gc2RwUGxhbkJVdGlscy5nZXRSdHBFbmNvZGluZ3Moe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0byBlYWNoXG4gICAgICAgIC8vIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5zZXQobG9jYWxJZCwgdHJhY2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2sgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHRyYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCcgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLCAvLyBOT1RFOiBPbGQgc3BlYy5cbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkID8/IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhY2tJZDtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUlkID0gb3B0aW9ucy5zdHJlYW1JZCA/PyBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWU7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRSZW1vdGVTdHJlYW1zKClcbiAgICAgICAgICAgICAgICAuZmluZCgocykgPT4gcy5pZCA9PT0gc3RyZWFtSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0VHJhY2tCeUlkKGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5zZXQobG9jYWxJZCwgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goeyBsb2NhbElkLCB0cmFjayB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0gPSB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZ2V0KGxvY2FsSWQpID8/IHt9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGxhbkJTdG9wUmVjZWl2aW5nKHtcbiAgICAgICAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLCAvLyBOT1RFOiBPbGQgc3BlYy5cbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbih7IG9sZERhdGFDaGFubmVsU3BlYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNocm9tZTU1ID0gQ2hyb21lNTU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWU2NyA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwUGxhbkJVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignQ2hyb21lNjcnKTtcbmNvbnN0IE5BTUUgPSAnQ2hyb21lNjcnO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgQ2hyb21lNjcgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgQ2hyb21lNjcoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwU2VuZGVyIGluZGV4ZWQgYnkgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoe1xuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7XG4gICAgICAgICAgICAgICAgc2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNUyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3J1bigpJyk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwID0gbmV3IFJlbW90ZVNkcF8xLlJlbW90ZVNkcCh7XG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFuQjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyA/PyBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5ID8/ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3J1bigpIHwgcGMuY29ubmVjdGlvblN0YXRlIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIHBjLmljZUNvbm5lY3Rpb25TdGF0ZScpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzZW5kKCkgfCBjb2RlYyBzZWxlY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiAlcyBoYW5kbGVyJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nICYmIGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAndmlkZW8nKTtcbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09IHRyYWNrLmtpbmQpO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gc2RwUGxhbkJVdGlscy5nZXRSdHBFbmNvZGluZ3Moe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0byBlYWNoXG4gICAgICAgIC8vIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgIC5nZXRTZW5kZXJzKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLnNldChsb2NhbElkLCBydHBTZW5kZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2socnRwU2VuZGVyKTtcbiAgICAgICAgaWYgKHJ0cFNlbmRlci50cmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayhydHBTZW5kZXIudHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuICAgICAgICAgICAgLy8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2VuZFN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFNlbmRpbmcoKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVHJhY2sgPSBydHBTZW5kZXIudHJhY2s7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmIChvbGRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayhvbGRUcmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgdHJhY2sgdG8gdGhlIGxvY2FsIHN0cmVhbS5cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydHBTZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLCAvLyBOT1RFOiBPbGQgc3BlYy5cbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkID8/IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgocikgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghcnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBSZWNlaXZlciBub3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgIHRyYWNrOiBydHBSZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgPz8ge307XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoe1xuICAgICAgICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgcnRwUmVjZWl2ZXIgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgPz8ge307XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwUmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsIC8vIE5PVEU6IE9sZCBzcGVjLlxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKHsgb2xkRGF0YUNoYW5uZWxTcGVjOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0LCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNjcgPSBDaHJvbWU2NztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNocm9tZTcwID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBVbmlmaWVkUGxhblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTcwJyk7XG5jb25zdCBOQU1FID0gJ0Nocm9tZTcwJztcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIENocm9tZTcwIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IENocm9tZTcwKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDVHJhbnNjZWl2ZXJzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gTkFNRTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzID8/IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgPz8gJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbklkeCA9IHRoaXMuX3JlbW90ZVNkcC5nZXROZXh0TWVkaWFTZWN0aW9uSWR4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgICAgIHN0cmVhbXM6IFt0aGlzLl9zZW5kU3RyZWFtXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCcpO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVttZWRpYVNlY3Rpb25JZHguaWR4XTtcbiAgICAgICAgICAgIHNkcFVuaWZpZWRQbGFuVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFZQOSB3aXRoIFNWQy5cbiAgICAgICAgbGV0IGhhY2tWcDlTdmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gKDAsIHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZSkoKGVuY29kaW5ncyA/PyBbe31dKVswXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBpZiAoZW5jb2RpbmdzICYmXG4gICAgICAgICAgICBlbmNvZGluZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBsYXllcnMuc3BhdGlhbExheWVycyA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA5Jykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0IGZvciBWUDkgU1ZDJyk7XG4gICAgICAgICAgICBoYWNrVnA5U3ZjID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBsYXllcnMuc3BhdGlhbExheWVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIElmIGVuY29kaW5ncyBhcmUgZ2l2ZW4sIGFwcGx5IHRoZW0gbm93LlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGFwcGx5aW5nIGdpdmVuIGVuY29kaW5ncycpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCAocGFyYW1ldGVycy5lbmNvZGluZ3MgPz8gW10pLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZEVuY29kaW5nID0gZW5jb2RpbmdzW2lkeF07XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYnV0IGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICBpZiAoIWRlc2lyZWRFbmNvZGluZykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IE9iamVjdC5hc3NpZ24oZW5jb2RpbmcsIGRlc2lyZWRFbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhbnNjZWl2ZXIubWlkO1xuICAgICAgICAvLyBTZXQgTUlELlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5taWQgPSBsb2NhbElkO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVttZWRpYVNlY3Rpb25JZHguaWR4XTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPSBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayBmb3IgVlA5IFNWQy5cbiAgICAgICAgaWYgKGhhY2tWcDlTdmMpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IFtzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBvciBIMjY0IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvXG4gICAgICAgIC8vIGVhY2ggZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4JyB8fFxuICAgICAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vaDI2NCcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25DbG9zZWQgPSB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgaWYgKG1lZGlhU2VjdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsIC8vIE5PVEU6IE9sZCBzcGVjLlxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwTG9jYWxJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgPz8gU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICAgICAgbWFwTG9jYWxJZC5zZXQodHJhY2tJZCwgbG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCA/PyBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgIHRyYWNrOiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcjogdHJhbnNjZWl2ZXIucmVjZWl2ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSwgLy8gTk9URTogT2xkIHNwZWMuXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNocm9tZTcwID0gQ2hyb21lNzA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWU3NCA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKSk7XG5jb25zdCBvcnRjVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Yy91dGlsc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3Qgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4uL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdDaHJvbWU3NCcpO1xuY29uc3QgTkFNRSA9ICdDaHJvbWU3NCc7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU3NCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU3NCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBNYXAgb2YgUlRDVHJhbnNjZWl2ZXJzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gTkFNRTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGxpYndlYnJ0YyBzdXBwb3J0cyBOQUNLIGZvciBPUFVTIGJ1dCBkb2Vzbid0IGFubm91bmNlIGl0LlxuICAgICAgICAgICAgb3J0Y1V0aWxzLmFkZE5hY2tTdXBwcG9ydEZvck9wdXMobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyA/PyBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5ID8/ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucmlkID0gYHIke2lkeH1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwLmdldE5leHRNZWRpYVNlY3Rpb25JZHgoKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknLFxuICAgICAgICAgICAgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dLFxuICAgICAgICAgICAgc2VuZEVuY29kaW5nczogZW5jb2RpbmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBWUDkgd2l0aCBTVkMuXG4gICAgICAgIGxldCBoYWNrVnA5U3ZjID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxheWVycyA9ICgwLCBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2UpKChlbmNvZGluZ3MgPz8gW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJlxuICAgICAgICAgICAgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgbGF5ZXJzLnNwYXRpYWxMYXllcnMgPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOScpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCBmb3IgVlA5IFNWQycpO1xuICAgICAgICAgICAgaGFja1ZwOVN2YyA9IHRydWU7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogbGF5ZXJzLnNwYXRpYWxMYXllcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhbnNjZWl2ZXIubWlkO1xuICAgICAgICAvLyBTZXQgTUlELlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5taWQgPSBsb2NhbElkO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVttZWRpYVNlY3Rpb25JZHguaWR4XTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPSBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGlmIG5vIGVuY29kaW5ncyBhcmUgZ2l2ZW4uXG4gICAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBhbmQgY29tcGxldGUgdGhlbSB3aXRoIGdpdmVuXG4gICAgICAgIC8vIG9uZSBpZiBqdXN0IGEgc2luZ2xlIGVuY29kaW5nIGhhcyBiZWVuIGdpdmVuLlxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgbmV3RW5jb2RpbmdzID0gc2RwVW5pZmllZFBsYW5VdGlscy5nZXRSdHBFbmNvZGluZ3Moe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3RW5jb2RpbmdzWzBdLCBlbmNvZGluZ3NbMF0pO1xuICAgICAgICAgICAgLy8gSGFjayBmb3IgVlA5IFNWQy5cbiAgICAgICAgICAgIGlmIChoYWNrVnA5U3ZjKSB7XG4gICAgICAgICAgICAgICAgbmV3RW5jb2RpbmdzID0gW25ld0VuY29kaW5nc1swXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBuZXdFbmNvZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIG1vcmUgdGhhbiAxIGVuY29kaW5nIGFyZSBnaXZlbiB1c2UgdGhlbSB2ZXJiYXRpbS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IG9yIEgyNjQgYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG9cbiAgICAgICAgLy8gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnIHx8XG4gICAgICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9oMjY0JykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSBgTDFUJHtsYXllcnMudGVtcG9yYWxMYXllcnN9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHJldXNlTWlkOiBtZWRpYVNlY3Rpb25JZHgucmV1c2VNaWQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgICAgICBleHRtYXBBbGxvd01peGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyOiB0cmFuc2NlaXZlci5zZW5kZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25DbG9zZWQgPSB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgaWYgKG1lZGlhU2VjdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVzdW1lU2VuZGluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IG1hcExvY2FsSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkID8/IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgICAgIG1hcExvY2FsSWQuc2V0KHRyYWNrSWQsIGxvY2FsSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQgPz8gcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBydHBSZWNlaXZlcjogdHJhbnNjZWl2ZXIucmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydE5vdENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdtZXRob2QgY2FsbGVkIGluIGEgY2xvc2VkIGhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNzQgPSBDaHJvbWU3NDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVkZ2UxMSA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IGVkZ2VVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9vcnRjL2VkZ2VVdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRWRnZTExJyk7XG5jb25zdCBOQU1FID0gJ0VkZ2UxMSc7XG5jbGFzcyBFZGdlMTEgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgRWRnZTExKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwU2VuZGVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9ydHBTZW5kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwUmVjZWl2ZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX3J0cFJlY2VpdmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBsb2NhbElkIGZvciBzZW5kaW5nIHRyYWNrcy5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gTkFNRTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgSUNFIGdhdGhlcmVyLlxuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9pY2VHYXRoZXJlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIC8vIENsb3NlIHRoZSBJQ0UgdHJhbnNwb3J0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAvLyBDbG9zZSB0aGUgRFRMUyB0cmFuc3BvcnQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9kdGxzVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAvLyBDbG9zZSBSVENSdHBTZW5kZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IHJ0cFNlbmRlciBvZiB0aGlzLl9ydHBTZW5kZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ0cFNlbmRlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlIFJUQ1J0cFJlY2VpdmVycy5cbiAgICAgICAgZm9yIChjb25zdCBydHBSZWNlaXZlciBvZiB0aGlzLl9ydHBSZWNlaXZlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VVdGlscy5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IHsgT1M6IDAsIE1JUzogMCB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVtb3RlSWNlUGFyYW1ldGVycyA9IGljZVBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMgPSBpY2VDYW5kaWRhdGVzO1xuICAgICAgICB0aGlzLl9yZW1vdGVEdGxzUGFyYW1ldGVycyA9IGR0bHNQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9jbmFtZSA9IGBDTkFNRS0ke3V0aWxzLmdlbmVyYXRlUmFuZG9tTnVtYmVyKCl9YDtcbiAgICAgICAgdGhpcy5zZXRJY2VHYXRoZXJlcih7IGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSB9KTtcbiAgICAgICAgdGhpcy5zZXRJY2VUcmFuc3BvcnQoKTtcbiAgICAgICAgdGhpcy5zZXREdGxzVHJhbnNwb3J0KCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgLy8gTk9URTogRWRnZSAxMSBkb2VzIG5vdCBpbXBsZW1lbnQgaWNlR2F0aGVyZXIuZ2F0ZXIoKS5cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZUljZVBhcmFtZXRlcnMgPSBpY2VQYXJhbWV0ZXJzO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIGljZVRyYW5zcG9ydC5zdGFydCgpJyk7XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5zdGFydCh0aGlzLl9pY2VHYXRoZXJlciwgaWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pY2VUcmFuc3BvcnQuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBuZXcgUlRDUnRwU2VuZGVyKCknKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gbmV3IFJUQ1J0cFNlbmRlcih0cmFjaywgdGhpcy5fZHRsc1RyYW5zcG9ydCk7XG4gICAgICAgIGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3MocnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgdXNlUnR4ID0gcnRwUGFyYW1ldGVycy5jb2RlY3Muc29tZSgoX2NvZGVjKSA9PiAvLitcXC9ydHgkL2kudGVzdChfY29kZWMubWltZVR5cGUpKTtcbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGVuY29kaW5ncyA9IFt7fV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGVuY29kaW5nLnNzcmMgPSB1dGlscy5nZW5lcmF0ZVJhbmRvbU51bWJlcigpO1xuICAgICAgICAgICAgaWYgKHVzZVJ0eCkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnJ0eCA9IHsgc3NyYzogdXRpbHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgICAvLyBGaWxsIFJUQ1J0cFBhcmFtZXRlcnMucnRjcC5cbiAgICAgICAgcnRwUGFyYW1ldGVycy5ydGNwID0ge1xuICAgICAgICAgICAgY25hbWU6IHRoaXMuX2NuYW1lLFxuICAgICAgICAgICAgcmVkdWNlZFNpemU6IHRydWUsXG4gICAgICAgICAgICBtdXg6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE5PVEU6IENvbnZlcnQgb3VyIHN0YW5kYXJkIFJUQ1J0cFBhcmFtZXRlcnMgaW50byB0aG9zZSB0aGF0IEVkZ2VcbiAgICAgICAgLy8gZXhwZWN0cy5cbiAgICAgICAgY29uc3QgZWRnZVJ0cFBhcmFtZXRlcnMgPSBlZGdlVXRpbHMubWFuZ2xlUnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHJ0cFNlbmRlci5zZW5kKCkgW3BhcmFtczolb10nLCBlZGdlUnRwUGFyYW1ldGVycyk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZW5kKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgLy8gU3RvcmUgaXQuXG4gICAgICAgIHRoaXMuX3J0cFNlbmRlcnMuc2V0KGxvY2FsSWQsIHJ0cFNlbmRlcik7XG4gICAgICAgIHJldHVybiB7IGxvY2FsSWQsIHJ0cFBhcmFtZXRlcnMsIHJ0cFNlbmRlciB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydHBTZW5kZXJzLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcnRwU2VuZGVyLnN0b3AoKScpO1xuICAgICAgICAgICAgcnRwU2VuZGVyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzdG9wU2VuZGluZygpIHwgcnRwU2VuZGVyLnN0b3AoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJ0cFNlbmRlci5zZXRUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ0cFNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgbmV3IFJUQ1J0cFJlY2VpdmVyKCknKTtcbiAgICAgICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gbmV3IFJUQ1J0cFJlY2VpdmVyKHRoaXMuX2R0bHNUcmFuc3BvcnQsIGtpbmQpO1xuICAgICAgICAgICAgcnRwUmVjZWl2ZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3J0cFJlY2VpdmVyIFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOT1RFOiBDb252ZXJ0IG91ciBzdGFuZGFyZCBSVENSdHBQYXJhbWV0ZXJzIGludG8gdGhvc2UgdGhhdCBFZGdlXG4gICAgICAgICAgICAvLyBleHBlY3RzLlxuICAgICAgICAgICAgY29uc3QgZWRnZVJ0cFBhcmFtZXRlcnMgPSBlZGdlVXRpbHMubWFuZ2xlUnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBydHBSZWNlaXZlci5yZWNlaXZlKCkgW3BhcmFtczolb10nLCBlZGdlUnRwUGFyYW1ldGVycyk7XG4gICAgICAgICAgICBhd2FpdCBydHBSZWNlaXZlci5yZWNlaXZlKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICAgICAgLy8gU3RvcmUgaXQuXG4gICAgICAgICAgICB0aGlzLl9ydHBSZWNlaXZlcnMuc2V0KGxvY2FsSWQsIHJ0cFJlY2VpdmVyKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICB0cmFjazogcnRwUmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9ydHBSZWNlaXZlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCFydHBSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ydHBSZWNlaXZlcnMuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIuc3RvcCgpJyk7XG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BSZWNlaXZpbmcoKSB8IHJ0cFJlY2VpdmVyLnN0b3AoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gdGhpcy5fcnRwUmVjZWl2ZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwUmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgc2V0SWNlR2F0aGVyZXIoeyBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIH0pIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLS0gT24gcHVycG9zZVxuICAgICAgICBjb25zdCBpY2VHYXRoZXJlciA9IG5ldyBSVENJY2VHYXRoZXJlcih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzID8/IFtdLFxuICAgICAgICAgICAgZ2F0aGVyUG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgPz8gJ2FsbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBpY2VHYXRoZXJlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdpY2VHYXRoZXJlciBcImVycm9yXCIgZXZlbnQgW2V2ZW50OiVvXScsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZSwgd2hpY2ggc3RhcnRzIGdhdGhlcmluZyBhdXRvbWF0aWNhbGx5LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWNlR2F0aGVyZXIuZ2F0aGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NldEljZUdhdGhlcmVyKCkgfCBpY2VHYXRoZXJlci5nYXRoZXIoKSBmYWlsZWQ6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faWNlR2F0aGVyZXIgPSBpY2VHYXRoZXJlcjtcbiAgICB9XG4gICAgc2V0SWNlVHJhbnNwb3J0KCkge1xuICAgICAgICBjb25zdCBpY2VUcmFuc3BvcnQgPSBuZXcgUlRDSWNlVHJhbnNwb3J0KHRoaXMuX2ljZUdhdGhlcmVyKTtcbiAgICAgICAgLy8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuICAgICAgICBpY2VUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGljZVRyYW5zcG9ydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogTm90IHN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgaWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2ljZXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChpY2VUcmFuc3BvcnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdjYW5kaWRhdGVwYWlyY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2ljZVRyYW5zcG9ydCBcImNhbmRpZGF0ZXBhaXJjaGFuZ2VcIiBldmVudCBbcGFpcjolb10nLCBldmVudC5wYWlyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydCA9IGljZVRyYW5zcG9ydDtcbiAgICB9XG4gICAgc2V0RHRsc1RyYW5zcG9ydCgpIHtcbiAgICAgICAgY29uc3QgZHRsc1RyYW5zcG9ydCA9IG5ldyBSVENEdGxzVHJhbnNwb3J0KHRoaXMuX2ljZVRyYW5zcG9ydCk7XG4gICAgICAgIC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgZHRsc1RyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnZHRsc1RyYW5zcG9ydCBcInN0YXRlY2hhbmdlXCIgZXZlbnQgW3N0YXRlOiVzXScsIGR0bHNUcmFuc3BvcnQuc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogTm90IHN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgZHRsc1RyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdkdGxzc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2R0bHNUcmFuc3BvcnQgXCJkdGxzc3RhdGVjaGFuZ2VcIiBldmVudCBbc3RhdGU6JXNdJywgZHRsc1RyYW5zcG9ydC5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHRsc1RyYW5zcG9ydC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkdGxzVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2R0bHNUcmFuc3BvcnQgXCJlcnJvclwiIGV2ZW50IFtldmVudDolb10nLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kdGxzVHJhbnNwb3J0ID0gZHRsc1RyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0dXBUcmFuc3BvcnQoKScpO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSB0aGlzLl9kdGxzVHJhbnNwb3J0LmdldExvY2FsUGFyYW1ldGVycygpO1xuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSVENJY2VUcmFuc3BvcnQuXG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5zdGFydCh0aGlzLl9pY2VHYXRoZXJlciwgdGhpcy5fcmVtb3RlSWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgIC8vIEFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZXMuXG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHNvIHNpZ25hbCBhICdjb21wbGV0ZScgY2FuZGlkYXRlIGFzIHBlciBzcGVjLlxuICAgICAgICAvLyBOT1RFOiBJdCBzaG91bGQgYmUge2NvbXBsZXRlOiB0cnVlfSBidXQgRWRnZSBwcmVmZXJzIHt9LlxuICAgICAgICAvLyBOT1RFOiBJZiB3ZSBkb24ndCBzaWduYWwgZW5kIG9mIGNhbmRpZGF0ZXMsIHRoZSBFZGdlIFJUQ0ljZVRyYW5zcG9ydFxuICAgICAgICAvLyB3b24ndCBlbnRlciB0aGUgJ2NvbXBsZXRlZCcgc3RhdGUuXG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgICAgICAvLyBOT1RFOiBFZGdlIGRvZXMgbm90IGxpa2UgU0hBIGxlc3MgdGhhbiAyNTYuXG4gICAgICAgIHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cyA9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHMuZmlsdGVyKChmaW5nZXJwcmludCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTI1NicgfHxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTM4NCcgfHxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTUxMicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSVENEdGxzVHJhbnNwb3J0LlxuICAgICAgICB0aGlzLl9kdGxzVHJhbnNwb3J0LnN0YXJ0KHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRWRnZTExID0gRWRnZTExO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlyZWZveDEyMCA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3Qgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4uL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdGaXJlZm94MTIwJyk7XG5jb25zdCBOQU1FID0gJ0ZpcmVmb3gxMjAnO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDE2LCBNSVM6IDIwNDggfTtcbmNsYXNzIEZpcmVmb3gxMjAgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgRmlyZWZveDEyMCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBNYXAgb2YgUlRDVHJhbnNjZWl2ZXJzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gTkFNRTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFOiBXZSBuZWVkIHRvIGFkZCBhIHJlYWwgdmlkZW8gdHJhY2sgdG8gZ2V0IHRoZSBSSUQgZXh0ZW5zaW9uIG1hcHBpbmcsXG4gICAgICAgIC8vIG90aGVyd2lzZXIgRmlyZWZveCBkb2Vzbid0IGluY2x1ZGUgaXQgaW4gdGhlIFNEUC5cbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIC8vIE5PVEU6IE90aGVyd2lzZSBGaXJlZm94IGZhaWxzIGluIG5leHQgbGluZS5cbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnN0IGZha2VTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuICAgICAgICBjb25zdCBmYWtlVmlkZW9UcmFjayA9IGZha2VTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uOiAnc2VuZHJlY3YnIH0pO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoZmFrZVZpZGVvVHJhY2ssIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kcmVjdicsXG4gICAgICAgICAgICAgICAgc2VuZEVuY29kaW5nczogW1xuICAgICAgICAgICAgICAgICAgICB7IHJpZDogJ3IwJywgbWF4Qml0cmF0ZTogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcmlkOiAncjEnLCBtYXhCaXRyYXRlOiA1MDAwMDAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZha2VWaWRlb1RyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzID8/IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgPz8gJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgfSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdAaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdydW4oKSB8IHBjLmNvbm5lY3Rpb25TdGF0ZSBub3Qgc3VwcG9ydGVkLCB1c2luZyBwYy5pY2VDb25uZWN0aW9uU3RhdGUnKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgLy8gTk9URTogRmlyZWZveCBkb2VzIG5vdCBpbXBsZW1lbnQgcGMuc2V0Q29uZmlndXJhdGlvbigpLlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgb25SdHBTZW5kZXIsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucmlkID0gYHIke2lkeH1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgLy8gTk9URTogRmlyZWZveCBmYWlscyBzb21ldGltZXMgdG8gcHJvcGVybHkgYW50aWNpcGF0ZSB0aGUgY2xvc2VkIG1lZGlhXG4gICAgICAgIC8vIHNlY3Rpb24gdGhhdCBpdCBzaG91bGQgdXNlLCBzbyBkb24ndCByZXVzZSBjbG9zZWQgbWVkaWEgc2VjdGlvbnMuXG4gICAgICAgIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3ZlcnNhdGljYS9tZWRpYXNvdXAtY2xpZW50L2lzc3Vlcy8xMDRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwIS5nZXROZXh0TWVkaWFTZWN0aW9uSWR4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgICAgIHN0cmVhbXM6IFt0aGlzLl9zZW5kU3RyZWFtXSxcbiAgICAgICAgICAgIHNlbmRFbmNvZGluZ3M6IGVuY29kaW5ncyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblJ0cFNlbmRlcikge1xuICAgICAgICAgICAgb25SdHBTZW5kZXIodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAvLyBJbiBGaXJlZm94IHVzZSBEVExTIHJvbGUgY2xpZW50IGV2ZW4gaWYgd2UgYXJlIHRoZSBcIm9mZmVyZXJcIiBzaW5jZVxuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlc3BlY3QgSUNFLUxpdGUuXG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5ZXJzID0gKDAsIHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZSkoKGVuY29kaW5ncyA/PyBbe31dKVswXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhbnNjZWl2ZXIubWlkO1xuICAgICAgICAvLyBTZXQgTUlELlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5taWQgPSBsb2NhbElkO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVtsb2NhbFNkcE9iamVjdC5tZWRpYS5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPSBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGlmIG5vIGVuY29kaW5ncyBhcmUgZ2l2ZW4uXG4gICAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBhbmQgY29tcGxldGUgdGhlbSB3aXRoIGdpdmVuXG4gICAgICAgIC8vIG9uZSBpZiBqdXN0IGEgc2luZ2xlIGVuY29kaW5nIGhhcyBiZWVuIGdpdmVuLlxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbmNvZGluZ3NbMF0sIGVuY29kaW5nc1swXSk7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBuZXdFbmNvZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIG1vcmUgdGhhbiAxIGVuY29kaW5nIGFyZSBnaXZlbiB1c2UgdGhlbSB2ZXJiYXRpbS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IG9yIEgyNjQgYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG9cbiAgICAgICAgLy8gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnIHx8XG4gICAgICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9oMjY0JykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSBgTDFUJHtsYXllcnMudGVtcG9yYWxMYXllcnN9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIC8vIE5PVEU6IENhbm5vdCB1c2Ugc3RvcCgpIHRoZSB0cmFuc2NlaXZlciBkdWUgdG8gdGhlIHRoZSBub3RlIGFib3ZlIGluXG4gICAgICAgIC8vIHNlbmQoKSBtZXRob2QuXG4gICAgICAgIC8vIHRyeVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vIFx0dHJhbnNjZWl2ZXIuc3RvcCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGNhdGNoIChlcnJvcilcbiAgICAgICAgLy8ge31cbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgLy8gTk9URTogQ2Fubm90IHVzZSBjbG9zZU1lZGlhU2VjdGlvbigpIGR1ZSB0byB0aGUgdGhlIG5vdGUgYWJvdmUgaW4gc2VuZCgpXG4gICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgLy8gdGhpcy5fcmVtb3RlU2RwIS5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuZGlzYWJsZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5kZWxldGUobG9jYWxJZCk7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wYXVzZU1lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVTZW5kaW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIHRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwTG9jYWxJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgPz8gU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICAgICAgbWFwTG9jYWxJZC5zZXQodHJhY2tJZCwgbG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCA/PyBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBvblJ0cFJlY2VpdmVyIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9uUnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uUnRwUmVjZWl2ZXIodHJhbnNjZWl2ZXIucmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVSZWNlaXZpbmdNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ21ldGhvZCBjYWxsZWQgaW4gYSBjbG9zZWQgaGFuZGxlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GaXJlZm94MTIwID0gRmlyZWZveDEyMDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpcmVmb3g2MCA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3Qgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4uL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdGaXJlZm94NjAnKTtcbmNvbnN0IE5BTUUgPSAnRmlyZWZveDYwJztcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxNiwgTUlTOiAyMDQ4IH07XG5jbGFzcyBGaXJlZm94NjAgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgRmlyZWZveDYwKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE1hcCBvZiBSVENUcmFuc2NlaXZlcnMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEU6IFdlIG5lZWQgdG8gYWRkIGEgcmVhbCB2aWRlbyB0cmFjayB0byBnZXQgdGhlIFJJRCBleHRlbnNpb24gbWFwcGluZy5cbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIC8vIE5PVEU6IE90aGVyd2lzZSBGaXJlZm94IGZhaWxzIGluIG5leHQgbGluZS5cbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnN0IGZha2VTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuICAgICAgICBjb25zdCBmYWtlVmlkZW9UcmFjayA9IGZha2VTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uOiAnc2VuZHJlY3YnIH0pO1xuICAgICAgICAgICAgY29uc3QgdmlkZW9UcmFuc2NlaXZlciA9IHBjLmFkZFRyYW5zY2VpdmVyKGZha2VWaWRlb1RyYWNrLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZHJlY3YnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdmlkZW9UcmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmdzID0gW1xuICAgICAgICAgICAgICAgIHsgcmlkOiAncjAnLCBtYXhCaXRyYXRlOiAxMDAwMDAgfSxcbiAgICAgICAgICAgICAgICB7IHJpZDogJ3IxJywgbWF4Qml0cmF0ZTogNTAwMDAwIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgICAgICBhd2FpdCB2aWRlb1RyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7XG4gICAgICAgICAgICAgICAgc2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmFrZVZpZGVvVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyA/PyBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5ID8/ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIC8vIE5PVEU6IEZpcmVmb3ggZG9lcyBub3QgaW1wbGVtZW50IHBjLnNldENvbmZpZ3VyYXRpb24oKS5cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGVuY29kaW5ncyA9IHV0aWxzLmNsb25lKGVuY29kaW5ncyk7XG4gICAgICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnJpZCA9IGByJHtpZHh9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGVuY29kaW5ncyBhbmQgcmV2ZXJzZSB0aGVtIGJlY2F1c2UgRmlyZWZveCBsaWtlcyB0aGVtXG4gICAgICAgICAgICAvLyBmcm9tIGhpZ2ggdG8gbG93LlxuICAgICAgICAgICAgZW5jb2RpbmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICAvLyBOT1RFOiBGaXJlZm94IGZhaWxzIHNvbWV0aW1lcyB0byBwcm9wZXJseSBhbnRpY2lwYXRlIHRoZSBjbG9zZWQgbWVkaWFcbiAgICAgICAgLy8gc2VjdGlvbiB0aGF0IGl0IHNob3VsZCB1c2UsIHNvIGRvbid0IHJldXNlIGNsb3NlZCBtZWRpYSBzZWN0aW9ucy5cbiAgICAgICAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vdmVyc2F0aWNhL21lZGlhc291cC1jbGllbnQvaXNzdWVzLzEwNFxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAhLmdldE5leHRNZWRpYVNlY3Rpb25JZHgoKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknLFxuICAgICAgICAgICAgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBub3Qgc3BlYyBjb21wbGlhbnRzLiBFbmNvZGluZ3Mgc2hvdWxkIGJlIGdpdmVuIGluIGFkZFRyYW5zY2VpdmVyXG4gICAgICAgIC8vIHNlY29uZCBhcmd1bWVudCwgYnV0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIC8vIEluIEZpcmVmb3ggdXNlIERUTFMgcm9sZSBjbGllbnQgZXZlbiBpZiB3ZSBhcmUgdGhlIFwib2ZmZXJlclwiIHNpbmNlXG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVzcGVjdCBJQ0UtTGl0ZS5cbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXllcnMgPSAoMCwgc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlKSgoZW5jb2RpbmdzID8/IFt7fV0pWzBdLnNjYWxhYmlsaXR5TW9kZSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW2xvY2FsU2RwT2JqZWN0Lm1lZGlhLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VuY29kaW5nc1swXSwgZW5jb2RpbmdzWzBdKTtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltIChidXRcbiAgICAgICAgLy8gcmV2ZXJzZSB0aGVtIGJhY2sgc2luY2Ugd2UgcmV2ZXJzZWQgdGhlbSBhYm92ZSB0byBzYXRpc2Z5IEZpcmVmb3gpLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IG9yIEgyNjQgYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG9cbiAgICAgICAgLy8gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnIHx8XG4gICAgICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9oMjY0JykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSBgTDFUJHtsYXllcnMudGVtcG9yYWxMYXllcnN9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIC8vIE5PVEU6IENhbm5vdCB1c2Ugc3RvcCgpIHRoZSB0cmFuc2NlaXZlciBkdWUgdG8gdGhlIHRoZSBub3RlIGFib3ZlIGluXG4gICAgICAgIC8vIHNlbmQoKSBtZXRob2QuXG4gICAgICAgIC8vIHRyeVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vIFx0dHJhbnNjZWl2ZXIuc3RvcCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGNhdGNoIChlcnJvcilcbiAgICAgICAgLy8ge31cbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgLy8gTk9URTogQ2Fubm90IHVzZSBjbG9zZU1lZGlhU2VjdGlvbigpIGR1ZSB0byB0aGUgdGhlIG5vdGUgYWJvdmUgaW4gc2VuZCgpXG4gICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgLy8gdGhpcy5fcmVtb3RlU2RwIS5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuZGlzYWJsZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5kZWxldGUobG9jYWxJZCk7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wYXVzZU1lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVTZW5kaW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIHRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAvLyBOT1RFOiBXZSByZXF1aXJlIGVuY29kaW5ncyBnaXZlbiBmcm9tIGxvdyB0byBoaWdoLCBob3dldmVyIEZpcmVmb3hcbiAgICAgICAgLy8gcmVxdWlyZXMgdGhlbSBpbiByZXZlcnNlIG9yZGVyLCBzbyBkbyBtYWdpYyBoZXJlLlxuICAgICAgICBzcGF0aWFsTGF5ZXIgPSBwYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggLSAxIC0gc3BhdGlhbExheWVyO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4ID49IHNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwTG9jYWxJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgPz8gU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICAgICAgbWFwTG9jYWxJZC5zZXQodHJhY2tJZCwgbG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCA/PyBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVSZWNlaXZpbmdNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ21ldGhvZCBjYWxsZWQgaW4gYSBjbG9zZWQgaGFuZGxlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GaXJlZm94NjAgPSBGaXJlZm94NjA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFuZGxlckludGVyZmFjZSA9IHZvaWQgMDtcbmNvbnN0IGVuaGFuY2VkRXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZW5oYW5jZWRFdmVudHNcIik7XG5jbGFzcyBIYW5kbGVySW50ZXJmYWNlIGV4dGVuZHMgZW5oYW5jZWRFdmVudHNfMS5FbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYW5kbGVySW50ZXJmYWNlID0gSGFuZGxlckludGVyZmFjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWN0TmF0aXZlID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBQbGFuQlV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9wbGFuQlV0aWxzXCIpKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdSZWFjdE5hdGl2ZScpO1xuY29uc3QgTkFNRSA9ICdSZWFjdE5hdGl2ZSc7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBSZWFjdE5hdGl2ZSBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBSZWFjdE5hdGl2ZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIE1hcCBvZiBzZW5kaW5nIE1lZGlhU3RyZWFtVHJhY2tzIGluZGV4ZWQgYnkgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjayA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBzZW5kaW5nIGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIE1hcCBvZiBNSUQsIFJUUCBwYXJhbWV0ZXJzIGFuZCBSVENSdHBSZWNlaXZlciBpbmRleGVkIGJ5IGxvY2FsIGlkLlxuICAgICAgICAvLyBWYWx1ZSBpcyBhbiBPYmplY3Qgd2l0aCBtaWQsIHJ0cFBhcmFtZXRlcnMgYW5kIHJ0cFJlY2VpdmVyLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gTkFNRTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBGcmVlL2Rpc3Bvc2UgbmF0aXZlIE1lZGlhU3RyZWFtIGJ1dCBETyBOT1QgZnJlZS9kaXNwb3NlIG5hdGl2ZVxuICAgICAgICAvLyBNZWRpYVN0cmVhbVRyYWNrcyAodGhhdCBpcyBwYXJlbnQncyBidXNpbmVzcykuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0tIFByb3ByaWV0YXJ5IEFQSSBpbiByZWFjdC1uYXRpdmUtd2VicnRjLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbGVhc2UoLyogcmVsZWFzZVRyYWNrcyAqLyBmYWxzZSk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAncGxhbi1iJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKHtcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkdGxzUGFyYW1ldGVycy5yb2xlICYmIGR0bHNQYXJhbWV0ZXJzLnJvbGUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA9XG4gICAgICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9PT0gJ3NlcnZlcicgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgPz8gW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSA/PyAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAncGxhbi1iJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgfSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdAaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdydW4oKSB8IHBjLmNvbm5lY3Rpb25TdGF0ZSBub3Qgc3VwcG9ydGVkLCB1c2luZyBwYy5pY2VDb25uZWN0aW9uU3RhdGUnKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc2VuZCgpIHwgY29kZWMgc2VsZWN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gJXMgaGFuZGxlcicsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJyAmJiBlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSB0cmFjay5raW5kKTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPSBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFBsYW5CVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB0cmFjayxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSwgZW5jb2RpbmdzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5zZXQobG9jYWxJZCwgdHJhY2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2sgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHRyYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSwgLy8gTk9URTogT2xkIHNwZWMuXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZShvcHRpb25zTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBtYXBTdHJlYW1JZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBsZXQgc3RyZWFtSWQgPSBvcHRpb25zLnN0cmVhbUlkID8/IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcbiAgICAgICAgICAgIC8vIE5PVEU6IEluIFJlYWN0LU5hdGl2ZSB3ZSBjYW5ub3QgcmV1c2UgdGhlIHNhbWUgcmVtb3RlIE1lZGlhU3RyZWFtIGZvciBuZXdcbiAgICAgICAgICAgIC8vIHJlbW90ZSB0cmFja3MuIFRoaXMgaXMgYmVjYXVzZSByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXMgbm90IHJlYWN0IG9uIG5ld1xuICAgICAgICAgICAgLy8gdHJhY2tzIGdlbmVyYXRlZCB3aXRoaW4gYWxyZWFkeSBleGlzdGluZyBzdHJlYW1zLCBzbyBmb3JjZSB0aGUgc3RyZWFtSWRcbiAgICAgICAgICAgIC8vIHRvIGJlIGRpZmZlcmVudC4gU2VlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LW5hdGl2ZS13ZWJydGMvcmVhY3QtbmF0aXZlLXdlYnJ0Yy9pc3N1ZXMvNDAxXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGZvcmNpbmcgYSByYW5kb20gcmVtb3RlIHN0cmVhbUlkIHRvIGF2b2lkIHdlbGwga25vd24gYnVnIGluIHJlYWN0LW5hdGl2ZS13ZWJydGMnKTtcbiAgICAgICAgICAgIHN0cmVhbUlkICs9IGAtaGFjay0ke3V0aWxzLmdlbmVyYXRlUmFuZG9tTnVtYmVyKCl9YDtcbiAgICAgICAgICAgIG1hcFN0cmVhbUlkLnNldCh0cmFja0lkLCBzdHJlYW1JZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICAgICAgbWlkLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBraW5kLCB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBtYXBTdHJlYW1JZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRSZW1vdGVTdHJlYW1zKClcbiAgICAgICAgICAgICAgICAuZmluZCgocykgPT4gcy5pZCA9PT0gc3RyZWFtSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0VHJhY2tCeUlkKGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5zZXQobG9jYWxJZCwgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goeyBsb2NhbElkLCB0cmFjayB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0gPSB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZ2V0KGxvY2FsSWQpID8/IHt9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGxhbkJTdG9wUmVjZWl2aW5nKHtcbiAgICAgICAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLCAvLyBOT1RFOiBPbGQgc3BlYy5cbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbih7IG9sZERhdGFDaGFubmVsU3BlYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlYWN0TmF0aXZlID0gUmVhY3ROYXRpdmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBVbmlmaWVkUGxhblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpKTtcbmNvbnN0IG9ydGNVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9vcnRjL3V0aWxzXCIpKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1JlYWN0TmF0aXZlVW5pZmllZFBsYW4nKTtcbmNvbnN0IE5BTUUgPSAnUmVhY3ROYXRpdmVVbmlmaWVkUGxhbic7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBSZWFjdE5hdGl2ZVVuaWZpZWRQbGFuIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IFJlYWN0TmF0aXZlVW5pZmllZFBsYW4oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIC8vIEZyZWUvZGlzcG9zZSBuYXRpdmUgTWVkaWFTdHJlYW0gYnV0IERPIE5PVCBmcmVlL2Rpc3Bvc2UgbmF0aXZlXG4gICAgICAgIC8vIE1lZGlhU3RyZWFtVHJhY2tzICh0aGF0IGlzIHBhcmVudCdzIGJ1c2luZXNzKS5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLS0gUHJvcHJpZXRhcnkgQVBJIGluIHJlYWN0LW5hdGl2ZS13ZWJydGMuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVsZWFzZSgvKiByZWxlYXNlVHJhY2tzICovIGZhbHNlKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGxpYndlYnJ0YyBzdXBwb3J0cyBOQUNLIGZvciBPUFVTIGJ1dCBkb2Vzbid0IGFubm91bmNlIGl0LlxuICAgICAgICAgICAgb3J0Y1V0aWxzLmFkZE5hY2tTdXBwcG9ydEZvck9wdXMobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyA/PyBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5ID8/ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3J1bigpIHwgcGMuY29ubmVjdGlvblN0YXRlIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIHBjLmljZUNvbm5lY3Rpb25TdGF0ZScpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCBvblJ0cFNlbmRlciwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5yaWQgPSBgciR7aWR4fWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiBlbmNvZGluZ3MsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25SdHBTZW5kZXIpIHtcbiAgICAgICAgICAgIG9uUnRwU2VuZGVyKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBWUDkgd2l0aCBTVkMuXG4gICAgICAgIGxldCBoYWNrVnA5U3ZjID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxheWVycyA9ICgwLCBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2UpKChlbmNvZGluZ3MgPz8gW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJlxuICAgICAgICAgICAgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgbGF5ZXJzLnNwYXRpYWxMYXllcnMgPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOScpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCBmb3IgVlA5IFNWQycpO1xuICAgICAgICAgICAgaGFja1ZwOVN2YyA9IHRydWU7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogbGF5ZXJzLnNwYXRpYWxMYXllcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICAvLyBOT1RFOiBXZSBjYW5ub3QgcmVhZCBnZW5lcmF0ZWQgTUlEIG9uIGlPUyByZWFjdC1uYXRpdmUtd2VicnRjIDExMS4wLjBcbiAgICAgICAgLy8gYmVjYXVzZSB0cmFuc2NlaXZlci5taWQgaXMgbm90IGF2YWlsYWJsZSB1bnRpbCBzZXRSZW1vdGVEZXNjcmlwdGlvbigpXG4gICAgICAgIC8vIGlzIGNhbGxlZCwgc28gdGhpcyBpcyBiZXN0IGVmZm9ydC5cbiAgICAgICAgLy8gSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1uYXRpdmUtd2VicnRjL3JlYWN0LW5hdGl2ZS13ZWJydGMvaXNzdWVzLzE0MDRcbiAgICAgICAgLy8gTk9URTogU28gbGV0J3MgZmlsbCBNSUQgaW4gc2VuZGluZ1J0cFBhcmFtZXRlcnMgbGF0ZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZml4ZWQgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0YyAxMTEuMC4zLlxuICAgICAgICBsZXQgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZCA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbG9jYWxJZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IG1pc3NpbmcgdHJhbnNjZWl2ZXIubWlkIChidWcgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0YywgdXNpbmcgYSB3b3JrYXJvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgLy8gTk9URTogQXMgcGVyIGFib3ZlLCBpdCBjb3VsZCBiZSB1bnNldCB5ZXQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbmNvZGluZ3NbMF0sIGVuY29kaW5nc1swXSk7XG4gICAgICAgICAgICAvLyBIYWNrIGZvciBWUDkgU1ZDLlxuICAgICAgICAgICAgaWYgKGhhY2tWcDlTdmMpIHtcbiAgICAgICAgICAgICAgICBuZXdFbmNvZGluZ3MgPSBbbmV3RW5jb2RpbmdzWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGBMMVQke2xheWVycy50ZW1wb3JhbExheWVyc31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ0wxVDMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIEZvbGxvdyB1cCBvZiBpT1MgcmVhY3QtbmF0aXZlLXdlYnJ0YyAxMTEuMC4wIGlzc3VlIHRvbGQgYWJvdmUuIE5vdyB5ZXMsXG4gICAgICAgIC8vIHdlIGNhbiByZWFkIGdlbmVyYXRlZCBNSUQgKGlmIG5vdCBkb25lIGFib3ZlKSBhbmQgZmlsbCBzZW5kaW5nUnRwUGFyYW1ldGVycy5cbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBmaXhlZCBpbiByZWFjdC1uYXRpdmUtd2VicnRjIDExMS4wLjMgc28gdGhpcyBibG9jayBpc24ndFxuICAgICAgICAvLyBuZWVkZWQgc3RhcnRpbmcgZnJvbSB0aGF0IHZlcnNpb24uXG4gICAgICAgIGlmICghbG9jYWxJZCkge1xuICAgICAgICAgICAgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZvaWQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uQ2xvc2VkID0gdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGlmIChtZWRpYVNlY3Rpb25DbG9zZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5kZWxldGUobG9jYWxJZCk7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wYXVzZU1lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVNlbmRpbmdNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZShvcHRpb25zTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBtYXBMb2NhbElkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycywgc3RyZWFtSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCA/PyBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgICAgICBtYXBMb2NhbElkLnNldCh0cmFja0lkLCBsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkID8/IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIG9uUnRwUmVjZWl2ZXIgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob25SdHBSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjXG4gICAgICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25SdHBSZWNlaXZlcih0cmFuc2NlaXZlci5yZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrOiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVSZWNlaXZpbmdNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0LCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnROb3RDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbWV0aG9kIGNhbGxlZCBpbiBhIGNsb3NlZCBoYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlYWN0TmF0aXZlVW5pZmllZFBsYW4gPSBSZWFjdE5hdGl2ZVVuaWZpZWRQbGFuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2FmYXJpMTEgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3BsYW5CVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1NhZmFyaTExJyk7XG5jb25zdCBOQU1FID0gJ1NhZmFyaTExJztcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIFNhZmFyaTExIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IFNhZmFyaTExKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFNlbmRlciBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOZXh0IHNlbmRpbmcgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkID0gMDtcbiAgICAgICAgLy8gTWFwIG9mIE1JRCwgUlRQIHBhcmFtZXRlcnMgYW5kIFJUQ1J0cFJlY2VpdmVyIGluZGV4ZWQgYnkgbG9jYWwgaWQuXG4gICAgICAgIC8vIFZhbHVlIGlzIGFuIE9iamVjdCB3aXRoIG1pZCwgcnRwUGFyYW1ldGVycyBhbmQgcnRwUmVjZWl2ZXIuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAncGxhbi1iJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKHtcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkdGxzUGFyYW1ldGVycy5yb2xlICYmIGR0bHNQYXJhbWV0ZXJzLnJvbGUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA9XG4gICAgICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9PT0gJ3NlcnZlcicgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgPz8gW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSA/PyAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3J1bigpIHwgcGMuY29ubmVjdGlvblN0YXRlIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIHBjLmljZUNvbm5lY3Rpb25TdGF0ZScpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzZW5kKCkgfCBjb2RlYyBzZWxlY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiAlcyBoYW5kbGVyJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nICYmIGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAndmlkZW8nKTtcbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09IHRyYWNrLmtpbmQpO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gc2RwUGxhbkJVdGlscy5nZXRSdHBFbmNvZGluZ3Moe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0byBlYWNoXG4gICAgICAgIC8vIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgIC5nZXRTZW5kZXJzKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLnNldChsb2NhbElkLCBydHBTZW5kZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydHBTZW5kZXIudHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2socnRwU2VuZGVyLnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFRyYWNrID0gcnRwU2VuZGVyLnRyYWNrO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuICAgICAgICBpZiAob2xkVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBydHBTZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwU2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkID8/IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhY2tJZDtcbiAgICAgICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgocikgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghcnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBSZWNlaXZlciBub3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgIHRyYWNrOiBydHBSZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgPz8ge307XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoe1xuICAgICAgICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgcnRwUmVjZWl2ZXIgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgPz8ge307XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwUmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TYWZhcmkxMSA9IFNhZmFyaTExO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2FmYXJpMTIgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3VuaWZpZWRQbGFuVXRpbHNcIikpO1xuY29uc3Qgb3J0Y1V0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29ydGMvdXRpbHNcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IHNjYWxhYmlsaXR5TW9kZXNfMSA9IHJlcXVpcmUoXCIuLi9zY2FsYWJpbGl0eU1vZGVzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignU2FmYXJpMTInKTtcbmNvbnN0IE5BTUUgPSAnU2FmYXJpMTInO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgU2FmYXJpMTIgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgU2FmYXJpMTIoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGxpYndlYnJ0YyBzdXBwb3J0cyBOQUNLIGZvciBPUFVTIGJ1dCBkb2Vzbid0IGFubm91bmNlIGl0LlxuICAgICAgICAgICAgb3J0Y1V0aWxzLmFkZE5hY2tTdXBwcG9ydEZvck9wdXMobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyA/PyBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5ID8/ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIG9uUnRwU2VuZGVyLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25SdHBTZW5kZXIpIHtcbiAgICAgICAgICAgIG9uUnRwU2VuZGVyKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5ZXJzID0gKDAsIHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZSkoKGVuY29kaW5ncyA/PyBbe31dKVswXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBpZiAoZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIGxlZ2FjeSBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgLy8gV2UgY2FuIG5vdyBnZXQgdGhlIHRyYW5zY2VpdmVyLm1pZC5cbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMubWlkID0gbG9jYWxJZDtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID0gc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBvciBIMjY0IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvXG4gICAgICAgIC8vIGVhY2ggZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4JyB8fFxuICAgICAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vaDI2NCcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gYEwxVCR7bGF5ZXJzLnRlbXBvcmFsTGF5ZXJzfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICByZXVzZU1pZDogbWVkaWFTZWN0aW9uSWR4LnJldXNlTWlkLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyOiB0cmFuc2NlaXZlci5zZW5kZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25DbG9zZWQgPSB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgaWYgKG1lZGlhU2VjdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVNlbmRpbmdNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IG1hcExvY2FsSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkID8/IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgICAgIG1hcExvY2FsSWQuc2V0KHRyYWNrSWQsIGxvY2FsSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQgPz8gcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwgb25SdHBSZWNlaXZlciB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvblJ0cFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblJ0cFJlY2VpdmVyKHRyYW5zY2VpdmVyLnJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICB0cmFjazogdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydE5vdENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdtZXRob2QgY2FsbGVkIGluIGEgY2xvc2VkIGhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2FmYXJpMTIgPSBTYWZhcmkxMjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENhcGFiaWxpdGllcyA9IGdldENhcGFiaWxpdGllcztcbmV4cG9ydHMubWFuZ2xlUnRwUGFyYW1ldGVycyA9IG1hbmdsZVJ0cFBhcmFtZXRlcnM7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vdXRpbHNcIikpO1xuLyoqXG4gKiBOb3JtYWxpemUgT1JUQyBiYXNlZCBFZGdlJ3MgUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCkgdG8gcHJvZHVjZSBhIGZ1bGxcbiAqIGNvbXBsaWFudCBPUlRDIFJUQ1J0cENhcGFiaWxpdGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FwYWJpbGl0aWVzKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNhcHMgPSBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICBjb25zdCBjYXBzID0gdXRpbHMuY2xvbmUobmF0aXZlQ2Fwcyk7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBzLmNvZGVjcyA/PyBbXSkge1xuICAgICAgICAvLyBSZW5hbWUgbnVtQ2hhbm5lbHMgdG8gY2hhbm5lbHMuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0tIE9uIHB1cnBvc2UuXG4gICAgICAgIGNvZGVjLmNoYW5uZWxzID0gY29kZWMubnVtQ2hhbm5lbHM7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0tIE9uIHB1cnBvc2UuXG4gICAgICAgIGRlbGV0ZSBjb2RlYy5udW1DaGFubmVscztcbiAgICAgICAgLy8gQWRkIG1pbWVUeXBlLlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tLSBPbiBwdXJwb3NlIChkdWUgdG8gY29kZWMubmFtZSkuXG4gICAgICAgIGNvZGVjLm1pbWVUeXBlID0gY29kZWMubWltZVR5cGUgPz8gYCR7Y29kZWMua2luZH0vJHtjb2RlYy5uYW1lfWA7XG4gICAgICAgIC8vIE5PVEU6IEVkZ2Ugc2V0cyBzb21lIG51bWVyaWMgcGFyYW1ldGVycyBhcyBzdHJpbmcgcmF0aGVyIHRoYW4gbnVtYmVyLiBGaXggdGhlbS5cbiAgICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBjb2RlYy5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hcHQgPSBOdW1iZXIocGFyYW1ldGVycy5hcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnNbJ3BhY2tldGl6YXRpb24tbW9kZSddKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10gPSBOdW1iZXIocGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZSBlbXR5IHBhcmFtZXRlciBTdHJpbmcgaW4gcnRjcEZlZWRiYWNrLlxuICAgICAgICBmb3IgKGNvbnN0IGZlZWRiYWNrIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjayA/PyBbXSkge1xuICAgICAgICAgICAgaWYgKCFmZWVkYmFjay5wYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICBmZWVkYmFjay5wYXJhbWV0ZXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2Fwcztcbn1cbi8qKlxuICogR2VuZXJhdGUgUlRDUnRwUGFyYW1ldGVycyBhcyBPUlRDIGJhc2VkIEVkZ2UgbGlrZXMuXG4gKi9cbmZ1bmN0aW9uIG1hbmdsZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLmNsb25lKHJ0cFBhcmFtZXRlcnMpO1xuICAgIC8vIFJlbmFtZSBtaWQgdG8gbXV4SWQuXG4gICAgaWYgKHBhcmFtcy5taWQpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLS0gT24gcHVycG9zZSAoZHVlIHRvIG11eElkKS5cbiAgICAgICAgcGFyYW1zLm11eElkID0gcGFyYW1zLm1pZDtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy5taWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29kZWMgb2YgcGFyYW1zLmNvZGVjcykge1xuICAgICAgICAvLyBSZW5hbWUgY2hhbm5lbHMgdG8gbnVtQ2hhbm5lbHMuXG4gICAgICAgIGlmIChjb2RlYy5jaGFubmVscykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLS0gT24gcHVycG9zZS5cbiAgICAgICAgICAgIGNvZGVjLm51bUNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICBkZWxldGUgY29kZWMuY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNvZGVjLm5hbWUgKHJlcXVyaWVkIGJ5IEVkZ2UpLlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tLSBPbiBwdXJwb3NlIChkdWUgdG8gbmFtZSkuXG4gICAgICAgIGlmIChjb2RlYy5taW1lVHlwZSAmJiAhY29kZWMubmFtZSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLS0gT24gcHVycG9zZSAoZHVlIHRvIG5hbWUpLlxuICAgICAgICAgICAgY29kZWMubmFtZSA9IGNvZGVjLm1pbWVUeXBlLnNwbGl0KCcvJylbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIG1pbWVUeXBlLlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tLSBPbiBwdXJwb3NlLlxuICAgICAgICBkZWxldGUgY29kZWMubWltZVR5cGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyA9IGFkZE5hY2tTdXBwcG9ydEZvck9wdXM7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBSVENQIE5BQ0sgc3VwcG9ydCBmb3IgT1BVUyBjb2RlYyBpbiBnaXZlbiBjYXBhYmlsaXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGFkZE5hY2tTdXBwcG9ydEZvck9wdXMocnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBydHBDYXBhYmlsaXRpZXMuY29kZWNzID8/IFtdKSB7XG4gICAgICAgIGlmICgoY29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2F1ZGlvL29wdXMnIHx8XG4gICAgICAgICAgICBjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8vbXVsdGlvcHVzJykgJiZcbiAgICAgICAgICAgICFjb2RlYy5ydGNwRmVlZGJhY2s/LnNvbWUoZmIgPT4gZmIudHlwZSA9PT0gJ25hY2snICYmICFmYi5wYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICBpZiAoIWNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goeyB0eXBlOiAnbmFjaycgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PZmZlck1lZGlhU2VjdGlvbiA9IGV4cG9ydHMuQW5zd2VyTWVkaWFTZWN0aW9uID0gZXhwb3J0cy5NZWRpYVNlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpKTtcbmNsYXNzIE1lZGlhU2VjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeyBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgcGxhbkIgPSBmYWxzZSwgfSkge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdCA9IHt9O1xuICAgICAgICB0aGlzLl9wbGFuQiA9IHBsYW5CO1xuICAgICAgICBpZiAoaWNlUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5zZXRJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY2VDYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jYW5kaWRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBpY2VDYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlT2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgLy8gbWVkaWFzb3VwIGRvZXMgbWFuZGF0ZXMgcnRjcC1tdXggc28gY2FuZGlkYXRlcyBjb21wb25lbnQgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gUlRQICgxKS5cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QuY29tcG9uZW50ID0gMTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QuZm91bmRhdGlvbiA9IGNhbmRpZGF0ZS5mb3VuZGF0aW9uO1xuICAgICAgICAgICAgICAgIC8vIEJlIHJlYWR5IGZvciBuZXcgY2FuZGlkYXRlLmFkZHJlc3MgZmllbGQgaW4gbWVkaWFzb3VwIHNlcnZlciBzaWRlXG4gICAgICAgICAgICAgICAgLy8gZmllbGQgYW5kIGtlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGRlcHJlY2F0ZWQgY2FuZGlkYXRlLmlwLlxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5pcCA9IGNhbmRpZGF0ZS5hZGRyZXNzID8/IGNhbmRpZGF0ZS5pcDtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QucG9ydCA9IGNhbmRpZGF0ZS5wb3J0O1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5wcmlvcml0eSA9IGNhbmRpZGF0ZS5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QudHJhbnNwb3J0ID0gY2FuZGlkYXRlLnByb3RvY29sO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC50eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC50Y3B0eXBlID0gY2FuZGlkYXRlLnRjcFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGVPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZW5kT2ZDYW5kaWRhdGVzID0gJ2VuZC1vZi1jYW5kaWRhdGVzJztcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmljZU9wdGlvbnMgPSAncmVub21pbmF0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHRsc1JvbGUoZHRsc1BhcmFtZXRlcnMucm9sZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1pZCgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLl9tZWRpYU9iamVjdC5taWQpO1xuICAgIH1cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFPYmplY3QucG9ydCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0T2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFPYmplY3Q7XG4gICAgfVxuICAgIHNldEljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5pY2VVZnJhZyA9IGljZVBhcmFtZXRlcnMudXNlcm5hbWVGcmFnbWVudDtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuaWNlUHdkID0gaWNlUGFyYW1ldGVycy5wYXNzd29yZDtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LmV4dDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdF8wMztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnJpZHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5leHRtYXBBbGxvd01peGVkO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSAwO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFTZWN0aW9uID0gTWVkaWFTZWN0aW9uO1xuY2xhc3MgQW5zd2VyTWVkaWFTZWN0aW9uIGV4dGVuZHMgTWVkaWFTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgcGxhaW5SdHBQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlLCBvZmZlck1lZGlhT2JqZWN0LCBvZmZlclJ0cFBhcmFtZXRlcnMsIGFuc3dlclJ0cFBhcmFtZXRlcnMsIGNvZGVjT3B0aW9ucywgZXh0bWFwQWxsb3dNaXhlZCA9IGZhbHNlLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHBsYW5CIH0pO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5taWQgPSBTdHJpbmcob2ZmZXJNZWRpYU9iamVjdC5taWQpO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC50eXBlID0gb2ZmZXJNZWRpYU9iamVjdC50eXBlO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9IG9mZmVyTWVkaWFPYmplY3QucHJvdG9jb2w7XG4gICAgICAgIGlmICghcGxhaW5SdHBQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBpcDogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucG9ydCA9IHBsYWluUnRwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAob2ZmZXJNZWRpYU9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGFuc3dlclJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ0cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWM6IGdldENvZGVjTmFtZShjb2RlYyksXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRlOiBjb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlYy5jaGFubmVscyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0cC5lbmNvZGluZyA9IGNvZGVjLmNoYW5uZWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cC5wdXNoKHJ0cCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKGNvZGVjLnBhcmFtZXRlcnMpID8/IHt9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZWNSdGNwRmVlZGJhY2sgPSB1dGlscy5jbG9uZShjb2RlYy5ydGNwRmVlZGJhY2spID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9wdXNTdGVyZW8sIG9wdXNGZWMsIG9wdXNEdHgsIG9wdXNNYXhQbGF5YmFja1JhdGUsIG9wdXNNYXhBdmVyYWdlQml0cmF0ZSwgb3B1c1B0aW1lLCBvcHVzTmFjaywgdmlkZW9Hb29nbGVTdGFydEJpdHJhdGUsIHZpZGVvR29vZ2xlTWF4Qml0cmF0ZSwgdmlkZW9Hb29nbGVNaW5CaXRyYXRlLCB9ID0gY29kZWNPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2ZmZXJDb2RlYyA9IG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3MuZmluZCgoYykgPT4gYy5wYXlsb2FkVHlwZSA9PT0gY29kZWMucGF5bG9hZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXVkaW8vb3B1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXVkaW8vbXVsdGlvcHVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c1N0ZXJlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnNbJ3Nwcm9wLXN0ZXJlbyddID0gb3B1c1N0ZXJlbyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnN0ZXJlbyA9IG9wdXNTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c0ZlYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMudXNlaW5iYW5kZmVjID0gb3B1c0ZlYyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnVzZWluYmFuZGZlYyA9IG9wdXNGZWMgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c0R0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMudXNlZHR4ID0gb3B1c0R0eCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnVzZWR0eCA9IG9wdXNEdHggPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c01heFBsYXliYWNrUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnMubWF4cGxheWJhY2tyYXRlID0gb3B1c01heFBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c01heEF2ZXJhZ2VCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5tYXhhdmVyYWdlYml0cmF0ZSA9IG9wdXNNYXhBdmVyYWdlQml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c1B0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZmVyQ29kZWMucGFyYW1ldGVycy5wdGltZSA9IG9wdXNQdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5wdGltZSA9IG9wdXNQdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvcHVzTmFjayBpcyBub3Qgc2V0LCB3ZSBtdXN0IHJlbW92ZSBOQUNLIHN1cHBvcnQgZm9yIE9QVVMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCB3b3VsZCBiZSBlbmFibGVkIGZvciB0aG9zZSBoYW5kbGVycyB0aGF0IGFydGlmaWNpYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm5vdW5jZSBpdCBpbiB0aGVpciBSVFAgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdXNOYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnJ0Y3BGZWVkYmFjayA9IG9mZmVyQ29kZWMucnRjcEZlZWRiYWNrLmZpbHRlcihmYiA9PiBmYi50eXBlICE9PSAnbmFjaycgfHwgZmIucGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUnRjcEZlZWRiYWNrID0gY29kZWNSdGNwRmVlZGJhY2suZmlsdGVyKGZiID0+IGZiLnR5cGUgIT09ICduYWNrJyB8fCBmYi5wYXJhbWV0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aWRlby92cDgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZGVvL3ZwOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlkZW8vaDI2NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlkZW8vaDI2NSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvR29vZ2xlU3RhcnRCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtc3RhcnQtYml0cmF0ZSddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0dvb2dsZVN0YXJ0Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9Hb29nbGVNYXhCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtbWF4LWJpdHJhdGUnXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9Hb29nbGVNYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb0dvb2dsZU1pbkJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzWyd4LWdvb2dsZS1taW4tYml0cmF0ZSddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0dvb2dsZU1pbkJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZtdHAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogJycsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjUGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlY1BhcmFtZXRlcnNba2V5XX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cC5wdXNoKGZtdHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmIgb2YgY29kZWNSdGNwRmVlZGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGU6IGZiLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gYW5zd2VyUnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIGFuc3dlclJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgYSBoZWFkZXIgZXh0ZW5zaW9uIGlmIG5vdCBwcmVzZW50IGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSAob2ZmZXJNZWRpYU9iamVjdC5leHQgPz8gW10pLnNvbWUoKGxvY2FsRXh0KSA9PiBsb2NhbEV4dC51cmkgPT09IGV4dC51cmkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IGV4dC51cmksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXh0LmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgYm90aCAxIGJ5dGUgYW5kIDIgYnl0ZXMgbGVuZ3RoIGhlYWRlciBleHRlbnNpb25zLlxuICAgICAgICAgICAgICAgIGlmIChleHRtYXBBbGxvd01peGVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QuZXh0bWFwQWxsb3dNaXhlZCA9PT0gJ2V4dG1hcC1hbGxvdy1taXhlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZXh0bWFwQWxsb3dNaXhlZCA9ICdleHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW11bGNhc3QuXG4gICAgICAgICAgICAgICAgaWYgKG9mZmVyTWVkaWFPYmplY3Quc2ltdWxjYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcjE6ICdyZWN2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QxOiBvZmZlck1lZGlhT2JqZWN0LnNpbXVsY2FzdC5saXN0MSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucmlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJpZCBvZiBvZmZlck1lZGlhT2JqZWN0LnJpZHMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWQuZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJpZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbXVsY2FzdCAoZHJhZnQgdmVyc2lvbiAwMykuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmZXJNZWRpYU9iamVjdC5zaW11bGNhc3RfMDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0XzAzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyTWVkaWFPYmplY3Quc2ltdWxjYXN0XzAzLnZhbHVlLnJlcGxhY2UoL3NlbmQvZywgJ3JlY3YnKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucmlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJpZCBvZiBvZmZlck1lZGlhT2JqZWN0LnJpZHMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWQuZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJpZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BNdXggPSAncnRjcC1tdXgnO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BSc2l6ZSA9ICdydGNwLXJzaXplJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhbkIgJiYgdGhpcy5fbWVkaWFPYmplY3QudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC54R29vZ2xlRmxhZyA9ICdjb25mZXJlbmNlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbic6IHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgc3BlYy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZmVyTWVkaWFPYmplY3Quc2N0cFBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gJ3dlYnJ0Yy1kYXRhY2hhbm5lbCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNjdHBQb3J0ID0gc2N0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubWF4TWVzc2FnZVNpemUgPSBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT2xkIHNwZWMuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmZXJNZWRpYU9iamVjdC5zY3RwbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gc2N0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2N0cG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcDogJ3dlYnJ0Yy1kYXRhY2hhbm5lbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3RwbWFwTnVtYmVyOiBzY3RwUGFyYW1ldGVycy5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemU6IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXREdGxzUm9sZShyb2xlKSB7XG4gICAgICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgICAgICAgY2FzZSAnY2xpZW50Jzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNldHVwID0gJ2FjdGl2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzZXJ2ZXInOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAncGFzc2l2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhdXRvJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNldHVwID0gJ2FjdHBhc3MnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICB9XG4gICAgbXV4U2ltdWxjYXN0U3RyZWFtcyhlbmNvZGluZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3Q/Lmxpc3QxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5ZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcucmlkKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW2VuY29kaW5nLnJpZF0gPSBlbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXcgPSB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3QubGlzdDE7XG4gICAgICAgIGNvbnN0IHNpbXVsY2FzdFN0cmVhbXMgPSBzZHBUcmFuc2Zvcm0ucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0KHJhdyk7XG4gICAgICAgIGZvciAoY29uc3Qgc2ltdWxjYXN0U3RyZWFtIG9mIHNpbXVsY2FzdFN0cmVhbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2ltdWxjYXN0Rm9ybWF0IG9mIHNpbXVsY2FzdFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHNpbXVsY2FzdEZvcm1hdC5wYXVzZWQgPSAhbGF5ZXJzW3NpbXVsY2FzdEZvcm1hdC5zY2lkXT8uYWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdC5saXN0MSA9IHNpbXVsY2FzdFN0cmVhbXNcbiAgICAgICAgICAgIC5tYXAoc2ltdWxjYXN0Rm9ybWF0cyA9PiBzaW11bGNhc3RGb3JtYXRzLm1hcChmID0+IGAke2YucGF1c2VkID8gJ34nIDogJyd9JHtmLnNjaWR9YCkuam9pbignLCcpKVxuICAgICAgICAgICAgLmpvaW4oJzsnKTtcbiAgICB9XG59XG5leHBvcnRzLkFuc3dlck1lZGlhU2VjdGlvbiA9IEFuc3dlck1lZGlhU2VjdGlvbjtcbmNsYXNzIE9mZmVyTWVkaWFTZWN0aW9uIGV4dGVuZHMgTWVkaWFTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgcGxhaW5SdHBQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlLCBtaWQsIGtpbmQsIG9mZmVyUnRwUGFyYW1ldGVycywgc3RyZWFtSWQsIHRyYWNrSWQsIG9sZERhdGFDaGFubmVsU3BlYyA9IGZhbHNlLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHBsYW5CIH0pO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5taWQgPSBTdHJpbmcobWlkKTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QudHlwZSA9IGtpbmQ7XG4gICAgICAgIGlmICghcGxhaW5SdHBQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcbiAgICAgICAgICAgIGlmICghc2N0cFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdVRFAvVExTL1JUUC9TQVZQRic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdVRFAvRFRMUy9TQ1RQJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBpcDogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucHJvdG9jb2wgPSAnUlRQL0FWUCc7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wb3J0ID0gcGxhaW5SdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BsYW5CKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0Lm1zaWQgPSBgJHtzdHJlYW1JZCA/PyAnLSd9ICR7dHJhY2tJZH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnRwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlYzogZ2V0Q29kZWNOYW1lKGNvZGVjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGU6IGNvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVjLmNoYW5uZWxzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnRwLmVuY29kaW5nID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRwLnB1c2gocnRwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm10cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlYy5wYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm10cC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcEZiLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGZiLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZTogZmIucGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgPSBvZmZlclJ0cFBhcmFtZXRlcnMuY29kZWNzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGNvZGVjKSA9PiBjb2RlYy5wYXlsb2FkVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4dCBvZiBvZmZlclJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IGV4dC51cmksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXh0LmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcE11eCA9ICdydGNwLW11eCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcFJzaXplID0gJ3J0Y3AtcnNpemUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzc3JjID0gZW5jb2Rpbmcuc3NyYztcbiAgICAgICAgICAgICAgICBjb25zdCBydHhTc3JjID0gZW5jb2RpbmcucnR4Py5zc3JjO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYW5CKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCA/PyAnLSd9ICR7dHJhY2tJZH1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ0eFNzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYW5CKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWQgPz8gJy0nfSAke3RyYWNrSWR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBvcmlnaW5hbCBhbmQgcmV0cmFuc21pc3Npb24gU1NSQ3MuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbic6IHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgc3BlYy5cbiAgICAgICAgICAgICAgICBpZiAoIW9sZERhdGFDaGFubmVsU3BlYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9ICd3ZWJydGMtZGF0YWNoYW5uZWwnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zY3RwUG9ydCA9IHNjdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0Lm1heE1lc3NhZ2VTaXplID0gc2N0cFBhcmFtZXRlcnMubWF4TWVzc2FnZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9sZCBzcGVjLlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9IHNjdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNjdHBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHA6ICd3ZWJydGMtZGF0YWNoYW5uZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2N0cG1hcE51bWJlcjogc2N0cFBhcmFtZXRlcnMucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VTaXplOiBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHNldER0bHNSb2xlKHJvbGUpIHtcbiAgICAgICAgLy8gQWx3YXlzICdhY3RwYXNzJy5cbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAnYWN0cGFzcyc7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICB9XG4gICAgcGxhbkJSZWNlaXZlKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCwgfSkge1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IG9mZmVyUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG4gICAgICAgIGNvbnN0IHNzcmMgPSBlbmNvZGluZy5zc3JjO1xuICAgICAgICBjb25zdCBydHhTc3JjID0gZW5jb2RpbmcucnR4Py5zc3JjO1xuICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2Ygb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgICAgaWYgKHBheWxvYWRzLmluY2x1ZGVzKFN0cmluZyhjb2RlYy5wYXlsb2FkVHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydHAgPSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZWM6IGdldENvZGVjTmFtZShjb2RlYyksXG4gICAgICAgICAgICAgICAgcmF0ZTogY29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb2RlYy5jaGFubmVscyA+IDEpIHtcbiAgICAgICAgICAgICAgICBydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cC5wdXNoKHJ0cCk7XG4gICAgICAgICAgICBjb25zdCBmbXRwID0ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogJycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm10cC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJzsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBgJHtrZXl9PSR7Y29kZWMucGFyYW1ldGVyc1trZXldfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm10cC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5mbXRwLnB1c2goZm10cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGZiLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGU6IGZiLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyArPSBgICR7b2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjc1xuICAgICAgICAgICAgLmZpbHRlcigoY29kZWMpID0+ICF0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2Fkcy5pbmNsdWRlcyhjb2RlYy5wYXlsb2FkVHlwZSkpXG4gICAgICAgICAgICAubWFwKChjb2RlYykgPT4gY29kZWMucGF5bG9hZFR5cGUpXG4gICAgICAgICAgICAuam9pbignICcpfWA7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMudHJpbSgpO1xuICAgICAgICBpZiAob2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWQgPz8gJy0nfSAke3RyYWNrSWR9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydHhTc3JjKSB7XG4gICAgICAgICAgICBpZiAob2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkID8/ICctJ30gJHt0cmFja0lkfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBvcmlnaW5hbCBhbmQgcmV0cmFuc21pc3Npb24gU1NSQ3MuXG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlbWFudGljczogJ0ZJRCcsXG4gICAgICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxhbkJTdG9wUmVjZWl2aW5nKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzLCB9KSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcbiAgICAgICAgY29uc3Qgc3NyYyA9IGVuY29kaW5nLnNzcmM7XG4gICAgICAgIGNvbnN0IHJ0eFNzcmMgPSBlbmNvZGluZy5ydHg/LnNzcmM7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzID0gdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MuZmlsdGVyKChzKSA9PiBzLmlkICE9PSBzc3JjICYmIHMuaWQgIT09IHJ0eFNzcmMpO1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcyA9IHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHMuZmlsdGVyKChncm91cCkgPT4gZ3JvdXAuc3NyY3MgIT09IGAke3NzcmN9ICR7cnR4U3NyY31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT2ZmZXJNZWRpYVNlY3Rpb24gPSBPZmZlck1lZGlhU2VjdGlvbjtcbmZ1bmN0aW9uIGdldENvZGVjTmFtZShjb2RlYykge1xuICAgIGNvbnN0IE1pbWVUeXBlUmVnZXggPSBuZXcgUmVnRXhwKCdeKGF1ZGlvfHZpZGVvKS8oLispJywgJ2knKTtcbiAgICBjb25zdCBtaW1lVHlwZU1hdGNoID0gTWltZVR5cGVSZWdleC5leGVjKGNvZGVjLm1pbWVUeXBlKTtcbiAgICBpZiAoIW1pbWVUeXBlTWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjb2RlYy5taW1lVHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gbWltZVR5cGVNYXRjaFsyXTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlbW90ZVNkcCA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9Mb2dnZXJcIik7XG5jb25zdCBNZWRpYVNlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL01lZGlhU2VjdGlvblwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1JlbW90ZVNkcCcpO1xuY2xhc3MgUmVtb3RlU2RwIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgcGxhaW5SdHBQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlLCB9KSB7XG4gICAgICAgIC8vIE1lZGlhU2VjdGlvbiBpbnN0YW5jZXMgd2l0aCBzYW1lIG9yZGVyIGFzIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgLy8gTWVkaWFTZWN0aW9uIGluZGljZXMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21pZFRvSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2ljZVBhcmFtZXRlcnMgPSBpY2VQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9pY2VDYW5kaWRhdGVzID0gaWNlQ2FuZGlkYXRlcztcbiAgICAgICAgdGhpcy5fZHRsc1BhcmFtZXRlcnMgPSBkdGxzUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fc2N0cFBhcmFtZXRlcnMgPSBzY3RwUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fcGxhaW5SdHBQYXJhbWV0ZXJzID0gcGxhaW5SdHBQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9wbGFuQiA9IHBsYW5CO1xuICAgICAgICB0aGlzLl9zZHBPYmplY3QgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgb3JpZ2luOiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogJzAuMC4wLjAnLFxuICAgICAgICAgICAgICAgIGlwVmVyOiA0LFxuICAgICAgICAgICAgICAgIG5ldFR5cGU6ICdJTicsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiAxMDAwMCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uVmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogJ21lZGlhc291cC1jbGllbnQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6ICctJyxcbiAgICAgICAgICAgIHRpbWluZzogeyBzdGFydDogMCwgc3RvcDogMCB9LFxuICAgICAgICAgICAgbWVkaWE6IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBJQ0UgcGFyYW1ldGVycyBhcmUgZ2l2ZW4sIGFkZCBJQ0UtTGl0ZSBpbmRpY2F0b3IuXG4gICAgICAgIGlmIChpY2VQYXJhbWV0ZXJzPy5pY2VMaXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QuaWNlbGl0ZSA9ICdpY2UtbGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgRFRMUyBwYXJhbWV0ZXJzIGFyZSBnaXZlbiwgYXNzdW1lIFdlYlJUQyBhbmQgQlVORExFLlxuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5tc2lkU2VtYW50aWMgPSB7IHNlbWFudGljOiAnV01TJywgdG9rZW46ICcqJyB9O1xuICAgICAgICAgICAgLy8gTk9URTogV2UgdGFrZSB0aGUgbGF0ZXN0IGZpbmdlcnByaW50LlxuICAgICAgICAgICAgY29uc3QgbnVtRmluZ2VycHJpbnRzID0gdGhpcy5fZHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5maW5nZXJwcmludCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0uYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgIGhhc2g6IGR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS52YWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QuZ3JvdXBzID0gW3sgdHlwZTogJ0JVTkRMRScsIG1pZHM6ICcnIH1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBwbGFpbiBSUFQgcGFyYW1ldGVycywgb3ZlcnJpZGUgU0RQIG9yaWdpbi5cbiAgICAgICAgaWYgKHBsYWluUnRwUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5hZGRyZXNzID0gcGxhaW5SdHBQYXJhbWV0ZXJzLmlwO1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5pcFZlciA9IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlUGFyYW1ldGVycygpIFtpY2VQYXJhbWV0ZXJzOiVvXScsIGljZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9pY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0LmljZWxpdGUgPSBpY2VQYXJhbWV0ZXJzLmljZUxpdGUgPyAnaWNlLWxpdGUnIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG1lZGlhU2VjdGlvbiBvZiB0aGlzLl9tZWRpYVNlY3Rpb25zKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24uc2V0SWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEdGxzUm9sZShyb2xlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlRHRsc1JvbGUoKSBbcm9sZTolc10nLCByb2xlKTtcbiAgICAgICAgdGhpcy5fZHRsc1BhcmFtZXRlcnMucm9sZSA9IHJvbGU7XG4gICAgICAgIGZvciAoY29uc3QgbWVkaWFTZWN0aW9uIG9mIHRoaXMuX21lZGlhU2VjdGlvbnMpIHtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbi5zZXREdGxzUm9sZShyb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROZXh0TWVkaWFTZWN0aW9uSWR4KCkge1xuICAgICAgICAvLyBJZiBhIGNsb3NlZCBtZWRpYSBzZWN0aW9uIGlzIGZvdW5kLCByZXR1cm4gaXRzIGluZGV4LlxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9tZWRpYVNlY3Rpb25zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIGlmIChtZWRpYVNlY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaWR4LCByZXVzZU1pZDogbWVkaWFTZWN0aW9uLm1pZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGNsb3NlZCBtZWRpYSBzZWN0aW9uIGlzIGZvdW5kLCByZXR1cm4gbmV4dCBvbmUuXG4gICAgICAgIHJldHVybiB7IGlkeDogdGhpcy5fbWVkaWFTZWN0aW9ucy5sZW5ndGggfTtcbiAgICB9XG4gICAgc2VuZCh7IG9mZmVyTWVkaWFPYmplY3QsIHJldXNlTWlkLCBvZmZlclJ0cFBhcmFtZXRlcnMsIGFuc3dlclJ0cFBhcmFtZXRlcnMsIGNvZGVjT3B0aW9ucywgZXh0bWFwQWxsb3dNaXhlZCA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IG5ldyBNZWRpYVNlY3Rpb25fMS5BbnN3ZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0aGlzLl9wbGFuQixcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICAgICAgZXh0bWFwQWxsb3dNaXhlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVuaWZpZWQtUGxhbiB3aXRoIGNsb3NlZCBtZWRpYSBzZWN0aW9uIHJlcGxhY2VtZW50LlxuICAgICAgICBpZiAocmV1c2VNaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uLCByZXVzZU1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5pZmllZC1QbGFuIG9yIFBsYW4tQiB3aXRoIGRpZmZlcmVudCBtZWRpYSBraW5kLlxuICAgICAgICBlbHNlIGlmICghdGhpcy5fbWlkVG9JbmRleC5oYXMobWVkaWFTZWN0aW9uLm1pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBsYW4tQiB3aXRoIHNhbWUgbWVkaWEga2luZC5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjZWl2ZSh7IG1pZCwga2luZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCwgfSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChtaWQpO1xuICAgICAgICBsZXQgbWVkaWFTZWN0aW9uO1xuICAgICAgICBpZiAoaWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmlmaWVkLVBsYW4gb3IgZGlmZmVyZW50IG1lZGlhIGtpbmQuXG4gICAgICAgIGlmICghbWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IHRoaXMuX2ljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogdGhpcy5faWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhaW5SdHBQYXJhbWV0ZXJzOiB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhbkI6IHRoaXMuX3BsYW5CLFxuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgdG8gcmVjeWNsZSBhIGNsb3NlZCBtZWRpYSBzZWN0aW9uIChpZiBhbnkpLlxuICAgICAgICAgICAgLy8gTk9URTogWWVzLCB3ZSBjYW4gcmVjeWNsZSBhIGNsb3NlZCBtPWF1ZGlvIHNlY3Rpb24gd2l0aCBhIG5ldyBtPXZpZGVvLlxuICAgICAgICAgICAgY29uc3Qgb2xkTWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9ucy5maW5kKG0gPT4gbS5jbG9zZWQpO1xuICAgICAgICAgICAgaWYgKG9sZE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uLCBvbGRNZWRpYVNlY3Rpb24ubWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBsYW4tQi5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24ucGxhbkJSZWNlaXZlKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZU1lZGlhU2VjdGlvbihtaWQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgcmVzdW1lU2VuZGluZ01lZGlhU2VjdGlvbihtaWQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucmVzdW1lKCk7XG4gICAgfVxuICAgIHJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihtaWQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucmVzdW1lKCk7XG4gICAgfVxuICAgIGRpc2FibGVNZWRpYVNlY3Rpb24obWlkKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX2ZpbmRNZWRpYVNlY3Rpb24obWlkKTtcbiAgICAgICAgbWVkaWFTZWN0aW9uLmRpc2FibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIG1lZGlhIHNlY3Rpb24uIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlEIGNvcnJlc3BvbmRzIHRvIGEgbVxuICAgICAqIHNlY3Rpb24gdGhhdCBoYXMgYmVlbiBpbmRlZWQgY2xvc2VkLiBGYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDbG9zaW5nIHRoZSBmaXJzdCBtIHNlY3Rpb24gaXMgYSBwYWluIHNpbmNlIGl0IGludmFsaWRhdGVzIHRoZSBidW5kbGVkXG4gICAgICogdHJhbnNwb3J0LCBzbyBpbnN0ZWFkIGNsb3NpbmcgaXQgd2UganVzdCBkaXNhYmxlIGl0LlxuICAgICAqL1xuICAgIGNsb3NlTWVkaWFTZWN0aW9uKG1pZCkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSB0aGlzLl9maW5kTWVkaWFTZWN0aW9uKG1pZCk7XG4gICAgICAgIC8vIE5PVEU6IENsb3NpbmcgdGhlIGZpcnN0IG0gc2VjdGlvbiBpcyBhIHBhaW4gc2luY2UgaXQgaW52YWxpZGF0ZXMgdGhlXG4gICAgICAgIC8vIGJ1bmRsZWQgdHJhbnNwb3J0LCBzbyBsZXQncyBhdm9pZCBpdC5cbiAgICAgICAgaWYgKG1pZCA9PT0gdGhpcy5fZmlyc3RNaWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2VNZWRpYVNlY3Rpb24oKSB8IGNhbm5vdCBjbG9zZSBmaXJzdCBtZWRpYSBzZWN0aW9uLCBkaXNhYmxpbmcgaXQgaW5zdGVhZCBbbWlkOiVzXScsIG1pZCk7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVNZWRpYVNlY3Rpb24obWlkKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYVNlY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgLy8gUmVnZW5lcmF0ZSBCVU5ETEUgbWlkcy5cbiAgICAgICAgdGhpcy5fcmVnZW5lcmF0ZUJ1bmRsZU1pZHMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChtaWQsIGVuY29kaW5ncykge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSB0aGlzLl9maW5kTWVkaWFTZWN0aW9uKG1pZCk7XG4gICAgICAgIG1lZGlhU2VjdGlvbi5tdXhTaW11bGNhc3RTdHJlYW1zKGVuY29kaW5ncyk7XG4gICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgcGxhbkJTdG9wUmVjZWl2aW5nKHsgbWlkLCBvZmZlclJ0cFBhcmFtZXRlcnMsIH0pIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucGxhbkJTdG9wUmVjZWl2aW5nKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICB0aGlzLl9yZXBsYWNlTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgfVxuICAgIHNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gbmV3IE1lZGlhU2VjdGlvbl8xLkFuc3dlck1lZGlhU2VjdGlvbih7XG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzOiB0aGlzLl9pY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogdGhpcy5faWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzOiB0aGlzLl9kdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzOiB0aGlzLl9zY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYWluUnRwUGFyYW1ldGVyczogdGhpcy5fcGxhaW5SdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgIH1cbiAgICByZWNlaXZlU2N0cEFzc29jaWF0aW9uKHsgb2xkRGF0YUNoYW5uZWxTcGVjID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyczogdGhpcy5fc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG1pZDogJ2RhdGFjaGFubmVsJyxcbiAgICAgICAgICAgIGtpbmQ6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgICBvbGREYXRhQ2hhbm5lbFNwZWMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hZGRNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0U2RwKCkge1xuICAgICAgICAvLyBJbmNyZWFzZSBTRFAgdmVyc2lvbi5cbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5zZXNzaW9uVmVyc2lvbisrO1xuICAgICAgICByZXR1cm4gc2RwVHJhbnNmb3JtLndyaXRlKHRoaXMuX3NkcE9iamVjdCk7XG4gICAgfVxuICAgIF9hZGRNZWRpYVNlY3Rpb24obmV3TWVkaWFTZWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlyc3RNaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWlkID0gbmV3TWVkaWFTZWN0aW9uLm1pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdG8gdGhlIHZlY3Rvci5cbiAgICAgICAgdGhpcy5fbWVkaWFTZWN0aW9ucy5wdXNoKG5ld01lZGlhU2VjdGlvbik7XG4gICAgICAgIC8vIEFkZCB0byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9taWRUb0luZGV4LnNldChuZXdNZWRpYVNlY3Rpb24ubWlkLCB0aGlzLl9tZWRpYVNlY3Rpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgICAvLyBBZGQgdG8gdGhlIFNEUCBvYmplY3QuXG4gICAgICAgIHRoaXMuX3NkcE9iamVjdC5tZWRpYS5wdXNoKG5ld01lZGlhU2VjdGlvbi5nZXRPYmplY3QoKSk7XG4gICAgICAgIC8vIFJlZ2VuZXJhdGUgQlVORExFIG1pZHMuXG4gICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVCdW5kbGVNaWRzKCk7XG4gICAgfVxuICAgIF9yZXBsYWNlTWVkaWFTZWN0aW9uKG5ld01lZGlhU2VjdGlvbiwgcmV1c2VNaWQpIHtcbiAgICAgICAgLy8gU3RvcmUgaXQgaW4gdGhlIG1hcC5cbiAgICAgICAgaWYgKHR5cGVvZiByZXVzZU1pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX21pZFRvSW5kZXguZ2V0KHJldXNlTWlkKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCBmb3IgcmV1c2VNaWQgJyR7cmV1c2VNaWR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkTWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9uc1tpZHhdO1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgaW5kZXggaW4gdGhlIHZlY3RvciB3aXRoIHRoZSBuZXcgbWVkaWEgc2VjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XSA9IG5ld01lZGlhU2VjdGlvbjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWlkVG9JbmRleC5kZWxldGUob2xkTWVkaWFTZWN0aW9uLm1pZCk7XG4gICAgICAgICAgICB0aGlzLl9taWRUb0luZGV4LnNldChuZXdNZWRpYVNlY3Rpb24ubWlkLCBpZHgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBTRFAgb2JqZWN0LlxuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm1lZGlhW2lkeF0gPSBuZXdNZWRpYVNlY3Rpb24uZ2V0T2JqZWN0KCk7XG4gICAgICAgICAgICAvLyBSZWdlbmVyYXRlIEJVTkRMRSBtaWRzLlxuICAgICAgICAgICAgdGhpcy5fcmVnZW5lcmF0ZUJ1bmRsZU1pZHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX21pZFRvSW5kZXguZ2V0KG5ld01lZGlhU2VjdGlvbi5taWQpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBtZWRpYSBzZWN0aW9uIGZvdW5kIHdpdGggbWlkICcke25ld01lZGlhU2VjdGlvbi5taWR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgaW5kZXggaW4gdGhlIHZlY3RvciB3aXRoIHRoZSBuZXcgbWVkaWEgc2VjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XSA9IG5ld01lZGlhU2VjdGlvbjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgU0RQIG9iamVjdC5cbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5tZWRpYVtpZHhdID0gbmV3TWVkaWFTZWN0aW9uLmdldE9iamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9maW5kTWVkaWFTZWN0aW9uKG1pZCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChtaWQpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCB3aXRoIG1pZCAnJHttaWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF07XG4gICAgfVxuICAgIF9yZWdlbmVyYXRlQnVuZGxlTWlkcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kdGxzUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NkcE9iamVjdC5ncm91cHNbMF0ubWlkcyA9IHRoaXMuX21lZGlhU2VjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKG1lZGlhU2VjdGlvbikgPT4gIW1lZGlhU2VjdGlvbi5jbG9zZWQpXG4gICAgICAgICAgICAubWFwKChtZWRpYVNlY3Rpb24pID0+IG1lZGlhU2VjdGlvbi5taWQpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU2RwID0gUmVtb3RlU2RwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyA9IGV4dHJhY3RSdHBDYXBhYmlsaXRpZXM7XG5leHBvcnRzLmV4dHJhY3REdGxzUGFyYW1ldGVycyA9IGV4dHJhY3REdGxzUGFyYW1ldGVycztcbmV4cG9ydHMuZ2V0Q25hbWUgPSBnZXRDbmFtZTtcbmV4cG9ydHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMgPSBhcHBseUNvZGVjUGFyYW1ldGVycztcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBTRFAgd2l0aCAxIG09YXVkaW8gYW5kIDEgbT12aWRlb1xuICogc2VjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QsIH0pIHtcbiAgICAvLyBNYXAgb2YgUnRwQ29kZWNQYXJhbWV0ZXJzIGluZGV4ZWQgYnkgcGF5bG9hZCB0eXBlLlxuICAgIGNvbnN0IGNvZGVjc01hcCA9IG5ldyBNYXAoKTtcbiAgICAvLyBBcnJheSBvZiBSdHBIZWFkZXJFeHRlbnNpb25zLlxuICAgIGNvbnN0IGhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICAvLyBXaGV0aGVyIGEgbT1hdWRpby92aWRlbyBzZWN0aW9uIGhhcyBiZWVuIGFscmVhZHkgZm91bmQuXG4gICAgbGV0IGdvdEF1ZGlvID0gZmFsc2U7XG4gICAgbGV0IGdvdFZpZGVvID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtIG9mIHNkcE9iamVjdC5tZWRpYSkge1xuICAgICAgICBjb25zdCBraW5kID0gbS50eXBlO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzoge1xuICAgICAgICAgICAgICAgIGlmIChnb3RBdWRpbykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ290QXVkaW8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndmlkZW8nOiB7XG4gICAgICAgICAgICAgICAgaWYgKGdvdFZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnb3RWaWRlbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGNvZGVjcy5cbiAgICAgICAgZm9yIChjb25zdCBydHAgb2YgbS5ydHApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IGAke2tpbmR9LyR7cnRwLmNvZGVjfWAsXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IHJ0cC5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIGNsb2NrUmF0ZTogcnRwLnJhdGUsXG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IHJ0cC5lbmNvZGluZyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvZGVjc01hcC5zZXQoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsIGNvZGVjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgY29kZWMgcGFyYW1ldGVycy5cbiAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG0uZm10cCB8fCBbXSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHNkcFRyYW5zZm9ybS5wYXJzZVBhcmFtcyhmbXRwLmNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc01hcC5nZXQoZm10cC5wYXlsb2FkKTtcbiAgICAgICAgICAgIGlmICghY29kZWMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNwZWNpYWxzIGNhc2UgdG8gY29udmVydCBwYXJhbWV0ZXIgdmFsdWUgdG8gc3RyaW5nLlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnM/Lmhhc093blByb3BlcnR5KCdwcm9maWxlLWxldmVsLWlkJykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ10gPSBTdHJpbmcocGFyYW1ldGVyc1sncHJvZmlsZS1sZXZlbC1pZCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBSVENQIGZlZWRiYWNrIGZvciBlYWNoIGNvZGVjLlxuICAgICAgICBmb3IgKGNvbnN0IGZiIG9mIG0ucnRjcEZiIHx8IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcjogZmIuc3VidHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWZlZWRiYWNrLnBhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmZWVkYmFjay5wYXJhbWV0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBydGNwLWZiIHBheWxvYWQgaXMgbm90ICcqJywgc28ganVzdCBhcHBseSBpdCB0byBpdHMgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgLy8gY29kZWMuXG4gICAgICAgICAgICBpZiAoZmIucGF5bG9hZCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWMgPSBjb2RlY3NNYXAuZ2V0KGZiLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmICghY29kZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5wdXNoKGZlZWRiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHJ0Y3AtZmIgcGF5bG9hZCBpcyAnKicgaXQgbXVzdCBiZSBhcHBsaWVkIHRvIGFsbCBjb2RlY3Mgd2l0aCBzYW1lXG4gICAgICAgICAgICAvLyBraW5kICh3aXRoIHNvbWUgZXhjZXB0aW9ucyBzdWNoIGFzIFJUWCBjb2RlYykuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNvZGVjc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWMua2luZCA9PT0ga2luZCAmJiAhLy4rXFwvcnR4JC9pLnRlc3QoY29kZWMubWltZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmZWVkYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFJUUCBoZWFkZXIgZXh0ZW5zaW9ucy5cbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgbS5leHQgfHwgW10pIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbmNyeXB0ZWQgZXh0ZW5zaW9ucyAobm90IHlldCBzdXBwb3J0ZWQgaW4gbWVkaWFzb3VwKS5cbiAgICAgICAgICAgIGlmIChleHRbJ2VuY3J5cHQtdXJpJ10pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgIHVyaTogZXh0LnVyaSxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRJZDogZXh0LnZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlckV4dGVuc2lvbnMucHVzaChoZWFkZXJFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBBcnJheS5mcm9tKGNvZGVjc01hcC52YWx1ZXMoKSksXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IGhlYWRlckV4dGVuc2lvbnMsXG4gICAgfTtcbiAgICByZXR1cm4gcnRwQ2FwYWJpbGl0aWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0LCB9KSB7XG4gICAgbGV0IHNldHVwID0gc2RwT2JqZWN0LnNldHVwO1xuICAgIGxldCBmaW5nZXJwcmludCA9IHNkcE9iamVjdC5maW5nZXJwcmludDtcbiAgICBpZiAoIXNldHVwIHx8ICFmaW5nZXJwcmludCkge1xuICAgICAgICBjb25zdCBtZWRpYU9iamVjdCA9IChzZHBPYmplY3QubWVkaWEgfHwgW10pLmZpbmQoKG0pID0+IG0ucG9ydCAhPT0gMCk7XG4gICAgICAgIGlmIChtZWRpYU9iamVjdCkge1xuICAgICAgICAgICAgc2V0dXAgPz8gKHNldHVwID0gbWVkaWFPYmplY3Quc2V0dXApO1xuICAgICAgICAgICAgZmluZ2VycHJpbnQgPz8gKGZpbmdlcnByaW50ID0gbWVkaWFPYmplY3QuZmluZ2VycHJpbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2V0dXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBhPXNldHVwIGZvdW5kIGF0IFNEUCBzZXNzaW9uIG9yIG1lZGlhIGxldmVsJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFmaW5nZXJwcmludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGE9ZmluZ2VycHJpbnQgZm91bmQgYXQgU0RQIHNlc3Npb24gb3IgbWVkaWEgbGV2ZWwnKTtcbiAgICB9XG4gICAgbGV0IHJvbGU7XG4gICAgc3dpdGNoIChzZXR1cCkge1xuICAgICAgICBjYXNlICdhY3RpdmUnOiB7XG4gICAgICAgICAgICByb2xlID0gJ2NsaWVudCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXNzaXZlJzoge1xuICAgICAgICAgICAgcm9sZSA9ICdzZXJ2ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYWN0cGFzcyc6IHtcbiAgICAgICAgICAgIHJvbGUgPSAnYXV0byc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHtcbiAgICAgICAgcm9sZSxcbiAgICAgICAgZmluZ2VycHJpbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBmaW5nZXJwcmludC50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmaW5nZXJwcmludC5oYXNoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIHJldHVybiBkdGxzUGFyYW1ldGVycztcbn1cbmZ1bmN0aW9uIGdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCwgfSkge1xuICAgIGNvbnN0IHNzcmNDbmFtZUxpbmUgPSAob2ZmZXJNZWRpYU9iamVjdC5zc3JjcyB8fCBbXSkuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgIGlmICghc3NyY0NuYW1lTGluZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzc3JjQ25hbWVMaW5lLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBnaXZlbiBTRFAgbT0gc2VjdGlvbiBhbnN3ZXIgYmFzZWQgb24gdGhlXG4gKiBnaXZlbiBSVFAgcGFyYW1ldGVycyBvZiBhbiBvZmZlci5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDb2RlY1BhcmFtZXRlcnMoeyBvZmZlclJ0cFBhcmFtZXRlcnMsIGFuc3dlck1lZGlhT2JqZWN0LCB9KSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBvZmZlclJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gY29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gQXZvaWQgcGFyc2luZyBjb2RlYyBwYXJhbWV0ZXJzIGZvciB1bmhhbmRsZWQgY29kZWNzLlxuICAgICAgICBpZiAobWltZVR5cGUgIT09ICdhdWRpby9vcHVzJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnRwID0gKGFuc3dlck1lZGlhT2JqZWN0LnJ0cCB8fCBbXSkuZmluZCgocikgPT4gci5wYXlsb2FkID09PSBjb2RlYy5wYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmICghcnRwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKdXN0IGluIGNhc2UuXG4gICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LmZtdHAgPSBhbnN3ZXJNZWRpYU9iamVjdC5mbXRwIHx8IFtdO1xuICAgICAgICBsZXQgZm10cCA9IGFuc3dlck1lZGlhT2JqZWN0LmZtdHAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBjb2RlYy5wYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmICghZm10cCkge1xuICAgICAgICAgICAgZm10cCA9IHsgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsIGNvbmZpZzogJycgfTtcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgc3dpdGNoIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8vb3B1cyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJvcFN0ZXJlbyA9IGNvZGVjLnBhcmFtZXRlcnNbJ3Nwcm9wLXN0ZXJlbyddO1xuICAgICAgICAgICAgICAgIGlmIChzcHJvcFN0ZXJlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RlcmVvID0gTnVtYmVyKHNwcm9wU3RlcmVvKSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSB0aGUgY29kZWMgZm10cC5jb25maWcgYmFjay5cbiAgICAgICAgZm10cC5jb25maWcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtwYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdHBFbmNvZGluZ3MgPSBnZXRSdHBFbmNvZGluZ3M7XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGFkZExlZ2FjeVNpbXVsY2FzdDtcbmZ1bmN0aW9uIGdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrLCB9KSB7XG4gICAgLy8gRmlyc3QgbWVkaWEgU1NSQyAob3IgdGhlIG9ubHkgb25lKS5cbiAgICBsZXQgZmlyc3RTc3JjO1xuICAgIGNvbnN0IHNzcmNzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBvZmZlck1lZGlhT2JqZWN0LnNzcmNzIHx8IFtdKSB7XG4gICAgICAgIGlmIChsaW5lLmF0dHJpYnV0ZSAhPT0gJ21zaWQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFja0lkID0gbGluZS52YWx1ZS5zcGxpdCgnICcpWzFdO1xuICAgICAgICBpZiAodHJhY2tJZCA9PT0gdHJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNzcmMgPSBsaW5lLmlkO1xuICAgICAgICAgICAgc3NyY3MuYWRkKHNzcmMpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdFNzcmMpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFNzcmMgPSBzc3JjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzc3Jjcy5zaXplID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG4gICAgfVxuICAgIGNvbnN0IHNzcmNUb1J0eFNzcmMgPSBuZXcgTWFwKCk7XG4gICAgLy8gRmlyc3QgYXNzdW1lIFJUWCBpcyB1c2VkLlxuICAgIGZvciAoY29uc3QgbGluZSBvZiBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgfHwgW10pIHtcbiAgICAgICAgaWYgKGxpbmUuc2VtYW50aWNzICE9PSAnRklEJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtzc3JjLCBydHhTc3JjXSA9IGxpbmUuc3NyY3Muc3BsaXQoL1xccysvKTtcbiAgICAgICAgc3NyYyA9IE51bWJlcihzc3JjKTtcbiAgICAgICAgcnR4U3NyYyA9IE51bWJlcihydHhTc3JjKTtcbiAgICAgICAgaWYgKHNzcmNzLmhhcyhzc3JjKSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGJvdGggdGhlIFNTUkMgYW5kIFJUWCBTU1JDIGZyb20gdGhlIHNldCBzbyBsYXRlciB3ZSBrbm93IHRoYXQgdGhleVxuICAgICAgICAgICAgLy8gYXJlIGFscmVhZHkgaGFuZGxlZC5cbiAgICAgICAgICAgIHNzcmNzLmRlbGV0ZShzc3JjKTtcbiAgICAgICAgICAgIHNzcmNzLmRlbGV0ZShydHhTc3JjKTtcbiAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgbWFwLlxuICAgICAgICAgICAgc3NyY1RvUnR4U3NyYy5zZXQoc3NyYywgcnR4U3NyYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNldCBvZiBTU1JDcyBpcyBub3QgZW1wdHkgaXQgbWVhbnMgdGhhdCBSVFggaXMgbm90IGJlaW5nIHVzZWQsIHNvIHRha2VcbiAgICAvLyBtZWRpYSBTU1JDcyBmcm9tIHRoZXJlLlxuICAgIGZvciAoY29uc3Qgc3NyYyBvZiBzc3Jjcykge1xuICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgc3NyY1RvUnR4U3NyYy5zZXQoc3NyYywgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3NzcmMsIHJ0eFNzcmNdIG9mIHNzcmNUb1J0eFNzcmMpIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSB7IHNzcmMgfTtcbiAgICAgICAgaWYgKHJ0eFNzcmMpIHtcbiAgICAgICAgICAgIGVuY29kaW5nLnJ0eCA9IHsgc3NyYzogcnR4U3NyYyB9O1xuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5ncztcbn1cbi8qKlxuICogQWRkcyBtdWx0aS1zc3JjIGJhc2VkIHNpbXVsY2FzdCBpbnRvIHRoZSBnaXZlbiBTRFAgbWVkaWEgc2VjdGlvbiBvZmZlci5cbiAqL1xuZnVuY3Rpb24gYWRkTGVnYWN5U2ltdWxjYXN0KHsgb2ZmZXJNZWRpYU9iamVjdCwgdHJhY2ssIG51bVN0cmVhbXMsIH0pIHtcbiAgICBpZiAobnVtU3RyZWFtcyA8PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ251bVN0cmVhbXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgIH1cbiAgICBsZXQgZmlyc3RTc3JjO1xuICAgIGxldCBmaXJzdFJ0eFNzcmM7XG4gICAgbGV0IHN0cmVhbUlkO1xuICAgIC8vIEdldCB0aGUgU1NSQy5cbiAgICBjb25zdCBzc3JjTXNpZExpbmUgPSAob2ZmZXJNZWRpYU9iamVjdC5zc3JjcyB8fCBbXSkuZmluZCgobGluZSkgPT4ge1xuICAgICAgICBpZiAobGluZS5hdHRyaWJ1dGUgIT09ICdtc2lkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrSWQgPSBsaW5lLnZhbHVlLnNwbGl0KCcgJylbMV07XG4gICAgICAgIGlmICh0cmFja0lkID09PSB0cmFjay5pZCkge1xuICAgICAgICAgICAgZmlyc3RTc3JjID0gbGluZS5pZDtcbiAgICAgICAgICAgIHN0cmVhbUlkID0gbGluZS52YWx1ZS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXNzcmNNc2lkTGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGE9c3NyYyBsaW5lIHdpdGggbXNpZCBpbmZvcm1hdGlvbiBub3QgZm91bmQgW3RyYWNrLmlkOiR7dHJhY2suaWR9XWApO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIFNTUkMgZm9yIFJUWC5cbiAgICAob2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdKS5zb21lKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzc3JjcyA9IGxpbmUuc3NyY3Muc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKE51bWJlcihzc3Jjc1swXSkgPT09IGZpcnN0U3NyYykge1xuICAgICAgICAgICAgZmlyc3RSdHhTc3JjID0gTnVtYmVyKHNzcmNzWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3NyY0NuYW1lTGluZSA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3MuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScgJiYgbGluZS5pZCA9PT0gZmlyc3RTc3JjKTtcbiAgICBpZiAoIXNzcmNDbmFtZUxpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhPXNzcmMgbGluZSB3aXRoIGNuYW1lIGluZm9ybWF0aW9uIG5vdCBmb3VuZCBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG4gICAgfVxuICAgIGNvbnN0IGNuYW1lID0gc3NyY0NuYW1lTGluZS52YWx1ZTtcbiAgICBjb25zdCBzc3JjcyA9IFtdO1xuICAgIGNvbnN0IHJ0eFNzcmNzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TdHJlYW1zOyArK2kpIHtcbiAgICAgICAgc3NyY3MucHVzaChmaXJzdFNzcmMgKyBpKTtcbiAgICAgICAgaWYgKGZpcnN0UnR4U3NyYykge1xuICAgICAgICAgICAgcnR4U3NyY3MucHVzaChmaXJzdFJ0eFNzcmMgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgfHwgW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjcyA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICBzZW1hbnRpY3M6ICdTSU0nLFxuICAgICAgICBzc3Jjczogc3NyY3Muam9pbignICcpLFxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgc3NyYyBvZiBzc3Jjcykge1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogY25hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFjay5pZH1gLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydHhTc3Jjcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzc3JjID0gc3NyY3NbaV07XG4gICAgICAgIGNvbnN0IHJ0eFNzcmMgPSBydHhTc3Jjc1tpXTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgdmFsdWU6IGNuYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWR9ICR7dHJhY2suaWR9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgIHNlbWFudGljczogJ0ZJRCcsXG4gICAgICAgICAgICBzc3JjczogYCR7c3NyY30gJHtydHhTc3JjfWAsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdHBFbmNvZGluZ3MgPSBnZXRSdHBFbmNvZGluZ3M7XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGFkZExlZ2FjeVNpbXVsY2FzdDtcbmZ1bmN0aW9uIGdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIH0pIHtcbiAgICBjb25zdCBzc3JjcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb2ZmZXJNZWRpYU9iamVjdC5zc3JjcyB8fCBbXSkge1xuICAgICAgICBjb25zdCBzc3JjID0gbGluZS5pZDtcbiAgICAgICAgc3NyY3MuYWRkKHNzcmMpO1xuICAgIH1cbiAgICBpZiAoc3NyY3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGE9c3NyYyBsaW5lcyBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBzc3JjVG9SdHhTc3JjID0gbmV3IE1hcCgpO1xuICAgIC8vIEZpcnN0IGFzc3VtZSBSVFggaXMgdXNlZC5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdKSB7XG4gICAgICAgIGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbc3NyYywgcnR4U3NyY10gPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHNzcmMgPSBOdW1iZXIoc3NyYyk7XG4gICAgICAgIHJ0eFNzcmMgPSBOdW1iZXIocnR4U3NyYyk7XG4gICAgICAgIGlmIChzc3Jjcy5oYXMoc3NyYykpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBib3RoIHRoZSBTU1JDIGFuZCBSVFggU1NSQyBmcm9tIHRoZSBzZXQgc28gbGF0ZXIgd2Uga25vd1xuICAgICAgICAgICAgLy8gdGhhdCB0aGV5IGFyZSBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUoc3NyYyk7XG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUocnR4U3NyYyk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIHJ0eFNzcmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzZXQgb2YgU1NSQ3MgaXMgbm90IGVtcHR5IGl0IG1lYW5zIHRoYXQgUlRYIGlzIG5vdCBiZWluZyB1c2VkLCBzb1xuICAgIC8vIHRha2UgbWVkaWEgU1NSQ3MgZnJvbSB0aGVyZS5cbiAgICBmb3IgKGNvbnN0IHNzcmMgb2Ygc3NyY3MpIHtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzc3JjLCBydHhTc3JjXSBvZiBzc3JjVG9SdHhTc3JjKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0geyBzc3JjIH07XG4gICAgICAgIGlmIChydHhTc3JjKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5ydHggPSB7IHNzcmM6IHJ0eFNzcmMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZ3MucHVzaChlbmNvZGluZyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKipcbiAqIEFkZHMgbXVsdGktc3NyYyBiYXNlZCBzaW11bGNhc3QgaW50byB0aGUgZ2l2ZW4gU0RQIG1lZGlhIHNlY3Rpb24gb2ZmZXIuXG4gKi9cbmZ1bmN0aW9uIGFkZExlZ2FjeVNpbXVsY2FzdCh7IG9mZmVyTWVkaWFPYmplY3QsIG51bVN0cmVhbXMsIH0pIHtcbiAgICBpZiAobnVtU3RyZWFtcyA8PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ251bVN0cmVhbXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIFNTUkMuXG4gICAgY29uc3Qgc3NyY01zaWRMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pLmZpbmQoKGxpbmUpID0+IGxpbmUuYXR0cmlidXRlID09PSAnbXNpZCcpO1xuICAgIGlmICghc3NyY01zaWRMaW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBbc3RyZWFtSWQsIHRyYWNrSWRdID0gc3NyY01zaWRMaW5lLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgZmlyc3RTc3JjID0gTnVtYmVyKHNzcmNNc2lkTGluZS5pZCk7XG4gICAgbGV0IGZpcnN0UnR4U3NyYztcbiAgICAvLyBHZXQgdGhlIFNTUkMgZm9yIFJUWC5cbiAgICAob2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdKS5zb21lKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzc3JjcyA9IGxpbmUuc3NyY3Muc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKE51bWJlcihzc3Jjc1swXSkgPT09IGZpcnN0U3NyYykge1xuICAgICAgICAgICAgZmlyc3RSdHhTc3JjID0gTnVtYmVyKHNzcmNzWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3NyY0NuYW1lTGluZSA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3MuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgIGlmICghc3NyY0NuYW1lTGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2E9c3NyYyBsaW5lIHdpdGggY25hbWUgaW5mb3JtYXRpb24gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGNuYW1lID0gc3NyY0NuYW1lTGluZS52YWx1ZTtcbiAgICBjb25zdCBzc3JjcyA9IFtdO1xuICAgIGNvbnN0IHJ0eFNzcmNzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TdHJlYW1zOyArK2kpIHtcbiAgICAgICAgc3NyY3MucHVzaChmaXJzdFNzcmMgKyBpKTtcbiAgICAgICAgaWYgKGZpcnN0UnR4U3NyYykge1xuICAgICAgICAgICAgcnR4U3NyY3MucHVzaChmaXJzdFJ0eFNzcmMgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBbXTtcbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzID0gW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICBzZW1hbnRpY3M6ICdTSU0nLFxuICAgICAgICBzc3Jjczogc3NyY3Muam9pbignICcpLFxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgc3NyYyBvZiBzc3Jjcykge1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogY25hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFja0lkfWAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ0eFNzcmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNzcmMgPSBzc3Jjc1tpXTtcbiAgICAgICAgY29uc3QgcnR4U3NyYyA9IHJ0eFNzcmNzW2ldO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogY25hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFja0lkfWAsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWJ1ZyA9IGV4cG9ydHMucGFyc2VTY2FsYWJpbGl0eU1vZGUgPSBleHBvcnRzLmRldGVjdERldmljZSA9IGV4cG9ydHMuRGV2aWNlID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy50eXBlcyA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmV4cG9ydHMuZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQ7XG5jb25zdCBEZXZpY2VfMSA9IHJlcXVpcmUoXCIuL0RldmljZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRldmljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGV2aWNlXzEuRGV2aWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGV0ZWN0RGV2aWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZXZpY2VfMS5kZXRlY3REZXZpY2U7IH0gfSk7XG5jb25zdCB0eXBlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSk7XG5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG4vKipcbiAqIEV4cG9zZSBtZWRpYXNvdXAtY2xpZW50IHZlcnNpb24uXG4gKi9cbmV4cG9ydHMudmVyc2lvbiA9ICczLjguMSc7XG4vKipcbiAqIEV4cG9zZSBwYXJzZVNjYWxhYmlsaXR5TW9kZSgpIGZ1bmN0aW9uLlxuICovXG52YXIgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlU2NhbGFiaWxpdHlNb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2U7IH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyA9IHZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzO1xuZXhwb3J0cy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnM7XG5leHBvcnRzLnZhbGlkYXRlU2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB2YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuZXhwb3J0cy52YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXMgPSB2YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXM7XG5leHBvcnRzLmdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gZ2V0RXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM7XG5leHBvcnRzLmdldFJlY3ZSdHBDYXBhYmlsaXRpZXMgPSBnZXRSZWN2UnRwQ2FwYWJpbGl0aWVzO1xuZXhwb3J0cy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycyA9IGdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzO1xuZXhwb3J0cy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IGdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzO1xuZXhwb3J0cy5yZWR1Y2VDb2RlY3MgPSByZWR1Y2VDb2RlY3M7XG5leHBvcnRzLmdlbmVyYXRlUHJvYmF0b3JSdHBQYXJhbWV0ZXJzID0gZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnM7XG5leHBvcnRzLmNhblNlbmQgPSBjYW5TZW5kO1xuZXhwb3J0cy5jYW5SZWNlaXZlID0gY2FuUmVjZWl2ZTtcbmNvbnN0IGgyNjQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImgyNjQtcHJvZmlsZS1sZXZlbC1pZFwiKSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBSVFBfUFJPQkFUT1JfTUlEID0gJ3Byb2JhdG9yJztcbmNvbnN0IFJUUF9QUk9CQVRPUl9TU1JDID0gMTIzNDtcbmNvbnN0IFJUUF9QUk9CQVRPUl9DT0RFQ19QQVlMT0FEX1RZUEUgPSAxMjc7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBDYXBhYmlsaXRpZXMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBDYXBhYmlsaXRpZXMoY2Fwcykge1xuICAgIGlmICh0eXBlb2YgY2FwcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FwcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIGNvZGVjcyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoY2Fwcy5jb2RlY3MgJiYgIUFycmF5LmlzQXJyYXkoY2Fwcy5jb2RlY3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuY29kZWNzIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY2Fwcy5jb2RlY3MpIHtcbiAgICAgICAgY2Fwcy5jb2RlY3MgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBzLmNvZGVjcykge1xuICAgICAgICB2YWxpZGF0ZVJ0cENvZGVjQ2FwYWJpbGl0eShjb2RlYyk7XG4gICAgfVxuICAgIC8vIGhlYWRlckV4dGVuc2lvbnMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBmaWxsIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucyAmJiAhQXJyYXkuaXNBcnJheShjYXBzLmhlYWRlckV4dGVuc2lvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuaGVhZGVyRXh0ZW5zaW9ucyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleHQgb2YgY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uKGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwUGFyYW1ldGVycy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIG1pZCBpcyBvcHRpb25hbC5cbiAgICBpZiAocGFyYW1zLm1pZCAmJiB0eXBlb2YgcGFyYW1zLm1pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zLm1pZCBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgLy8gY29kZWNzIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmNvZGVjcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMuY29kZWNzJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29kZWMgb2YgcGFyYW1zLmNvZGVjcykge1xuICAgICAgICB2YWxpZGF0ZVJ0cENvZGVjUGFyYW1ldGVycyhjb2RlYyk7XG4gICAgfVxuICAgIC8vIGhlYWRlckV4dGVuc2lvbnMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBmaWxsIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKHBhcmFtcy5oZWFkZXJFeHRlbnNpb25zICYmICFBcnJheS5pc0FycmF5KHBhcmFtcy5oZWFkZXJFeHRlbnNpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXBhcmFtcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIHBhcmFtcy5oZWFkZXJFeHRlbnNpb25zID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIHBhcmFtcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyhleHQpO1xuICAgIH1cbiAgICAvLyBlbmNvZGluZ3MgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBmaWxsIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKHBhcmFtcy5lbmNvZGluZ3MgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zLmVuY29kaW5ncykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zLmVuY29kaW5ncyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXBhcmFtcy5lbmNvZGluZ3MpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHBhcmFtcy5lbmNvZGluZ3MpIHtcbiAgICAgICAgdmFsaWRhdGVSdHBFbmNvZGluZ1BhcmFtZXRlcnMoZW5jb2RpbmcpO1xuICAgIH1cbiAgICAvLyBydGNwIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgZmlsbCB3aXRoIGFuIGVtcHR5IG9iamVjdC5cbiAgICBpZiAocGFyYW1zLnJ0Y3AgJiYgdHlwZW9mIHBhcmFtcy5ydGNwICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMucnRjcCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFwYXJhbXMucnRjcCkge1xuICAgICAgICBwYXJhbXMucnRjcCA9IHt9O1xuICAgIH1cbiAgICB2YWxpZGF0ZVJ0Y3BQYXJhbWV0ZXJzKHBhcmFtcy5ydGNwKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIFNjdHBTdHJlYW1QYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2N0cFN0cmVhbVBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIHN0cmVhbUlkIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5zdHJlYW1JZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMuc3RyZWFtSWQnKTtcbiAgICB9XG4gICAgLy8gb3JkZXJlZCBpcyBvcHRpb25hbC5cbiAgICBsZXQgb3JkZXJlZEdpdmVuID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMub3JkZXJlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9yZGVyZWRHaXZlbiA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJhbXMub3JkZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIG1heFBhY2tldExpZmVUaW1lIGlzIG9wdGlvbmFsLlxuICAgIGlmIChwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUgJiZcbiAgICAgICAgdHlwZW9mIHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUnKTtcbiAgICB9XG4gICAgLy8gbWF4UmV0cmFuc21pdHMgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5tYXhSZXRyYW5zbWl0cyAmJiB0eXBlb2YgcGFyYW1zLm1heFJldHJhbnNtaXRzICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5tYXhSZXRyYW5zbWl0cycpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLm1heFBhY2tldExpZmVUaW1lICYmIHBhcmFtcy5tYXhSZXRyYW5zbWl0cykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgcHJvdmlkZSBib3RoIG1heFBhY2tldExpZmVUaW1lIGFuZCBtYXhSZXRyYW5zbWl0cycpO1xuICAgIH1cbiAgICBpZiAob3JkZXJlZEdpdmVuICYmXG4gICAgICAgIHBhcmFtcy5vcmRlcmVkICYmXG4gICAgICAgIChwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUgfHwgcGFyYW1zLm1heFJldHJhbnNtaXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYmUgb3JkZXJlZCB3aXRoIG1heFBhY2tldExpZmVUaW1lIG9yIG1heFJldHJhbnNtaXRzJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcmRlcmVkR2l2ZW4gJiZcbiAgICAgICAgKHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSB8fCBwYXJhbXMubWF4UmV0cmFuc21pdHMpKSB7XG4gICAgICAgIHBhcmFtcy5vcmRlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGxhYmVsIGlzIG9wdGlvbmFsLlxuICAgIGlmIChwYXJhbXMubGFiZWwgJiYgdHlwZW9mIHBhcmFtcy5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMubGFiZWwnKTtcbiAgICB9XG4gICAgLy8gcHJvdG9jb2wgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5wcm90b2NvbCAmJiB0eXBlb2YgcGFyYW1zLnByb3RvY29sICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5wcm90b2NvbCcpO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIFNjdHBDYXBhYmlsaXRpZXMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTY3RwQ2FwYWJpbGl0aWVzKGNhcHMpIHtcbiAgICBpZiAodHlwZW9mIGNhcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICAvLyBudW1TdHJlYW1zIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWNhcHMubnVtU3RyZWFtcyB8fCB0eXBlb2YgY2Fwcy5udW1TdHJlYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNhcHMubnVtU3RyZWFtcycpO1xuICAgIH1cbiAgICB2YWxpZGF0ZU51bVNjdHBTdHJlYW1zKGNhcHMubnVtU3RyZWFtcyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGV4dGVuZGVkIFJUUCBjYXBhYmlsaXRpZXMgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0RXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMobG9jYWxDYXBzLCByZW1vdGVDYXBzKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMgPSB7XG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgIH07XG4gICAgLy8gTWF0Y2ggbWVkaWEgY29kZWNzIGFuZCBrZWVwIHRoZSBvcmRlciBwcmVmZXJyZWQgYnkgcmVtb3RlQ2Fwcy5cbiAgICBmb3IgKGNvbnN0IHJlbW90ZUNvZGVjIG9mIHJlbW90ZUNhcHMuY29kZWNzID8/IFtdKSB7XG4gICAgICAgIGlmIChpc1J0eENvZGVjKHJlbW90ZUNvZGVjKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hpbmdMb2NhbENvZGVjID0gKGxvY2FsQ2Fwcy5jb2RlY3MgPz8gW10pLmZpbmQoKGxvY2FsQ29kZWMpID0+IG1hdGNoQ29kZWNzKGxvY2FsQ29kZWMsIHJlbW90ZUNvZGVjLCB7IHN0cmljdDogdHJ1ZSwgbW9kaWZ5OiB0cnVlIH0pKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZ0xvY2FsQ29kZWMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogbWF0Y2hpbmdMb2NhbENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAga2luZDogbWF0Y2hpbmdMb2NhbENvZGVjLmtpbmQsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IG1hdGNoaW5nTG9jYWxDb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICBjaGFubmVsczogbWF0Y2hpbmdMb2NhbENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgbG9jYWxQYXlsb2FkVHlwZTogbWF0Y2hpbmdMb2NhbENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgbG9jYWxSdHhQYXlsb2FkVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVtb3RlUGF5bG9hZFR5cGU6IHJlbW90ZUNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgcmVtb3RlUnR4UGF5bG9hZFR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2FsUGFyYW1ldGVyczogbWF0Y2hpbmdMb2NhbENvZGVjLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZW1vdGVQYXJhbWV0ZXJzOiByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiByZWR1Y2VSdGNwRmVlZGJhY2sobWF0Y2hpbmdMb2NhbENvZGVjLCByZW1vdGVDb2RlYyksXG4gICAgICAgIH07XG4gICAgICAgIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcy5wdXNoKGV4dGVuZGVkQ29kZWMpO1xuICAgIH1cbiAgICAvLyBNYXRjaCBSVFggY29kZWNzLlxuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRDb2RlYyBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdMb2NhbFJ0eENvZGVjID0gbG9jYWxDYXBzLmNvZGVjcy5maW5kKChsb2NhbENvZGVjKSA9PiBpc1J0eENvZGVjKGxvY2FsQ29kZWMpICYmXG4gICAgICAgICAgICBsb2NhbENvZGVjLnBhcmFtZXRlcnMuYXB0ID09PSBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjID0gcmVtb3RlQ2Fwcy5jb2RlY3MuZmluZCgocmVtb3RlQ29kZWMpID0+IGlzUnR4Q29kZWMocmVtb3RlQ29kZWMpICYmXG4gICAgICAgICAgICByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLmFwdCA9PT0gZXh0ZW5kZWRDb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmIChtYXRjaGluZ0xvY2FsUnR4Q29kZWMgJiYgbWF0Y2hpbmdSZW1vdGVSdHhDb2RlYykge1xuICAgICAgICAgICAgZXh0ZW5kZWRDb2RlYy5sb2NhbFJ0eFBheWxvYWRUeXBlID1cbiAgICAgICAgICAgICAgICBtYXRjaGluZ0xvY2FsUnR4Q29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICAgICAgICBleHRlbmRlZENvZGVjLnJlbW90ZVJ0eFBheWxvYWRUeXBlID1cbiAgICAgICAgICAgICAgICBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1hdGNoIGhlYWRlciBleHRlbnNpb25zLlxuICAgIGZvciAoY29uc3QgcmVtb3RlRXh0IG9mIHJlbW90ZUNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsRXh0ID0gbG9jYWxDYXBzLmhlYWRlckV4dGVuc2lvbnMuZmluZCgobG9jYWxFeHQpID0+IG1hdGNoSGVhZGVyRXh0ZW5zaW9ucyhsb2NhbEV4dCwgcmVtb3RlRXh0KSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdMb2NhbEV4dCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW5kZWRFeHQgPSB7XG4gICAgICAgICAgICBraW5kOiByZW1vdGVFeHQua2luZCxcbiAgICAgICAgICAgIHVyaTogcmVtb3RlRXh0LnVyaSxcbiAgICAgICAgICAgIHNlbmRJZDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRJZCxcbiAgICAgICAgICAgIHJlY3ZJZDogcmVtb3RlRXh0LnByZWZlcnJlZElkLFxuICAgICAgICAgICAgZW5jcnlwdDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRFbmNyeXB0LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZHJlY3YnLFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHJlbW90ZUV4dC5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3NlbmRyZWN2Jzoge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdzZW5kcmVjdic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdyZWN2b25seSc6IHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dC5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2VuZG9ubHknOiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRFeHQuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luYWN0aXZlJzoge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dGVuZGVkRXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmcgbWVkaWEgYmFzZWQgb24gdGhlIGdpdmVuIGV4dGVuZGVkXG4gKiBSVFAgY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRSZWN2UnRwQ2FwYWJpbGl0aWVzKGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3QgcnRwQ2FwYWJpbGl0aWVzID0ge1xuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRDb2RlYyBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgICAgY29uc3QgY29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogZXh0ZW5kZWRDb2RlYy5taW1lVHlwZSxcbiAgICAgICAgICAgIGtpbmQ6IGV4dGVuZGVkQ29kZWMua2luZCxcbiAgICAgICAgICAgIHByZWZlcnJlZFBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLnJlbW90ZVBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBleHRlbmRlZENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogZXh0ZW5kZWRDb2RlYy5sb2NhbFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IGV4dGVuZGVkQ29kZWMucnRjcEZlZWRiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBydHBDYXBhYmlsaXRpZXMuY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAvLyBBZGQgUlRYIGNvZGVjLlxuICAgICAgICBpZiAoIWV4dGVuZGVkQ29kZWMucmVtb3RlUnR4UGF5bG9hZFR5cGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGAke2V4dGVuZGVkQ29kZWMua2luZH0vcnR4YCxcbiAgICAgICAgICAgIGtpbmQ6IGV4dGVuZGVkQ29kZWMua2luZCxcbiAgICAgICAgICAgIHByZWZlcnJlZFBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLnJlbW90ZVJ0eFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBhcHQ6IGV4dGVuZGVkQ29kZWMucmVtb3RlUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcnRwQ2FwYWJpbGl0aWVzLmNvZGVjcy5wdXNoKHJ0eENvZGVjKTtcbiAgICAgICAgLy8gVE9ETzogSW4gdGhlIGZ1dHVyZSwgd2UgbmVlZCB0byBhZGQgRkVDLCBDTiwgZXRjLCBjb2RlY3MuXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRFeHRlbnNpb24gb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAvLyBJZ25vcmUgUlRQIGV4dGVuc2lvbnMgbm90IHZhbGlkIGZvciByZWNlaXZpbmcuXG4gICAgICAgIGlmIChleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgJiZcbiAgICAgICAgICAgIGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ID0ge1xuICAgICAgICAgICAga2luZDogZXh0ZW5kZWRFeHRlbnNpb24ua2luZCxcbiAgICAgICAgICAgIHVyaTogZXh0ZW5kZWRFeHRlbnNpb24udXJpLFxuICAgICAgICAgICAgcHJlZmVycmVkSWQ6IGV4dGVuZGVkRXh0ZW5zaW9uLnJlY3ZJZCxcbiAgICAgICAgICAgIHByZWZlcnJlZEVuY3J5cHQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmVuY3J5cHQsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgcnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcnRwQ2FwYWJpbGl0aWVzO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBmb3Igc2VuZGluZyBtZWRpYS5cbiAqIE5PVEU6IG1pZCwgZW5jb2RpbmdzIGFuZCBydGNwIGZpZWxkcyBhcmUgbGVmdCBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICBjb25zdCBydHBQYXJhbWV0ZXJzID0ge1xuICAgICAgICBtaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgIGVuY29kaW5nczogW10sXG4gICAgICAgIHJ0Y3A6IHt9LFxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5raW5kICE9PSBraW5kKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlYyA9IHtcbiAgICAgICAgICAgIG1pbWVUeXBlOiBleHRlbmRlZENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAgcGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMubG9jYWxQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgIGNsb2NrUmF0ZTogZXh0ZW5kZWRDb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICBjaGFubmVsczogZXh0ZW5kZWRDb2RlYy5jaGFubmVscyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGV4dGVuZGVkQ29kZWMubG9jYWxQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiBleHRlbmRlZENvZGVjLnJ0Y3BGZWVkYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAgIC8vIEFkZCBSVFggY29kZWMuXG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBgJHtleHRlbmRlZENvZGVjLmtpbmR9L3J0eGAsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMubG9jYWxSdHhQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXB0OiBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRFeHRlbnNpb24gb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAvLyBJZ25vcmUgUlRQIGV4dGVuc2lvbnMgb2YgYSBkaWZmZXJlbnQga2luZCBhbmQgdGhvc2Ugbm90IHZhbGlkIGZvciBzZW5kaW5nLlxuICAgICAgICBpZiAoKGV4dGVuZGVkRXh0ZW5zaW9uLmtpbmQgJiYgZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAhPT0ga2luZCkgfHxcbiAgICAgICAgICAgIChleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSB7XG4gICAgICAgICAgICB1cmk6IGV4dGVuZGVkRXh0ZW5zaW9uLnVyaSxcbiAgICAgICAgICAgIGlkOiBleHRlbmRlZEV4dGVuc2lvbi5zZW5kSWQsXG4gICAgICAgICAgICBlbmNyeXB0OiBleHRlbmRlZEV4dGVuc2lvbi5lbmNyeXB0LFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBydHBQYXJhbWV0ZXJzO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBzdWl0YWJsZSBmb3IgdGhlIHJlbW90ZSBTRFAgYW5zd2VyLlxuICovXG5mdW5jdGlvbiBnZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyhraW5kLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcykge1xuICAgIGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB7XG4gICAgICAgIG1pZDogdW5kZWZpbmVkLFxuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICAgICAgZW5jb2RpbmdzOiBbXSxcbiAgICAgICAgcnRjcDoge30sXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuZGVkQ29kZWMgb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmtpbmQgIT09IGtpbmQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGV4dGVuZGVkQ29kZWMubWltZVR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBleHRlbmRlZENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogZXh0ZW5kZWRDb2RlYy5yZW1vdGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiBleHRlbmRlZENvZGVjLnJ0Y3BGZWVkYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAgIC8vIEFkZCBSVFggY29kZWMuXG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBgJHtleHRlbmRlZENvZGVjLmtpbmR9L3J0eGAsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMubG9jYWxSdHhQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXB0OiBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRFeHRlbnNpb24gb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAvLyBJZ25vcmUgUlRQIGV4dGVuc2lvbnMgb2YgYSBkaWZmZXJlbnQga2luZCBhbmQgdGhvc2Ugbm90IHZhbGlkIGZvciBzZW5kaW5nLlxuICAgICAgICBpZiAoKGV4dGVuZGVkRXh0ZW5zaW9uLmtpbmQgJiYgZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAhPT0ga2luZCkgfHxcbiAgICAgICAgICAgIChleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSB7XG4gICAgICAgICAgICB1cmk6IGV4dGVuZGVkRXh0ZW5zaW9uLnVyaSxcbiAgICAgICAgICAgIGlkOiBleHRlbmRlZEV4dGVuc2lvbi5zZW5kSWQsXG4gICAgICAgICAgICBlbmNyeXB0OiBleHRlbmRlZEV4dGVuc2lvbi5lbmNyeXB0LFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gICAgfVxuICAgIC8vIFJlZHVjZSBjb2RlY3MnIFJUQ1AgZmVlZGJhY2suIFVzZSBUcmFuc3BvcnQtQ0MgaWYgYXZhaWxhYmxlLCBSRU1CIG90aGVyd2lzZS5cbiAgICBpZiAocnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zLnNvbWUoZXh0ID0+IGV4dC51cmkgPT09XG4gICAgICAgICdodHRwOi8vd3d3LmlldGYub3JnL2lkL2RyYWZ0LWhvbG1lci1ybWNhdC10cmFuc3BvcnQtd2lkZS1jYy1leHRlbnNpb25zLTAxJykpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBydHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gKGNvZGVjLnJ0Y3BGZWVkYmFjayA/PyBbXSkuZmlsdGVyKChmYikgPT4gZmIudHlwZSAhPT0gJ2dvb2ctcmVtYicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5zb21lKGV4dCA9PiBleHQudXJpID09PSAnaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLXNlbmQtdGltZScpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgcnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IChjb2RlYy5ydGNwRmVlZGJhY2sgPz8gW10pLmZpbHRlcihmYiA9PiBmYi50eXBlICE9PSAndHJhbnNwb3J0LWNjJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgcnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IChjb2RlYy5ydGNwRmVlZGJhY2sgPz8gW10pLmZpbHRlcigoZmIpID0+IGZiLnR5cGUgIT09ICd0cmFuc3BvcnQtY2MnICYmIGZiLnR5cGUgIT09ICdnb29nLXJlbWInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbi8qKlxuICogUmVkdWNlIGdpdmVuIGNvZGVjcyBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY29kZWNzIFwiY29tcGF0aWJsZVwiIHdpdGggdGhlXG4gKiBnaXZlbiBjYXBhYmlsaXR5IGNvZGVjLiBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdFxuICogb25lKHMpLlxuICpcbiAqIEdpdmVuIGNvZGVjcyBtdXN0IGJlIGdlbmVyYXRlZCBieSBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCkgb3JcbiAqIG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoKS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYXJyYXkgb2YgY29kZWNzIGFsc28gaW5jbHVkZSBhIFJUWCBjb2RlYyBpZiBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvZGVjcyhjb2RlY3MsIGNhcENvZGVjKSB7XG4gICAgY29uc3QgZmlsdGVyZWRDb2RlY3MgPSBbXTtcbiAgICAvLyBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdCBvbmUgKGFuZCBSVFgpLlxuICAgIGlmICghY2FwQ29kZWMpIHtcbiAgICAgICAgZmlsdGVyZWRDb2RlY3MucHVzaChjb2RlY3NbMF0pO1xuICAgICAgICBpZiAoaXNSdHhDb2RlYyhjb2RlY3NbMV0pKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZENvZGVjcy5wdXNoKGNvZGVjc1sxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGEgY29tcGF0aWJsZSBzZXQgb2YgY29kZWNzLlxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBjb2RlY3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoQ29kZWNzKGNvZGVjc1tpZHhdLCBjYXBDb2RlYywgeyBzdHJpY3Q6IHRydWUgfSkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvZGVjcy5wdXNoKGNvZGVjc1tpZHhdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSdHhDb2RlYyhjb2RlY3NbaWR4ICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29kZWNzLnB1c2goY29kZWNzW2lkeCArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlcmVkQ29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gbWF0Y2hpbmcgY29kZWMgZm91bmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRDb2RlY3M7XG59XG4vKipcbiAqIENyZWF0ZSBSVFAgcGFyYW1ldGVycyBmb3IgYSBDb25zdW1lciBmb3IgdGhlIFJUUCBwcm9iYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnModmlkZW9SdHBQYXJhbWV0ZXJzKSB7XG4gICAgLy8gQ2xvbmUgZ2l2ZW4gcmVmZXJlbmNlIHZpZGVvIFJUUCBwYXJhbWV0ZXJzLlxuICAgIHZpZGVvUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHZpZGVvUnRwUGFyYW1ldGVycyk7XG4gICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgdmFsaWRhdGVSdHBQYXJhbWV0ZXJzKHZpZGVvUnRwUGFyYW1ldGVycyk7XG4gICAgY29uc3QgcnRwUGFyYW1ldGVycyA9IHtcbiAgICAgICAgbWlkOiBSVFBfUFJPQkFUT1JfTUlELFxuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICAgICAgZW5jb2RpbmdzOiBbeyBzc3JjOiBSVFBfUFJPQkFUT1JfU1NSQyB9XSxcbiAgICAgICAgcnRjcDogeyBjbmFtZTogJ3Byb2JhdG9yJyB9LFxuICAgIH07XG4gICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaCh2aWRlb1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdKTtcbiAgICBydHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5wYXlsb2FkVHlwZSA9IFJUUF9QUk9CQVRPUl9DT0RFQ19QQVlMT0FEX1RZUEU7XG4gICAgcnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zID0gdmlkZW9SdHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnM7XG4gICAgcmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG59XG4vKipcbiAqIFdoZXRoZXIgbWVkaWEgY2FuIGJlIHNlbnQgYmFzZWQgb24gdGhlIGdpdmVuIFJUUCBjYXBhYmlsaXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNhblNlbmQoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICByZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnNvbWUoKGNvZGVjKSA9PiBjb2RlYy5raW5kID09PSBraW5kKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gUlRQIHBhcmFtZXRlcnMgY2FuIGJlIHJlY2VpdmVkIHdpdGggdGhlIGdpdmVuIFJUUFxuICogY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBjYW5SZWNlaXZlKHJ0cFBhcmFtZXRlcnMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgdmFsaWRhdGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgIGlmIChydHBQYXJhbWV0ZXJzLmNvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE1lZGlhQ29kZWMgPSBydHBQYXJhbWV0ZXJzLmNvZGVjc1swXTtcbiAgICByZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnNvbWUoKGNvZGVjKSA9PiBjb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSA9PT0gZmlyc3RNZWRpYUNvZGVjLnBheWxvYWRUeXBlKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIFJ0cENvZGVjQ2FwYWJpbGl0eS4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cENvZGVjQ2FwYWJpbGl0eShjb2RlYykge1xuICAgIGNvbnN0IE1pbWVUeXBlUmVnZXggPSBuZXcgUmVnRXhwKCdeKGF1ZGlvfHZpZGVvKS8oLispJywgJ2knKTtcbiAgICBpZiAodHlwZW9mIGNvZGVjICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb2RlYyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIG1pbWVUeXBlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWNvZGVjLm1pbWVUeXBlIHx8IHR5cGVvZiBjb2RlYy5taW1lVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjb2RlYy5taW1lVHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBtaW1lVHlwZU1hdGNoID0gTWltZVR5cGVSZWdleC5leGVjKGNvZGVjLm1pbWVUeXBlKTtcbiAgICBpZiAoIW1pbWVUeXBlTWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjb2RlYy5taW1lVHlwZScpO1xuICAgIH1cbiAgICAvLyBKdXN0IG92ZXJyaWRlIGtpbmQgd2l0aCBtZWRpYSBjb21wb25lbnQgb2YgbWltZVR5cGUuXG4gICAgY29kZWMua2luZCA9IG1pbWVUeXBlTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAvLyBwcmVmZXJyZWRQYXlsb2FkVHlwZSBpcyBvcHRpb25hbC5cbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgJiZcbiAgICAgICAgdHlwZW9mIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlJyk7XG4gICAgfVxuICAgIC8vIGNsb2NrUmF0ZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBjb2RlYy5jbG9ja1JhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMuY2xvY2tSYXRlJyk7XG4gICAgfVxuICAgIC8vIGNoYW5uZWxzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIDEgKGp1c3QgaWYgYXVkaW8pLlxuICAgIGlmIChjb2RlYy5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZWMuY2hhbm5lbHMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb2RlYy5jaGFubmVscyA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBjb2RlYy5jaGFubmVscztcbiAgICB9XG4gICAgLy8gcGFyYW1ldGVycyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKCFjb2RlYy5wYXJhbWV0ZXJzIHx8IHR5cGVvZiBjb2RlYy5wYXJhbWV0ZXJzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzID0ge307XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvZGVjLnBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNba2V5XSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGNvZGVjIHBhcmFtZXRlciBba2V5OiR7a2V5fXMsIHZhbHVlOiR7dmFsdWV9XWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpZmljIHBhcmFtZXRlcnMgdmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2FwdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjb2RlYyBhcHQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcnRjcEZlZWRiYWNrIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmICghY29kZWMucnRjcEZlZWRiYWNrIHx8ICFBcnJheS5pc0FycmF5KGNvZGVjLnJ0Y3BGZWVkYmFjaykpIHtcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmIgb2YgY29kZWMucnRjcEZlZWRiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlUnRjcEZlZWRiYWNrKGZiKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBSdGNwRmVlZGJhY2suIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdGNwRmVlZGJhY2soZmIpIHtcbiAgICBpZiAodHlwZW9mIGZiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIHR5cGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghZmIudHlwZSB8fCB0eXBlb2YgZmIudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBmYi50eXBlJyk7XG4gICAgfVxuICAgIC8vIHBhcmFtZXRlciBpcyBvcHRpb25hbC4gSWYgdW5zZXQgc2V0IGl0IHRvIGFuIGVtcHR5IHN0cmluZy5cbiAgICBpZiAoIWZiLnBhcmFtZXRlciB8fCB0eXBlb2YgZmIucGFyYW1ldGVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICBmYi5wYXJhbWV0ZXIgPSAnJztcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBIZWFkZXJFeHRlbnNpb24uIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb24oZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBleHQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIGtpbmQgaXMgbWFuZGF0b3J5LlxuICAgIGlmIChleHQua2luZCAhPT0gJ2F1ZGlvJyAmJiBleHQua2luZCAhPT0gJ3ZpZGVvJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGV4dC5raW5kJyk7XG4gICAgfVxuICAgIC8vIHVyaSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFleHQudXJpIHx8IHR5cGVvZiBleHQudXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC51cmknKTtcbiAgICB9XG4gICAgLy8gcHJlZmVycmVkSWQgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgZXh0LnByZWZlcnJlZElkICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC5wcmVmZXJyZWRJZCcpO1xuICAgIH1cbiAgICAvLyBwcmVmZXJyZWRFbmNyeXB0IGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gZmFsc2UuXG4gICAgaWYgKGV4dC5wcmVmZXJyZWRFbmNyeXB0ICYmIHR5cGVvZiBleHQucHJlZmVycmVkRW5jcnlwdCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LnByZWZlcnJlZEVuY3J5cHQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4dC5wcmVmZXJyZWRFbmNyeXB0KSB7XG4gICAgICAgIGV4dC5wcmVmZXJyZWRFbmNyeXB0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGRpcmVjdGlvbiBpcyBvcHRpb25hbC4gSWYgdW5zZXQgc2V0IGl0IHRvIHNlbmRyZWN2LlxuICAgIGlmIChleHQuZGlyZWN0aW9uICYmIHR5cGVvZiBleHQuZGlyZWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGV4dC5kaXJlY3Rpb24nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4dC5kaXJlY3Rpb24pIHtcbiAgICAgICAgZXh0LmRpcmVjdGlvbiA9ICdzZW5kcmVjdic7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwQ29kZWNQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzKGNvZGVjKSB7XG4gICAgY29uc3QgTWltZVR5cGVSZWdleCA9IG5ldyBSZWdFeHAoJ14oYXVkaW98dmlkZW8pLyguKyknLCAnaScpO1xuICAgIGlmICh0eXBlb2YgY29kZWMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvZGVjIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gbWltZVR5cGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghY29kZWMubWltZVR5cGUgfHwgdHlwZW9mIGNvZGVjLm1pbWVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IG1pbWVUeXBlTWF0Y2ggPSBNaW1lVHlwZVJlZ2V4LmV4ZWMoY29kZWMubWltZVR5cGUpO1xuICAgIGlmICghbWltZVR5cGVNYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgfVxuICAgIC8vIHBheWxvYWRUeXBlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIGNvZGVjLnBheWxvYWRUeXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLnBheWxvYWRUeXBlJyk7XG4gICAgfVxuICAgIC8vIGNsb2NrUmF0ZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBjb2RlYy5jbG9ja1JhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMuY2xvY2tSYXRlJyk7XG4gICAgfVxuICAgIGNvbnN0IGtpbmQgPSBtaW1lVHlwZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gY2hhbm5lbHMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBzZXQgaXQgdG8gMSAoanVzdCBpZiBhdWRpbykuXG4gICAgaWYgKGtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlYy5jaGFubmVscyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvZGVjLmNoYW5uZWxzID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuICAgIH1cbiAgICAvLyBwYXJhbWV0ZXJzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIGFuIGVtcHR5IG9iamVjdC5cbiAgICBpZiAoIWNvZGVjLnBhcmFtZXRlcnMgfHwgdHlwZW9mIGNvZGVjLnBhcmFtZXRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29kZWMucGFyYW1ldGVyc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVyc1trZXldID0gJyc7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgY29kZWMgcGFyYW1ldGVyIFtrZXk6JHtrZXl9cywgdmFsdWU6JHt2YWx1ZX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lmaWMgcGFyYW1ldGVycyB2YWxpZGF0aW9uLlxuICAgICAgICBpZiAoa2V5ID09PSAnYXB0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjIGFwdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBydGNwRmVlZGJhY2sgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBzZXQgaXQgdG8gYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKCFjb2RlYy5ydGNwRmVlZGJhY2sgfHwgIUFycmF5LmlzQXJyYXkoY29kZWMucnRjcEZlZWRiYWNrKSkge1xuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmYiBvZiBjb2RlYy5ydGNwRmVlZGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVSdGNwRmVlZGJhY2soZmIpO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIFJ0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRldGVycy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMoZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBleHQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIHVyaSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFleHQudXJpIHx8IHR5cGVvZiBleHQudXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC51cmknKTtcbiAgICB9XG4gICAgLy8gaWQgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgZXh0LmlkICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC5pZCcpO1xuICAgIH1cbiAgICAvLyBlbmNyeXB0IGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gZmFsc2UuXG4gICAgaWYgKGV4dC5lbmNyeXB0ICYmIHR5cGVvZiBleHQuZW5jcnlwdCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LmVuY3J5cHQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4dC5lbmNyeXB0KSB7XG4gICAgICAgIGV4dC5lbmNyeXB0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHBhcmFtZXRlcnMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBzZXQgaXQgdG8gYW4gZW1wdHkgb2JqZWN0LlxuICAgIGlmICghZXh0LnBhcmFtZXRlcnMgfHwgdHlwZW9mIGV4dC5wYXJhbWV0ZXJzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBleHQucGFyYW1ldGVycyA9IHt9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhleHQucGFyYW1ldGVycykpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZXh0LnBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4dC5wYXJhbWV0ZXJzW2tleV0gPSAnJztcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBoZWFkZXIgZXh0ZW5zaW9uIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGVuY29kaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICAvLyBzc3JjIGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5zc3JjICYmIHR5cGVvZiBlbmNvZGluZy5zc3JjICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGVuY29kaW5nLnNzcmMnKTtcbiAgICB9XG4gICAgLy8gcmlkIGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5yaWQgJiYgdHlwZW9mIGVuY29kaW5nLnJpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5yaWQnKTtcbiAgICB9XG4gICAgLy8gcnR4IGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5ydHggJiYgdHlwZW9mIGVuY29kaW5nLnJ0eCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5ydHgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5jb2RpbmcucnR4KSB7XG4gICAgICAgIC8vIFJUWCBzc3JjIGlzIG1hbmRhdG9yeSBpZiBydHggaXMgcHJlc2VudC5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5ydHguc3NyYyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZW5jb2RpbmcucnR4LnNzcmMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkdHggaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBmYWxzZS5cbiAgICBpZiAoIWVuY29kaW5nLmR0eCB8fCB0eXBlb2YgZW5jb2RpbmcuZHR4ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZW5jb2RpbmcuZHR4ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHNjYWxhYmlsaXR5TW9kZSBpcyBvcHRpb25hbC5cbiAgICBpZiAoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlICYmXG4gICAgICAgIHR5cGVvZiBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlJyk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgUnRjcFBhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdGNwUGFyYW1ldGVycyhydGNwKSB7XG4gICAgaWYgKHR5cGVvZiBydGNwICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdydGNwIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gY25hbWUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHJ0Y3AuY25hbWUgJiYgdHlwZW9mIHJ0Y3AuY25hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcnRjcC5jbmFtZScpO1xuICAgIH1cbiAgICAvLyByZWR1Y2VkU2l6ZSBpcyBvcHRpb25hbC4gSWYgdW5zZXQgc2V0IGl0IHRvIHRydWUuXG4gICAgaWYgKCFydGNwLnJlZHVjZWRTaXplIHx8IHR5cGVvZiBydGNwLnJlZHVjZWRTaXplICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcnRjcC5yZWR1Y2VkU2l6ZSA9IHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgTnVtU2N0cFN0cmVhbXMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOdW1TY3RwU3RyZWFtcyhudW1TdHJlYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBudW1TdHJlYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdudW1TdHJlYW1zIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gT1MgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgbnVtU3RyZWFtcy5PUyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBudW1TdHJlYW1zLk9TJyk7XG4gICAgfVxuICAgIC8vIE1JUyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBudW1TdHJlYW1zLk1JUyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBudW1TdHJlYW1zLk1JUycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUnR4Q29kZWMoY29kZWMpIHtcbiAgICBpZiAoIWNvZGVjKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIC8uK1xcL3J0eCQvaS50ZXN0KGNvZGVjLm1pbWVUeXBlKTtcbn1cbmZ1bmN0aW9uIG1hdGNoQ29kZWNzKGFDb2RlYywgYkNvZGVjLCB7IHN0cmljdCA9IGZhbHNlLCBtb2RpZnkgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBhTWltZVR5cGUgPSBhQ29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBiTWltZVR5cGUgPSBiQ29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoYU1pbWVUeXBlICE9PSBiTWltZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYUNvZGVjLmNsb2NrUmF0ZSAhPT0gYkNvZGVjLmNsb2NrUmF0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhQ29kZWMuY2hhbm5lbHMgIT09IGJDb2RlYy5jaGFubmVscykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFBlciBjb2RlYyBzcGVjaWFsIGNoZWNrcy5cbiAgICBzd2l0Y2ggKGFNaW1lVHlwZSkge1xuICAgICAgICBjYXNlICd2aWRlby9oMjY0Jzoge1xuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFQYWNrZXRpemF0aW9uTW9kZSA9IGFDb2RlYy5wYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJQYWNrZXRpemF0aW9uTW9kZSA9IGJDb2RlYy5wYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChhUGFja2V0aXphdGlvbk1vZGUgIT09IGJQYWNrZXRpemF0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaDI2NC5pc1NhbWVQcm9maWxlKGFDb2RlYy5wYXJhbWV0ZXJzLCBiQ29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRQcm9maWxlTGV2ZWxJZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFByb2ZpbGVMZXZlbElkID0gaDI2NC5nZW5lcmF0ZVByb2ZpbGVMZXZlbElkU3RyaW5nRm9yQW5zd2VyKGFDb2RlYy5wYXJhbWV0ZXJzLCBiQ29kZWMucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkUHJvZmlsZUxldmVsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFDb2RlYy5wYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ10gPSBzZWxlY3RlZFByb2ZpbGVMZXZlbElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYkNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSA9IHNlbGVjdGVkUHJvZmlsZUxldmVsSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYUNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBiQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1sZXZlbC1pZCddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndmlkZW8vdnA5Jzoge1xuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFQcm9maWxlSWQgPSBhQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1pZCddIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYlByb2ZpbGVJZCA9IGJDb2RlYy5wYXJhbWV0ZXJzWydwcm9maWxlLWlkJ10gfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoYVByb2ZpbGVJZCAhPT0gYlByb2ZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaEhlYWRlckV4dGVuc2lvbnMoYUV4dCwgYkV4dCkge1xuICAgIGlmIChhRXh0LmtpbmQgJiYgYkV4dC5raW5kICYmIGFFeHQua2luZCAhPT0gYkV4dC5raW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFFeHQudXJpICE9PSBiRXh0LnVyaSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVkdWNlUnRjcEZlZWRiYWNrKGNvZGVjQSwgY29kZWNCKSB7XG4gICAgY29uc3QgcmVkdWNlZFJ0Y3BGZWVkYmFjayA9IFtdO1xuICAgIGZvciAoY29uc3QgYUZiIG9mIGNvZGVjQS5ydGNwRmVlZGJhY2sgPz8gW10pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCRmIgPSAoY29kZWNCLnJ0Y3BGZWVkYmFjayA/PyBbXSkuZmluZCgoYkZiKSA9PiBiRmIudHlwZSA9PT0gYUZiLnR5cGUgJiZcbiAgICAgICAgICAgIChiRmIucGFyYW1ldGVyID09PSBhRmIucGFyYW1ldGVyIHx8ICghYkZiLnBhcmFtZXRlciAmJiAhYUZiLnBhcmFtZXRlcikpKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nQkZiKSB7XG4gICAgICAgICAgICByZWR1Y2VkUnRjcEZlZWRiYWNrLnB1c2gobWF0Y2hpbmdCRmIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWR1Y2VkUnRjcEZlZWRiYWNrO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5jb25zdCBTY2FsYWJpbGl0eU1vZGVSZWdleCA9IG5ldyBSZWdFeHAoJ15bTFNdKFsxLTldXFxcXGR7MCwxfSlUKFsxLTldXFxcXGR7MCwxfSknKTtcbmZ1bmN0aW9uIHBhcnNlKHNjYWxhYmlsaXR5TW9kZSkge1xuICAgIGNvbnN0IG1hdGNoID0gU2NhbGFiaWxpdHlNb2RlUmVnZXguZXhlYyhzY2FsYWJpbGl0eU1vZGUgPz8gJycpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhdGlhbExheWVyczogTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgIHRlbXBvcmFsTGF5ZXJzOiBOdW1iZXIobWF0Y2hbMl0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYXRpYWxMYXllcnM6IDEsXG4gICAgICAgICAgICB0ZW1wb3JhbExheWVyczogMSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RldmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHJhbnNwb3J0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Qcm9kdWNlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29uc3VtZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RhdGFQcm9kdWNlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGF0YUNvbnN1bWVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9SdHBQYXJhbWV0ZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TY3RwUGFyYW1ldGVyc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFuZGxlcnMvSGFuZGxlckludGVyZmFjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5nZW5lcmF0ZVJhbmRvbU51bWJlciA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyO1xuZXhwb3J0cy5kZWVwRnJlZXplID0gZGVlcEZyZWV6ZTtcbi8qKlxuICogQ2xvbmVzIHRoZSBnaXZlbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQXZhaWxhYmxlIGluIE5vZGUgPj0gMTguXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU51bWJlcigpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xufVxuLyoqXG4gKiBNYWtlIGFuIG9iamVjdCBvciBhcnJheSByZWN1cnNpdmVseSBpbW11dGFibGUuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZnJlZXplLlxuICovXG5mdW5jdGlvbiBkZWVwRnJlZXplKG9iamVjdCkge1xuICAgIC8vIFJldHJpZXZlIHRoZSBwcm9wZXJ0eSBuYW1lcyBkZWZpbmVkIG9uIG9iamVjdC5cbiAgICBjb25zdCBwcm9wTmFtZXMgPSBSZWZsZWN0Lm93bktleXMob2JqZWN0KTtcbiAgICAvLyBGcmVlemUgcHJvcGVydGllcyBiZWZvcmUgZnJlZXppbmcgc2VsZi5cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcHJvcE5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W25hbWVdO1xuICAgICAgICBpZiAoKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKiEgcXVldWUtbWljcm90YXNrLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5sZXQgcHJvbWlzZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJ1xuICA/IHF1ZXVlTWljcm90YXNrLmJpbmQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG4gIC8vIHJldXNlIHJlc29sdmVkIHByb21pc2UsIGFuZCBhbGxvY2F0ZSBpdCBsYXppbHlcbiAgOiBjYiA9PiAocHJvbWlzZSB8fCAocHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpKSlcbiAgICAudGhlbihjYilcbiAgICAuY2F0Y2goZXJyID0+IHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlcnIgfSwgMCkpXG4iLCJ2YXIgZ3JhbW1hciA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB2OiBbe1xuICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICByZWc6IC9eKFxcZCopJC9cbiAgfV0sXG4gIG86IFt7XG4gICAgLy8gbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXG4gICAgbmFtZTogJ29yaWdpbicsXG4gICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXG4gIH1dLFxuICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcbiAgczogW3sgbmFtZTogJ25hbWUnIH1dLFxuICBpOiBbeyBuYW1lOiAnZGVzY3JpcHRpb24nIH1dLFxuICB1OiBbeyBuYW1lOiAndXJpJyB9XSxcbiAgZTogW3sgbmFtZTogJ2VtYWlsJyB9XSxcbiAgcDogW3sgbmFtZTogJ3Bob25lJyB9XSxcbiAgejogW3sgbmFtZTogJ3RpbWV6b25lcycgfV0sIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLi5cbiAgcjogW3sgbmFtZTogJ3JlcGVhdHMnIH1dLCAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAvLyBrOiBbe31dLCAvLyBvdXRkYXRlZCB0aGluZyBpZ25vcmVkXG4gIHQ6IFt7XG4gICAgLy8gdD0wIDBcbiAgICBuYW1lOiAndGltaW5nJyxcbiAgICByZWc6IC9eKFxcZCopIChcXGQqKS8sXG4gICAgbmFtZXM6IFsnc3RhcnQnLCAnc3RvcCddLFxuICAgIGZvcm1hdDogJyVkICVkJ1xuICB9XSxcbiAgYzogW3tcbiAgICAvLyBjPUlOIElQNCAxMC40Ny4xOTcuMjZcbiAgICBuYW1lOiAnY29ubmVjdGlvbicsXG4gICAgcmVnOiAvXklOIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd2ZXJzaW9uJywgJ2lwJ10sXG4gICAgZm9ybWF0OiAnSU4gSVAlZCAlcydcbiAgfV0sXG4gIGI6IFt7XG4gICAgLy8gYj1BUzo0MDAwXG4gICAgcHVzaDogJ2JhbmR3aWR0aCcsXG4gICAgcmVnOiAvXihUSUFTfEFTfENUfFJSfFJTKTooXFxkKikvLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAnbGltaXQnXSxcbiAgICBmb3JtYXQ6ICclczolcydcbiAgfV0sXG4gIG06IFt7XG4gICAgLy8gbT12aWRlbyA1MTc0NCBSVFAvQVZQIDEyNiA5NyA5OCAzNCAzMVxuICAgIC8vIE5COiBzcGVjaWFsIC0gcHVzaGVzIHRvIHNlc3Npb25cbiAgICAvLyBUT0RPOiBydHAvZm10cCBzaG91bGQgYmUgZmlsdGVyZWQgYnkgdGhlIHBheWxvYWRzIGZvdW5kIGhlcmU/XG4gICAgcmVnOiAvXihcXHcqKSAoXFxkKikgKFtcXHcvXSopKD86ICguKikpPy8sXG4gICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXG4gICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXG4gIH1dLFxuICBhOiBbXG4gICAge1xuICAgICAgLy8gYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgICAgcHVzaDogJ3J0cCcsXG4gICAgICByZWc6IC9ecnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5lbmNvZGluZylcbiAgICAgICAgICA/ICdydHBtYXA6JWQgJXMvJXMvJXMnXG4gICAgICAgICAgOiBvLnJhdGVcbiAgICAgICAgICAgID8gJ3J0cG1hcDolZCAlcy8lcydcbiAgICAgICAgICAgIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZtdHA6MTA4IHByb2ZpbGUtbGV2ZWwtaWQ9MjQ7b2JqZWN0PTIzO2JpdHJhdGU9NjQwMDBcbiAgICAgIC8vIGE9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXG4gICAgICBwdXNoOiAnZm10cCcsXG4gICAgICByZWc6IC9eZm10cDooXFxkKikgKFtcXFN8IF0qKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29udHJvbDpzdHJlYW1pZD0wXG4gICAgICBuYW1lOiAnY29udHJvbCcsXG4gICAgICByZWc6IC9eY29udHJvbDooLiopLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRyb2w6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICAgIG5hbWU6ICdydGNwJyxcbiAgICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uYWRkcmVzcyAhPSBudWxsKVxuICAgICAgICAgID8gJ3J0Y3A6JWQgJXMgSVAlZCAlcydcbiAgICAgICAgICA6ICdydGNwOiVkJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgICAgcHVzaDogJ3J0Y3BGYlRyckludCcsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3J0Y3AtZmI6JXMgdHJyLWludCAlZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICAgIHB1c2g6ICdydGNwRmInLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3R5cGUnLCAnc3VidHlwZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc3VidHlwZSAhPSBudWxsKVxuICAgICAgICAgID8gJ3J0Y3AtZmI6JXMgJXMgJXMnXG4gICAgICAgICAgOiAncnRjcC1mYjolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAgIC8vIGE9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICAgIHB1c2g6ICdleHQnLFxuICAgICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyg/OiAodXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCkpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAnZXh0bWFwOiVkJyArXG4gICAgICAgICAgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArXG4gICAgICAgICAgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICtcbiAgICAgICAgICAnICVzJyArXG4gICAgICAgICAgKG8uY29uZmlnID8gJyAlcycgOiAnJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZXh0bWFwLWFsbG93LW1peGVkXG4gICAgICBuYW1lOiAnZXh0bWFwQWxsb3dNaXhlZCcsXG4gICAgICByZWc6IC9eKGV4dG1hcC1hbGxvdy1taXhlZCkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgICAgcHVzaDogJ2NyeXB0bycsXG4gICAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5zZXNzaW9uQ29uZmlnICE9IG51bGwpXG4gICAgICAgICAgPyAnY3J5cHRvOiVkICVzICVzICVzJ1xuICAgICAgICAgIDogJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNldHVwOmFjdHBhc3NcbiAgICAgIG5hbWU6ICdzZXR1cCcsXG4gICAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcbiAgICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb25uZWN0aW9uOm5ld1xuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25UeXBlJyxcbiAgICAgIHJlZzogL15jb25uZWN0aW9uOihuZXd8ZXhpc3RpbmcpLyxcbiAgICAgIGZvcm1hdDogJ2Nvbm5lY3Rpb246JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1pZDoxXG4gICAgICBuYW1lOiAnbWlkJyxcbiAgICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ21pZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgICBuYW1lOiAnbXNpZCcsXG4gICAgICByZWc6IC9ebXNpZDooLiopLyxcbiAgICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXB0aW1lOjIwXG4gICAgICBuYW1lOiAncHRpbWUnLFxuICAgICAgcmVnOiAvXnB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdwdGltZTolZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXG4gICAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zZW5kcmVjdlxuICAgICAgbmFtZTogJ2RpcmVjdGlvbicsXG4gICAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLWxpdGVcbiAgICAgIG5hbWU6ICdpY2VsaXRlJyxcbiAgICAgIHJlZzogL14oaWNlLWxpdGUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtdWZyYWc6RjdnSVxuICAgICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLXB3ZDp4OWNtbC9ZemljaFYyK1hsaGlNdThnXG4gICAgICBuYW1lOiAnaWNlUHdkJyxcbiAgICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtcHdkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1maW5nZXJwcmludDpTSEEtMSAwMDoxMToyMjozMzo0NDo1NTo2Njo3Nzo4ODo5OTpBQTpCQjpDQzpERDpFRTpGRjowMDoxMToyMjozM1xuICAgICAgbmFtZTogJ2ZpbmdlcnByaW50JyxcbiAgICAgIHJlZzogL15maW5nZXJwcmludDooXFxTKikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnaGFzaCddLFxuICAgICAgZm9ybWF0OiAnZmluZ2VycHJpbnQ6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgcHVzaDonY2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXG4gICAgICBuYW1lczogWydmb3VuZGF0aW9uJywgJ2NvbXBvbmVudCcsICd0cmFuc3BvcnQnLCAncHJpb3JpdHknLCAnaXAnLCAncG9ydCcsICd0eXBlJywgJ3JhZGRyJywgJ3Jwb3J0JywgJ3RjcHR5cGUnLCAnZ2VuZXJhdGlvbicsICduZXR3b3JrLWlkJywgJ25ldHdvcmstY29zdCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xuXG4gICAgICAgIHN0ciArPSAoby5yYWRkciAhPSBudWxsKSA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAgIC8vIE5COiBjYW5kaWRhdGUgaGFzIHRocmVlIG9wdGlvbmFsIGNodW5rcywgc28gJXZvaWQgbWlkZGxlcyBvbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIHN0ciArPSAoby50Y3B0eXBlICE9IG51bGwpID8gJyB0Y3B0eXBlICVzJyA6ICcldic7XG5cbiAgICAgICAgaWYgKG8uZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gKG9bJ25ldHdvcmstaWQnXSAhPSBudWxsKSA/ICcgbmV0d29yay1pZCAlZCcgOiAnJXYnO1xuICAgICAgICBzdHIgKz0gKG9bJ25ldHdvcmstY29zdCddICE9IG51bGwpID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL14oZW5kLW9mLWNhbmRpZGF0ZXMpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1yZW1vdGUtY2FuZGlkYXRlczoxIDIwMy4wLjExMy4xIDU0NDAwIDIgMjAzLjAuMTEzLjEgNTQ0MDEgLi4uXG4gICAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdyZW1vdGUtY2FuZGlkYXRlczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLW9wdGlvbnM6Z29vZ2xlLWljZVxuICAgICAgbmFtZTogJ2ljZU9wdGlvbnMnLFxuICAgICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2Utb3B0aW9uczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c3NyYzoyNTY2MTA3NTY5IGNuYW1lOnQ5WVU4TTFVeFRGOFkxQTFcbiAgICAgIHB1c2g6ICdzc3JjcycsXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnYXR0cmlidXRlJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICAgIGlmIChvLmF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOiVzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMgMSAyXG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgICAgcHVzaDogJ3NzcmNHcm91cHMnLFxuICAgICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcbiAgICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpY3MnLCAnc3NyY3MnXSxcbiAgICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1zaWQtc2VtYW50aWM6IFdNUyBKdmxhbTVYM1NYMU9QNnBuMjB6V29ndmFLSno1SGpmOU9ubFZcbiAgICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgICAgcmVnOiAvXm1zaWQtc2VtYW50aWM6XFxzPyhcXHcqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWMnLCAndG9rZW4nXSxcbiAgICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgICBwdXNoOiAnZ3JvdXBzJyxcbiAgICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICAgIGZvcm1hdDogJ2dyb3VwOiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLW11eFxuICAgICAgbmFtZTogJ3J0Y3BNdXgnLFxuICAgICAgcmVnOiAvXihydGNwLW11eCkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtcnNpemVcbiAgICAgIG5hbWU6ICdydGNwUnNpemUnLFxuICAgICAgcmVnOiAvXihydGNwLXJzaXplKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XG4gICAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgICByZWc6IC9ec2N0cG1hcDooW1xcd18vXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbClcbiAgICAgICAgICA/ICdzY3RwbWFwOiVzICVzICVzJ1xuICAgICAgICAgIDogJ3NjdHBtYXA6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2VcbiAgICAgIG5hbWU6ICd4R29vZ2xlRmxhZycsXG4gICAgICByZWc6IC9eeC1nb29nbGUtZmxhZzooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAneC1nb29nbGUtZmxhZzolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cmlkOjEgc2VuZCBtYXgtd2lkdGg9MTI4MDttYXgtaGVpZ2h0PTcyMDttYXgtZnBzPTMwO2RlcGVuZD0wXG4gICAgICBwdXNoOiAncmlkcycsXG4gICAgICByZWc6IC9ecmlkOihbXFxkXFx3XSspIChcXHcrKSg/OiAoW1xcU3wgXSopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnZGlyZWN0aW9uJywgJ3BhcmFtcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ucGFyYW1zKSA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgLy8gYT1pbWFnZWF0dHI6KiBzZW5kIFt4PTgwMCx5PTY0MF0gcmVjdiAqXG4gICAgICAvLyBhPWltYWdlYXR0cjoxMDAgcmVjdiBbeD0zMjAseT0yNDBdXG4gICAgICBwdXNoOiAnaW1hZ2VhdHRycycsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3XG4gICAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgICAgIC8vIHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF1cbiAgICAgICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgICAnKD86W1xcXFxzXFxcXHRdKyhyZWN2fHNlbmQpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKikpPydcbiAgICAgICksXG4gICAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ2ltYWdlYXR0cjolcyAlcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgICAgLy8gYT1zaW11bGNhc3Q6cmVjdiAxOzQsNSBzZW5kIDY7N1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdCcsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGE9c2ltdWxjYXN0OlxuICAgICAgICAnXnNpbXVsY2FzdDonICtcbiAgICAgICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcbiAgICAgICAgLy8gc3BhY2UgKyByZWN2IDY7fjcsfjhcbiAgICAgICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAgICAgLy8gZW5kXG4gICAgICAgICckJ1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBvbGQgc2ltdWxjYXN0IGRyYWZ0IDAzIChpbXBsZW1lbnRlZCBieSBGaXJlZm94KVxuICAgICAgLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2RwLXNpbXVsY2FzdC0wM1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHNlbmQgcmlkPTU7Njs3IHBhdXNlZD02LDdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3RfMDMnLFxuICAgICAgcmVnOiAvXnNpbXVsY2FzdDpbXFxzXFx0XSsoW1xcUytcXHNcXHRdKykkLyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdzaW11bGNhc3Q6ICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mcmFtZXJhdGU6MjVcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI5Ljk3XG4gICAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICAgIHJlZzogL15mcmFtZXJhdGU6KFxcZCsoPzokfFxcLlxcZCspKS8sXG4gICAgICBmb3JtYXQ6ICdmcmFtZXJhdGU6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM0NTcwXG4gICAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgICBuYW1lOiAnc291cmNlRmlsdGVyJyxcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgICBmb3JtYXQ6ICdzb3VyY2UtZmlsdGVyOiAlcyAlcyAlcyAlcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9YnVuZGxlLW9ubHlcbiAgICAgIG5hbWU6ICdidW5kbGVPbmx5JyxcbiAgICAgIHJlZzogL14oYnVuZGxlLW9ubHkpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1sYWJlbDoxXG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgcmVnOiAvXmxhYmVsOiguKykvLFxuICAgICAgZm9ybWF0OiAnbGFiZWw6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTVcbiAgICAgIG5hbWU6ICdzY3RwUG9ydCcsXG4gICAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnc2N0cC1wb3J0OiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi02XG4gICAgICBuYW1lOiAnbWF4TWVzc2FnZVNpemUnLFxuICAgICAgcmVnOiAvXm1heC1tZXNzYWdlLXNpemU6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdtYXgtbWVzc2FnZS1zaXplOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcbiAgICAgIHB1c2g6J3RzUmVmQ2xvY2tzJyxcbiAgICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgICBuYW1lczogWydjbGtzcmMnLCAnY2xrc3JjRXh0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPW1lZGlhY2xrOmRpcmVjdD05NjMyMTQ0MjRcbiAgICAgIG5hbWU6J21lZGlhQ2xrJyxcbiAgICAgIHJlZzogL15tZWRpYWNsazooPzppZD0oXFxTKikpPyAqKFteXFxzPV0qKSg/Oj0oXFxTKikpPyg/OiAqcmF0ZT0oXFxkKylcXC8oXFxkKykpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdtZWRpYWNsazonO1xuICAgICAgICBzdHIgKz0gKG8uaWQgIT0gbnVsbCA/ICdpZD0lcyAlcycgOiAnJXYlcycpO1xuICAgICAgICBzdHIgKz0gKG8ubWVkaWFDbG9ja1ZhbHVlICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcbiAgICAgICAgc3RyICs9IChvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJyk7XG4gICAgICAgIHN0ciArPSAoby5yYXRlRGVub21pbmF0b3IgIT0gbnVsbCA/ICcvJXMnIDogJycpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1rZXl3ZHM6a2V5d29yZHNcbiAgICAgIG5hbWU6ICdrZXl3b3JkcycsXG4gICAgICByZWc6IC9ea2V5d2RzOiguKykkLyxcbiAgICAgIGZvcm1hdDogJ2tleXdkczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29udGVudDptYWluXG4gICAgICBuYW1lOiAnY29udGVudCcsXG4gICAgICByZWc6IC9eY29udGVudDooLispLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXG4gICAgfSxcbiAgICAvLyBCRkNQIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NTgzXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmN0cmw6Yy1zXG4gICAgICBuYW1lOiAnYmZjcEZsb29yQ3RybCcsXG4gICAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxuICAgICAgZm9ybWF0OiAnZmxvb3JjdHJsOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb25maWQ6MVxuICAgICAgbmFtZTogJ2JmY3BDb25mSWQnLFxuICAgICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAnY29uZmlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT11c2VyaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BVc2VySWQnLFxuICAgICAgcmVnOiAvXnVzZXJpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAndXNlcmlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JJZCcsXG4gICAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21TdHJlYW0nXSxcbiAgICAgIGZvcm1hdDogJ2Zsb29yaWQ6JXMgbXN0cm06JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXVxuICAgIH1cbiAgXVxufTtcblxuLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXG5PYmplY3Qua2V5cyhncmFtbWFyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG9ianMgPSBncmFtbWFyW2tleV07XG4gIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICBvYmoucmVnID0gLyguKikvO1xuICAgIH1cbiAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xudmFyIHdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG52YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xuXG5leHBvcnRzLmdyYW1tYXIgPSBncmFtbWFyO1xuZXhwb3J0cy53cml0ZSA9IHdyaXRlcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZXIucGFyc2U7XG5leHBvcnRzLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuIiwidmFyIHRvSW50SWZJbnQgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gU3RyaW5nKE51bWJlcih2KSkgPT09IHYgPyBOdW1iZXIodikgOiB2O1xufTtcblxudmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xuICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICBsb2NhdGlvbltyYXdOYW1lXSA9IHRvSW50SWZJbnQobWF0Y2hbMV0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChtYXRjaFtpKzFdICE9IG51bGwpIHtcbiAgICAgICAgbG9jYXRpb25bbmFtZXNbaV1dID0gdG9JbnRJZkludChtYXRjaFtpKzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gIHZhciBuZWVkc0JsYW5rID0gb2JqLm5hbWUgJiYgb2JqLm5hbWVzO1xuICBpZiAob2JqLnB1c2ggJiYgIWxvY2F0aW9uW29iai5wdXNoXSkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICB9XG4gIGVsc2UgaWYgKG5lZWRzQmxhbmsgJiYgIWxvY2F0aW9uW29iai5uYW1lXSkge1xuICAgIGxvY2F0aW9uW29iai5uYW1lXSA9IHt9O1xuICB9XG4gIHZhciBrZXlMb2NhdGlvbiA9IG9iai5wdXNoID9cbiAgICB7fSA6ICAvLyBibGFuayBvYmplY3QgdGhhdCB3aWxsIGJlIHB1c2hlZFxuICAgIG5lZWRzQmxhbmsgPyBsb2NhdGlvbltvYmoubmFtZV0gOiBsb2NhdGlvbjsgLy8gb3RoZXJ3aXNlLCBuYW1lZCBsb2NhdGlvbiBvciByb290XG5cbiAgYXR0YWNoUHJvcGVydGllcyhjb250ZW50Lm1hdGNoKG9iai5yZWcpLCBrZXlMb2NhdGlvbiwgb2JqLm5hbWVzLCBvYmoubmFtZSk7XG5cbiAgaWYgKG9iai5wdXNoKSB7XG4gICAgbG9jYXRpb25bb2JqLnB1c2hdLnB1c2goa2V5TG9jYXRpb24pO1xuICB9XG59O1xuXG52YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xudmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2RwKSB7XG4gIHZhciBzZXNzaW9uID0ge31cbiAgICAsIG1lZGlhID0gW11cbiAgICAsIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5maWx0ZXIodmFsaWRMaW5lKS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICBpZiAodHlwZSA9PT0gJ20nKSB7XG4gICAgICBtZWRpYS5wdXNoKHtydHA6IFtdLCBmbXRwOiBbXX0pO1xuICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGgtMV07IC8vIHBvaW50IGF0IGxhdGVzdCBtZWRpYSBsaW5lXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgaWYgKG9iai5yZWcudGVzdChjb250ZW50KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBzZXNzaW9uLm1lZGlhID0gbWVkaWE7IC8vIGxpbmsgaXQgdXBcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG52YXIgcGFyYW1SZWR1Y2VyID0gZnVuY3Rpb24gKGFjYywgZXhwcikge1xuICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgIGFjY1tzWzBdXSA9IHRvSW50SWZJbnQoc1sxXSk7XG4gIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgYWNjW3NbMF1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhY2M7XG59O1xuXG5leHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC87XFxzPy8pLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbn07XG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gYWxpYXMgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4wXG5leHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IGV4cG9ydHMucGFyc2VQYXJhbXM7XG5cbmV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG59O1xuXG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICBpcDogcGFydHNbaSArIDFdLFxuICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uc3Vic3RyaW5nKDEsIGl0ZW0ubGVuZ3RoLTEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHZhciBzY2lkLCBwYXVzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsInZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnJSUnOlxuICAgICAgcmV0dXJuICclJztcbiAgICBjYXNlICclcyc6XG4gICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgY2FzZSAnJWQnOlxuICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgIGNhc2UgJyV2JzpcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0pO1xuICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXG59O1xuXG52YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID9cbiAgICAob2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSkgOlxuICAgIG9iai5mb3JtYXQ7XG5cbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufTtcblxuLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbnZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFtcbiAgJ3YnLCAnbycsICdzJywgJ2knLFxuICAndScsICdlJywgJ3AnLCAnYycsXG4gICdiJywgJ3QnLCAncicsICd6JywgJ2EnXG5dO1xudmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gIH1cbiAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgfVxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuXG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrb2ZmID0gQmFja29mZjtcbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gICAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gICAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgIHRoaXMubXMgPSBtaW47XG59O1xuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG59O1xuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uIChqaXR0ZXIpIHtcbiAgICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViVHJhbnNwb3J0ID0gZXhwb3J0cy5XZWJTb2NrZXQgPSBleHBvcnRzLk5vZGVXZWJTb2NrZXQgPSBleHBvcnRzLlhIUiA9IGV4cG9ydHMuTm9kZVhIUiA9IGV4cG9ydHMuRmV0Y2ggPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMuTWFuYWdlciA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5leHBvcnRzLmlvID0gbG9va3VwO1xuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9va3VwO1xuY29uc3QgdXJsX2pzXzEgPSByZXF1aXJlKFwiLi91cmwuanNcIik7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi9tYW5hZ2VyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFuYWdlcl9qc18xLk1hbmFnZXI7IH0gfSk7XG5jb25zdCBzb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3NvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0X2pzXzEuU29ja2V0OyB9IH0pO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvLWNsaWVudFwiKTsgLy8gZGVidWcoKVxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRzID0gdXJpO1xuICAgICAgICB1cmkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGNvbnN0IHBhcnNlZCA9ICgwLCB1cmxfanNfMS51cmwpKHVyaSwgb3B0cy5wYXRoIHx8IFwiL3NvY2tldC5pb1wiKTtcbiAgICBjb25zdCBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICAgIGNvbnN0IGlkID0gcGFyc2VkLmlkO1xuICAgIGNvbnN0IHBhdGggPSBwYXJzZWQucGF0aDtcbiAgICBjb25zdCBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdW1wibnNwc1wiXTtcbiAgICBjb25zdCBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fFxuICAgICAgICBvcHRzW1wiZm9yY2UgbmV3IGNvbm5lY3Rpb25cIl0gfHxcbiAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8XG4gICAgICAgIHNhbWVOYW1lc3BhY2U7XG4gICAgbGV0IGlvO1xuICAgIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgICAgIGRlYnVnKFwiaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlc1wiLCBzb3VyY2UpO1xuICAgICAgICBpbyA9IG5ldyBtYW5hZ2VyX2pzXzEuTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIGRlYnVnKFwibmV3IGlvIGluc3RhbmNlIGZvciAlc1wiLCBzb3VyY2UpO1xuICAgICAgICAgICAgY2FjaGVbaWRdID0gbmV3IG1hbmFnZXJfanNfMS5NYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaW8gPSBjYWNoZVtpZF07XG4gICAgfVxuICAgIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICAgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeUtleTtcbiAgICB9XG4gICAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG4vLyBzbyB0aGF0IFwibG9va3VwXCIgY2FuIGJlIHVzZWQgYm90aCBhcyBhIGZ1bmN0aW9uIChlLmcuIGBpbyguLi4pYCkgYW5kIGFzIGFcbi8vIG5hbWVzcGFjZSAoZS5nLiBgaW8uY29ubmVjdCguLi4pYCksIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5PYmplY3QuYXNzaWduKGxvb2t1cCwge1xuICAgIE1hbmFnZXI6IG1hbmFnZXJfanNfMS5NYW5hZ2VyLFxuICAgIFNvY2tldDogc29ja2V0X2pzXzEuU29ja2V0LFxuICAgIGlvOiBsb29rdXAsXG4gICAgY29ubmVjdDogbG9va3VwLFxufSk7XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm90b2NvbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0X2lvX3BhcnNlcl8xLnByb3RvY29sOyB9IH0pO1xudmFyIGVuZ2luZV9pb19jbGllbnRfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZ2luZV9pb19jbGllbnRfMS5GZXRjaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vZGVYSFJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZ2luZV9pb19jbGllbnRfMS5Ob2RlWEhSOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWEhSXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmdpbmVfaW9fY2xpZW50XzEuWEhSOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9kZVdlYlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5naW5lX2lvX2NsaWVudF8xLk5vZGVXZWJTb2NrZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZ2luZV9pb19jbGllbnRfMS5XZWJTb2NrZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJUcmFuc3BvcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZ2luZV9pb19jbGllbnRfMS5XZWJUcmFuc3BvcnQ7IH0gfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9va3VwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGVuZ2luZV9pb19jbGllbnRfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tY2xpZW50XCIpO1xuY29uc3Qgc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQuanNcIik7XG5jb25zdCBwYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIikpO1xuY29uc3Qgb25fanNfMSA9IHJlcXVpcmUoXCIuL29uLmpzXCIpO1xuY29uc3QgYmFja28yX2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmliL2JhY2tvMi5qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pby1jbGllbnQ6bWFuYWdlclwiKTsgLy8gZGVidWcoKVxuY2xhc3MgTWFuYWdlciBleHRlbmRzIGNvbXBvbmVudF9lbWl0dGVyXzEuRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3BzID0ge307XG4gICAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgICAgICBpZiAodXJpICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1cmkpIHtcbiAgICAgICAgICAgIG9wdHMgPSB1cmk7XG4gICAgICAgICAgICB1cmkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCBcIi9zb2NrZXQuaW9cIjtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgKDAsIGVuZ2luZV9pb19jbGllbnRfMS5pbnN0YWxsVGltZXJGdW5jdGlvbnMpKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgICAgICAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKChfYSA9IG9wdHMucmFuZG9taXphdGlvbkZhY3RvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC41KTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvMl9qc18xLkJhY2tvZmYoe1xuICAgICAgICAgICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgICAgICAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICAgICAgICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgY29uc3QgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuX2F1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvQ29ubmVjdClcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb24odikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVjb25uZWN0aW9uQXR0ZW1wdHModikge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb25EZWxheSh2KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICAgICAgICAoX2EgPSB0aGlzLmJhY2tvZmYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRNaW4odik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByYW5kb21pemF0aW9uRmFjdG9yKHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gICAgICAgIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICAgICAgICAoX2EgPSB0aGlzLmJhY2tvZmYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRKaXR0ZXIodik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb25EZWxheU1heCh2KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICAgICAgICAoX2EgPSB0aGlzLmJhY2tvZmYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRNYXgodik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aW1lb3V0KHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gICAgICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1heWJlUmVjb25uZWN0T25PcGVuKCkge1xuICAgICAgICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gICAgICAgIGlmICghdGhpcy5fcmVjb25uZWN0aW5nICYmXG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb24gJiZcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAgICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIG9wZW4oZm4pIHtcbiAgICAgICAgZGVidWcoXCJyZWFkeVN0YXRlICVzXCIsIHRoaXMuX3JlYWR5U3RhdGUpO1xuICAgICAgICBpZiAofnRoaXMuX3JlYWR5U3RhdGUuaW5kZXhPZihcIm9wZW5cIikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZGVidWcoXCJvcGVuaW5nICVzXCIsIHRoaXMudXJpKTtcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBuZXcgZW5naW5lX2lvX2NsaWVudF8xLlNvY2tldCh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAvLyBlbWl0IGBvcGVuYFxuICAgICAgICBjb25zdCBvcGVuU3ViRGVzdHJveSA9ICgwLCBvbl9qc18xLm9uKShzb2NrZXQsIFwib3BlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9ub3BlbigpO1xuICAgICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZW1pdCBgZXJyb3JgXG4gICAgICAgIGNvbnN0IGVycm9yU3ViID0gKDAsIG9uX2pzXzEub24pKHNvY2tldCwgXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZFwiLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIC8vIHNldCB0aW1lclxuICAgICAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkXCIsIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIG9wZW5TdWJEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hdXRvVW5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGltZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob3BlblN1YkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Igb3BlbigpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29ubmVjdChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuKGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ub3BlbigpIHtcbiAgICAgICAgZGVidWcoXCJvcGVuXCIpO1xuICAgICAgICAvLyBjbGVhciBvbGQgc3Vic1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgLy8gbWFyayBhcyBvcGVuXG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICAgICAgICAvLyBhZGQgbmV3IHN1YnNcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKCgwLCBvbl9qc18xLm9uKShzb2NrZXQsIFwicGluZ1wiLCB0aGlzLm9ucGluZy5iaW5kKHRoaXMpKSwgKDAsIG9uX2pzXzEub24pKHNvY2tldCwgXCJkYXRhXCIsIHRoaXMub25kYXRhLmJpbmQodGhpcykpLCAoMCwgb25fanNfMS5vbikoc29ja2V0LCBcImVycm9yXCIsIHRoaXMub25lcnJvci5iaW5kKHRoaXMpKSwgKDAsIG9uX2pzXzEub24pKHNvY2tldCwgXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKSksIFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICgwLCBvbl9qc18xLm9uKSh0aGlzLmRlY29kZXIsIFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25waW5nKCkge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGF0YShkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJwYXJzZSBlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kZWNvZGVkKHBhY2tldCkge1xuICAgICAgICAvLyB0aGUgbmV4dFRpY2sgY2FsbCBwcmV2ZW50cyBhbiBleGNlcHRpb24gaW4gYSB1c2VyLXByb3ZpZGVkIGV2ZW50IGxpc3RlbmVyIGZyb20gdHJpZ2dlcmluZyBhIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGEgXCJwYXJzZSBlcnJvclwiXG4gICAgICAgICgwLCBlbmdpbmVfaW9fY2xpZW50XzEubmV4dFRpY2spKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICBkZWJ1ZyhcImVycm9yXCIsIGVycik7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0KG5zcCwgb3B0cykge1xuICAgICAgICBsZXQgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgICBzb2NrZXQgPSBuZXcgc29ja2V0X2pzXzEuU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgICAgICAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9hdXRvQ29ubmVjdCAmJiAhc29ja2V0LmFjdGl2ZSkge1xuICAgICAgICAgICAgc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb2NrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXN0cm95KHNvY2tldCkge1xuICAgICAgICBjb25zdCBuc3BzID0gT2JqZWN0LmtleXModGhpcy5uc3BzKTtcbiAgICAgICAgZm9yIChjb25zdCBuc3Agb2YgbnNwcykge1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gICAgICAgICAgICBpZiAoc29ja2V0LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic29ja2V0ICVzIGlzIHN0aWxsIGFjdGl2ZSwgc2tpcHBpbmcgY2xvc2VcIiwgbnNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhY2tldChwYWNrZXQpIHtcbiAgICAgICAgZGVidWcoXCJ3cml0aW5nIHBhY2tldCAlalwiLCBwYWNrZXQpO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgZGVidWcoXCJjbGVhbnVwXCIpO1xuICAgICAgICB0aGlzLnN1YnMuZm9yRWFjaCgoc3ViRGVzdHJveSkgPT4gc3ViRGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5zdWJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Nsb3NlKCkge1xuICAgICAgICBkZWJ1ZyhcImRpc2Nvbm5lY3RcIik7XG4gICAgICAgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBjbG9zZSgpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbjpcbiAgICAgKlxuICAgICAqIC0gdGhlIGxvdy1sZXZlbCBlbmdpbmUgaXMgY2xvc2VkXG4gICAgICogLSB0aGUgcGFyc2VyIGVuY291bnRlcmVkIGEgYmFkbHkgZm9ybWF0dGVkIHBhY2tldFxuICAgICAqIC0gYWxsIHNvY2tldHMgYXJlIGRpc2Nvbm5lY3RlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkZWJ1ZyhcImNsb3NlZCBkdWUgdG8gJXNcIiwgcmVhc29uKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgICAgZGVidWcoXCJyZWNvbm5lY3QgZmFpbGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9mYWlsZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgICAgICAgICBkZWJ1ZyhcIndpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdFwiLCBkZWxheSk7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiYXR0ZW1wdGluZyByZWNvbm5lY3RcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RfYXR0ZW1wdFwiLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlY29ubmVjdCBhdHRlbXB0IGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVjb25uZWN0IHN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbnJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdFwiLCBhdHRlbXB0KTtcbiAgICB9XG59XG5leHBvcnRzLk1hbmFnZXIgPSBNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uID0gb247XG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICAgIG9iai5vbihldiwgZm4pO1xuICAgIHJldHVybiBmdW5jdGlvbiBzdWJEZXN0cm95KCkge1xuICAgICAgICBvYmoub2ZmKGV2LCBmbik7XG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2NrZXQgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNvbnN0IG9uX2pzXzEgPSByZXF1aXJlKFwiLi9vbi5qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pby1jbGllbnQ6c29ja2V0XCIpOyAvLyBkZWJ1ZygpXG4vKipcbiAqIEludGVybmFsIGV2ZW50cy5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICovXG5jb25zdCBSRVNFUlZFRF9FVkVOVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBjb25uZWN0OiAxLFxuICAgIGNvbm5lY3RfZXJyb3I6IDEsXG4gICAgZGlzY29ubmVjdDogMSxcbiAgICBkaXNjb25uZWN0aW5nOiAxLFxuICAgIC8vIEV2ZW50RW1pdHRlciByZXNlcnZlZCBldmVudHM6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2V2ZW50X25ld2xpc3RlbmVyXG4gICAgbmV3TGlzdGVuZXI6IDEsXG4gICAgcmVtb3ZlTGlzdGVuZXI6IDEsXG59KTtcbi8qKlxuICogQSBTb2NrZXQgaXMgdGhlIGZ1bmRhbWVudGFsIGNsYXNzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBzZXJ2ZXIuXG4gKlxuICogQSBTb2NrZXQgYmVsb25ncyB0byBhIGNlcnRhaW4gTmFtZXNwYWNlIChieSBkZWZhdWx0IC8pIGFuZCB1c2VzIGFuIHVuZGVybHlpbmcge0BsaW5rIE1hbmFnZXJ9IHRvIGNvbW11bmljYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICpcbiAqIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhcImNvbm5lY3RlZFwiKTtcbiAqIH0pO1xuICpcbiAqIC8vIHNlbmQgYW4gZXZlbnQgdG8gdGhlIHNlcnZlclxuICogc29ja2V0LmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gKlxuICogc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgLy8gYW4gZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICogfSk7XG4gKlxuICogLy8gdXBvbiBkaXNjb25uZWN0aW9uXG4gKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAqICAgY29uc29sZS5sb2coYGRpc2Nvbm5lY3RlZCBkdWUgdG8gJHtyZWFzb259YCk7XG4gKiB9KTtcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgY29tcG9uZW50X2VtaXR0ZXJfMS5FbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbywgbnNwLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGNvbm5lY3RlZCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgd2FzIHJlY292ZXJlZCBhZnRlciBhIHRlbXBvcmFyeSBkaXNjb25uZWN0aW9uLiBJbiB0aGF0IGNhc2UsIGFueSBtaXNzZWQgcGFja2V0cyB3aWxsXG4gICAgICAgICAqIGJlIHRyYW5zbWl0dGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGZvciBwYWNrZXRzIHJlY2VpdmVkIGJlZm9yZSB0aGUgQ09OTkVDVCBwYWNrZXRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGZvciBwYWNrZXRzIHRoYXQgd2lsbCBiZSBzZW50IG9uY2UgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHF1ZXVlIG9mIHBhY2tldHMgdG8gYmUgc2VudCB3aXRoIHJldHJ5IGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogUGFja2V0cyBhcmUgc2VudCBvbmUgYnkgb25lLCBlYWNoIHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VtZW50LCBpbiBvcmRlciB0byBndWFyYW50ZWUgdGhlIGRlbGl2ZXJ5IG9yZGVyLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2VxdWVuY2UgdG8gZ2VuZXJhdGUgdGhlIElEIG9mIHRoZSB7QGxpbmsgUXVldWVkUGFja2V0fS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXVlU2VxID0gMDtcbiAgICAgICAgdGhpcy5pZHMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyBhY2tub3dsZWRnZW1lbnQgaGFuZGxlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgd2l0aEVycm9yYCBhdHRyaWJ1dGUgaXMgdXNlZCB0byBkaWZmZXJlbnRpYXRlIGhhbmRsZXJzIHRoYXQgYWNjZXB0IGFuIGVycm9yIGFzIGZpcnN0IGFyZ3VtZW50OlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBzb2NrZXQuZW1pdChcInRlc3RcIiwgKGVyciwgdmFsdWUpID0+IHsgLi4uIH0pYCB3aXRoIGBhY2tUaW1lb3V0YCBvcHRpb25cbiAgICAgICAgICogLSBgc29ja2V0LnRpbWVvdXQoNTAwMCkuZW1pdChcInRlc3RcIiwgKGVyciwgdmFsdWUpID0+IHsgLi4uIH0pYFxuICAgICAgICAgKiAtIGBjb25zdCB2YWx1ZSA9IGF3YWl0IHNvY2tldC5lbWl0V2l0aEFjayhcInRlc3RcIilgXG4gICAgICAgICAqXG4gICAgICAgICAqIEZyb20gdGhvc2UgdGhhdCBkb24ndDpcbiAgICAgICAgICpcbiAgICAgICAgICogLSBgc29ja2V0LmVtaXQoXCJ0ZXN0XCIsICh2YWx1ZSkgPT4geyAuLi4gfSk7YFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGhhbmRsZXJzIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbjpcbiAgICAgICAgICpcbiAgICAgICAgICogLSB0aGUgdGltZW91dCBpcyByZWFjaGVkXG4gICAgICAgICAqIC0gdGhlIHNvY2tldCBnZXRzIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZSBoYW5kbGVycyB3aWxsIGJlIHNpbXBseSBkaXNjYXJkZWQgdXBvbiBkaXNjb25uZWN0aW9uLCBzaW5jZSB0aGUgY2xpZW50IHdpbGwgbmV2ZXIgcmVjZWl2ZVxuICAgICAgICAgKiBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2tzID0ge307XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5pbyA9IGlvO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5pby5fYXV0b0Nvbm5lY3QpXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBkaXNjb25uZWN0ZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRpc2Nvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kaXNjb25uZWN0ZWQpOyAvLyB0cnVlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbm5lY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN1YkV2ZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3VicylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW8gPSB0aGlzLmlvO1xuICAgICAgICB0aGlzLnN1YnMgPSBbXG4gICAgICAgICAgICAoMCwgb25fanNfMS5vbikoaW8sIFwib3BlblwiLCB0aGlzLm9ub3Blbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgICgwLCBvbl9qc18xLm9uKShpbywgXCJwYWNrZXRcIiwgdGhpcy5vbnBhY2tldC5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgICgwLCBvbl9qc18xLm9uKShpbywgXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSksXG4gICAgICAgICAgICAoMCwgb25fanNfMS5vbikoaW8sIFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlLmJpbmQodGhpcykpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBTb2NrZXQgd2lsbCB0cnkgdG8gcmVjb25uZWN0IHdoZW4gaXRzIE1hbmFnZXIgY29ubmVjdHMgb3IgcmVjb25uZWN0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHNvY2tldC5hY3RpdmUpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAgICAgKiAgIGlmIChyZWFzb24gPT09IFwiaW8gc2VydmVyIGRpc2Nvbm5lY3RcIikge1xuICAgICAqICAgICAvLyB0aGUgZGlzY29ubmVjdGlvbiB3YXMgaW5pdGlhdGVkIGJ5IHRoZSBzZXJ2ZXIsIHlvdSBuZWVkIHRvIG1hbnVhbGx5IHJlY29ubmVjdFxuICAgICAqICAgICBjb25zb2xlLmxvZyhzb2NrZXQuYWN0aXZlKTsgLy8gZmFsc2VcbiAgICAgKiAgIH1cbiAgICAgKiAgIC8vIGVsc2UgdGhlIHNvY2tldCB3aWxsIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIHJlY29ubmVjdFxuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmFjdGl2ZSk7IC8vIHRydWVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnN1YnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbyh7XG4gICAgICogICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5jb25uZWN0KCk7XG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuc3ViRXZlbnRzKCk7XG4gICAgICAgIGlmICghdGhpcy5pb1tcIl9yZWNvbm5lY3RpbmdcIl0pXG4gICAgICAgICAgICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmlvLl9yZWFkeVN0YXRlKVxuICAgICAgICAgICAgdGhpcy5vbm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgY29ubmVjdCgpfS5cbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWltaWNzIHRoZSBXZWJTb2NrZXQuc2VuZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9zZW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICBhcmdzLnVuc2hpZnQoXCJtZXNzYWdlXCIpO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBgZW1pdGAuXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgMSwgXCIyXCIsIHsgMzogW1wiNFwiXSwgNTogVWludDhBcnJheS5mcm9tKFs2XSkgfSk7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIiwgKHZhbCkgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoUkVTRVJWRURfRVZFTlRTLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBldi50b1N0cmluZygpICsgJ1wiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MudW5zaGlmdChldik7XG4gICAgICAgIGlmICh0aGlzLl9vcHRzLnJldHJpZXMgJiYgIXRoaXMuZmxhZ3MuZnJvbVF1ZXVlICYmICF0aGlzLmZsYWdzLnZvbGF0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1F1ZXVlKGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICAgICAgICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9IHRoaXMuZmxhZ3MuY29tcHJlc3MgIT09IGZhbHNlO1xuICAgICAgICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmlkcysrO1xuICAgICAgICAgICAgZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgY29uc3QgYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjayk7XG4gICAgICAgICAgICBwYWNrZXQuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1RyYW5zcG9ydFdyaXRhYmxlID0gKF9iID0gKF9hID0gdGhpcy5pby5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc3BvcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53cml0YWJsZTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSB0aGlzLmNvbm5lY3RlZCAmJiAhKChfYyA9IHRoaXMuaW8uZW5naW5lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuX2hhc1BpbmdFeHBpcmVkKCkpO1xuICAgICAgICBjb25zdCBkaXNjYXJkUGFja2V0ID0gdGhpcy5mbGFncy52b2xhdGlsZSAmJiAhaXNUcmFuc3BvcnRXcml0YWJsZTtcbiAgICAgICAgaWYgKGRpc2NhcmRQYWNrZXQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZGlzY2FyZCBwYWNrZXQgYXMgdGhlIHRyYW5zcG9ydCBpcyBub3QgY3VycmVudGx5IHdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF9hID0gdGhpcy5mbGFncy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9vcHRzLmFja1RpbWVvdXQ7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNrc1tpZF0gPSBhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuaW8uc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZW5kQnVmZmVyW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlbW92aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCBmcm9tIHRoZSBidWZmZXJcIiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKFwiZXZlbnQgd2l0aCBhY2sgaWQgJWQgaGFzIHRpbWVkIG91dCBhZnRlciAlZCBtc1wiLCBpZCwgdGltZW91dCk7XG4gICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLmlvLmNsZWFyVGltZW91dEZuKHRpbWVyKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4ud2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY2tzW2lkXSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhbmQgd2FpdHMgZm9yIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB3aXRob3V0IHRpbWVvdXRcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC5lbWl0V2l0aEFjayhcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgc3BlY2lmaWMgdGltZW91dFxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC50aW1lb3V0KDEwMDApLmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKiB9IGNhdGNoIChlcnIpIHtcbiAgICAgKiAgIC8vIHRoZSBzZXJ2ZXIgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IChhcmcxLCBhcmcyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZzEgPyByZWplY3QoYXJnMSkgOiByZXNvbHZlKGFyZzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLndpdGhFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBhcmdzLnB1c2goZm4pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcGFja2V0IHRvIHRoZSBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZFRvUXVldWUoYXJncykge1xuICAgICAgICBsZXQgYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9xdWV1ZVNlcSsrLFxuICAgICAgICAgICAgdHJ5Q291bnQ6IDAsXG4gICAgICAgICAgICBwZW5kaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBmbGFnczogT2JqZWN0LmFzc2lnbih7IGZyb21RdWV1ZTogdHJ1ZSB9LCB0aGlzLmZsYWdzKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXJncy5wdXNoKChlcnIsIC4uLnJlc3BvbnNlQXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKHBhY2tldCAhPT0gdGhpcy5fcXVldWVbMF0pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFja2V0IGhhcyBhbHJlYWR5IGJlZW4gYWNrbm93bGVkZ2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzRXJyb3IgPSBlcnIgIT09IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LnRyeUNvdW50ID4gdGhpcy5fb3B0cy5yZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicGFja2V0IFslZF0gaXMgZGlzY2FyZGVkIGFmdGVyICVkIHRyaWVzXCIsIHBhY2tldC5pZCwgcGFja2V0LnRyeUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInBhY2tldCBbJWRdIHdhcyBzdWNjZXNzZnVsbHkgc2VudFwiLCBwYWNrZXQuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjaykge1xuICAgICAgICAgICAgICAgICAgICBhY2sobnVsbCwgLi4ucmVzcG9uc2VBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWNrZXQucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFja2V0KTtcbiAgICAgICAgdGhpcy5fZHJhaW5RdWV1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHF1ZXVlLCBhbmQgd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gZm9yY2UgLSB3aGV0aGVyIHRvIHJlc2VuZCBhIHBhY2tldCB0aGF0IGhhcyBub3QgYmVlbiBhY2tub3dsZWRnZWQgeWV0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmFpblF1ZXVlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgZGVidWcoXCJkcmFpbmluZyBxdWV1ZVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCB8fCB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9xdWV1ZVswXTtcbiAgICAgICAgaWYgKHBhY2tldC5wZW5kaW5nICYmICFmb3JjZSkge1xuICAgICAgICAgICAgZGVidWcoXCJwYWNrZXQgWyVkXSBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgYW5kIGlzIHdhaXRpbmcgZm9yIGFuIGFja1wiLCBwYWNrZXQuaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhY2tldC5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcGFja2V0LnRyeUNvdW50Kys7XG4gICAgICAgIGRlYnVnKFwic2VuZGluZyBwYWNrZXQgWyVkXSAodHJ5IG7CsCVkKVwiLCBwYWNrZXQuaWQsIHBhY2tldC50cnlDb3VudCk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBwYWNrZXQuZmxhZ3M7XG4gICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBwYWNrZXQuYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcGFja2V0KHBhY2tldCkge1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gICAgICAgIHRoaXMuaW8uX3BhY2tldChwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbm9wZW4oKSB7XG4gICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXV0aCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb25uZWN0UGFja2V0KGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29ubmVjdFBhY2tldCh0aGlzLmF1dGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgQ09OTkVDVCBwYWNrZXQgdG8gaW5pdGlhdGUgdGhlIFNvY2tldC5JTyBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kQ29ubmVjdFBhY2tldChkYXRhKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9waWRcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oeyBwaWQ6IHRoaXMuX3BpZCwgb2Zmc2V0OiB0aGlzLl9sYXN0T2Zmc2V0IH0sIGRhdGEpXG4gICAgICAgICAgICAgICAgOiBkYXRhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIG9yIG1hbmFnZXIgYGVycm9yYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdF9lcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2UgKCVzKVwiLCByZWFzb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy5pZDtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkaXNjb25uZWN0XCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLl9jbGVhckFja3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBhY2tub3dsZWRnZW1lbnQgaGFuZGxlcnMgdXBvbiBkaXNjb25uZWN0aW9uLCBzaW5jZSB0aGUgY2xpZW50IHdpbGwgbmV2ZXIgcmVjZWl2ZSBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbVxuICAgICAqIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckFja3MoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNrcykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQnVmZmVyZWQgPSB0aGlzLnNlbmRCdWZmZXIuc29tZSgocGFja2V0KSA9PiBTdHJpbmcocGFja2V0LmlkKSA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKCFpc0J1ZmZlcmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZTogaGFuZGxlcnMgdGhhdCBkbyBub3QgYWNjZXB0IGFuIGVycm9yIGFzIGZpcnN0IGFyZ3VtZW50IGFyZSBpZ25vcmVkIGhlcmVcbiAgICAgICAgICAgICAgICBjb25zdCBhY2sgPSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChhY2sud2l0aEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjay5jYWxsKHRoaXMsIG5ldyBFcnJvcihcInNvY2tldCBoYXMgYmVlbiBkaXNjb25uZWN0ZWRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbnBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgY29uc3Qgc2FtZU5hbWVzcGFjZSA9IHBhY2tldC5uc3AgPT09IHRoaXMubnNwO1xuICAgICAgICBpZiAoIXNhbWVOYW1lc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LmRhdGEgJiYgcGFja2V0LmRhdGEuc2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jb25uZWN0KHBhY2tldC5kYXRhLnNpZCwgcGFja2V0LmRhdGEucGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdF9lcnJvclwiLCBuZXcgRXJyb3IoXCJJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byByZWFjaCBhIFNvY2tldC5JTyBzZXJ2ZXIgaW4gdjIueCB3aXRoIGEgdjMueCBjbGllbnQsIGJ1dCB0aGV5IGFyZSBub3QgY29tcGF0aWJsZSAobW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL3NvY2tldC5pby9kb2NzL3YzL21pZ3JhdGluZy1mcm9tLTIteC10by0zLTAvKVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5FVkVOVDpcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQklOQVJZX0VWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKHBhY2tldC5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBlcnIuZGF0YSA9IHBhY2tldC5kYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmV2ZW50KHBhY2tldCkge1xuICAgICAgICBjb25zdCBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gICAgICAgIGRlYnVnKFwiZW1pdHRpbmcgZXZlbnQgJWpcIiwgYXJncyk7XG4gICAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50XCIpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChPYmplY3QuZnJlZXplKGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0RXZlbnQoYXJncykge1xuICAgICAgICBpZiAodGhpcy5fYW55TGlzdGVuZXJzICYmIHRoaXMuX2FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAodGhpcy5fcGlkICYmIGFyZ3MubGVuZ3RoICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RPZmZzZXQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWNrKGlkKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgc2VudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHNlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgICAgICBkZWJ1ZyhcInNlbmRpbmcgYWNrICVqXCIsIGFyZ3MpO1xuICAgICAgICAgICAgc2VsZi5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSyxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWRnZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmFjayhwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gICAgICAgIGlmICh0eXBlb2YgYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYmFkIGFjayAlc1wiLCBwYWNrZXQuaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgICAgICAgZGVidWcoXCJjYWxsaW5nIGFjayAlcyB3aXRoICVqXCIsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FIGFjayBpcyBpbmNvcnJlY3RseSBpbmZlcnJlZCBhcyAnbmV2ZXInXG4gICAgICAgIGlmIChhY2sud2l0aEVycm9yKSB7XG4gICAgICAgICAgICBwYWNrZXQuZGF0YS51bnNoaWZ0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY29ubmVjdChpZCwgcGlkKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGNvbm5lY3RlZCB3aXRoIGlkICVzXCIsIGlkKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IHBpZCAmJiB0aGlzLl9waWQgPT09IHBpZDtcbiAgICAgICAgdGhpcy5fcGlkID0gcGlkOyAvLyBkZWZpbmVkIG9ubHkgaWYgY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0XCIpO1xuICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlbWl0QnVmZmVyZWQoKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5mb3JFYWNoKChhcmdzKSA9PiB0aGlzLmVtaXRFdmVudChhcmdzKSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgocGFja2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwic2VydmVyIGRpc2Nvbm5lY3QgKCVzKVwiLCB0aGlzLm5zcCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAgICAgKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICAgICAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzKSB7XG4gICAgICAgICAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKChzdWJEZXN0cm95KSA9PiBzdWJEZXN0cm95KCkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW9bXCJfZGVzdHJveVwiXSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS4gSW4gdGhhdCBjYXNlLCB0aGUgc29ja2V0IHdpbGwgbm90IHRyeSB0byByZWNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIHRoZSBsYXN0IGFjdGl2ZSBTb2NrZXQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBNYW5hZ2VyfSwgdGhlIGxvdy1sZXZlbCBjb25uZWN0aW9uIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICAgICAqXG4gICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gICAgICogICAvLyBjb25zb2xlLmxvZyhyZWFzb24pOyBwcmludHMgXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInBlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpXCIsIHRoaXMubnNwKTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBmaXJlIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKFwiaW8gY2xpZW50IGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgZGlzY29ubmVjdCgpfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBtZXNzYWdlIHdpbGwgYmUgZHJvcHBlZCB3aGVuIHRoaXMgc29ja2V0IGlzIG5vdFxuICAgICAqIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBzZXJ2ZXIgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgdGhpcy5mbGFncy52b2xhdGlsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgICogZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgd2l0aG91dCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgc2VydmVyOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyB0aGUgc2VydmVyIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLmZsYWdzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQub25BbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnByZXBlbmRBbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBnb3QgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzb2NrZXQub25BbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAqIHNvY2tldC5vZmZBbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyBvciByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqIHNvY2tldC5vZmZBbnkoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9mZkFueShsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueUxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogTm90ZTogYWNrbm93bGVkZ2VtZW50cyBzZW50IHRvIHRoZSBzZXJ2ZXIgYXJlIG5vdCBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0Lm9uQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgc2VydmVyIGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5wcmVwZW5kQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgcHJlcGVuZEFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogc29ja2V0Lm9uQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAqIHNvY2tldC5vZmZBbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogc29ja2V0Lm9mZkFueU91dGdvaW5nKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2xpc3RlbmVyXSAtIHRoZSBjYXRjaC1hbGwgbGlzdGVuZXIgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIG9mZkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55T3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBsaXN0ZW5lcnMgZm9yIGVhY2ggcGFja2V0IHNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyAmJiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVybCA9IHVybDtcbmNvbnN0IGVuZ2luZV9pb19jbGllbnRfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tY2xpZW50XCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvLWNsaWVudDp1cmxcIik7IC8vIGRlYnVnKClcbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0gdXJpIC0gdXJsXG4gKiBAcGFyYW0gcGF0aCAtIHRoZSByZXF1ZXN0IHBhdGggb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBsb2MgLSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXJsKHVyaSwgcGF0aCA9IFwiXCIsIGxvYykge1xuICAgIGxldCBvYmogPSB1cmk7XG4gICAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgICBsb2MgPSBsb2MgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBsb2NhdGlvbik7XG4gICAgaWYgKG51bGwgPT0gdXJpKVxuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2MuaG9zdDtcbiAgICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoXCIvXCIgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGlmIChcIi9cIiA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInByb3RvY29sLWxlc3MgdXJsICVzXCIsIHVyaSk7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIFwiLy9cIiArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZVxuICAgICAgICBkZWJ1ZyhcInBhcnNlICVzXCIsIHVyaSk7XG4gICAgICAgIG9iaiA9ICgwLCBlbmdpbmVfaW9fY2xpZW50XzEucGFyc2UpKHVyaSk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICAgIGlmICghb2JqLnBvcnQpIHtcbiAgICAgICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICBvYmoucG9ydCA9IFwiODBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgIG9iai5wb3J0ID0gXCI0NDNcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYmoucGF0aCA9IG9iai5wYXRoIHx8IFwiL1wiO1xuICAgIGNvbnN0IGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKFwiOlwiKSAhPT0gLTE7XG4gICAgY29uc3QgaG9zdCA9IGlwdjYgPyBcIltcIiArIG9iai5ob3N0ICsgXCJdXCIgOiBvYmouaG9zdDtcbiAgICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gICAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgXCI6Ly9cIiArIGhvc3QgKyBcIjpcIiArIG9iai5wb3J0ICsgcGF0aDtcbiAgICAvLyBkZWZpbmUgaHJlZlxuICAgIG9iai5ocmVmID1cbiAgICAgICAgb2JqLnByb3RvY29sICtcbiAgICAgICAgICAgIFwiOi8vXCIgK1xuICAgICAgICAgICAgaG9zdCArXG4gICAgICAgICAgICAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/IFwiXCIgOiBcIjpcIiArIG9iai5wb3J0KTtcbiAgICByZXR1cm4gb2JqO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBleHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gdm9pZCAwO1xuY29uc3QgaXNfYmluYXJ5X2pzXzEgPSByZXF1aXJlKFwiLi9pcy1iaW5hcnkuanNcIik7XG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIHwgQmxvYiB8IEZpbGUgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGNvbnN0IHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICBjb25zdCBwYWNrID0gcGFja2V0O1xuICAgIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICAgIHJldHVybiB7IHBhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVycyB9O1xufVxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGRlY29uc3RydWN0UGFja2V0O1xuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGlmICgoMCwgaXNfYmluYXJ5X2pzXzEuaXNCaW5hcnkpKGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LCBidWZmZXJzKSB7XG4gICAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICAgIGRlbGV0ZSBwYWNrZXQuYXR0YWNobWVudHM7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgICByZXR1cm4gcGFja2V0O1xufVxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IHJlY29uc3RydWN0UGFja2V0O1xuZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGlzSW5kZXhWYWxpZCA9IHR5cGVvZiBkYXRhLm51bSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgZGF0YS5udW0gPj0gMCAmJlxuICAgICAgICAgICAgZGF0YS5udW0gPCBidWZmZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGlzSW5kZXhWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgYXR0YWNobWVudHNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVjb2RlciA9IGV4cG9ydHMuRW5jb2RlciA9IGV4cG9ydHMuUGFja2V0VHlwZSA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5jb25zdCBjb21wb25lbnRfZW1pdHRlcl8xID0gcmVxdWlyZShcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIik7XG5jb25zdCBiaW5hcnlfanNfMSA9IHJlcXVpcmUoXCIuL2JpbmFyeS5qc1wiKTtcbmNvbnN0IGlzX2JpbmFyeV9qc18xID0gcmVxdWlyZShcIi4vaXMtYmluYXJ5LmpzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pby1wYXJzZXJcIik7IC8vIGRlYnVnKClcbi8qKlxuICogVGhlc2Ugc3RyaW5ncyBtdXN0IG5vdCBiZSB1c2VkIGFzIGV2ZW50IG5hbWVzLCBhcyB0aGV5IGhhdmUgYSBzcGVjaWFsIG1lYW5pbmcuXG4gKi9cbmNvbnN0IFJFU0VSVkVEX0VWRU5UUyA9IFtcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbm5lY3RfZXJyb3JcIixcbiAgICBcImRpc2Nvbm5lY3RcIixcbiAgICBcImRpc2Nvbm5lY3RpbmdcIixcbiAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgXCJyZW1vdmVMaXN0ZW5lclwiLCAvLyB1c2VkIGJ5IHRoZSBOb2RlLmpzIEV2ZW50RW1pdHRlclxuXTtcbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMucHJvdG9jb2wgPSA1O1xudmFyIFBhY2tldFR5cGU7XG4oZnVuY3Rpb24gKFBhY2tldFR5cGUpIHtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUXCJdID0gMF0gPSBcIkNPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJESVNDT05ORUNUXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJFVkVOVFwiXSA9IDJdID0gXCJFVkVOVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkFDS1wiXSA9IDNdID0gXCJBQ0tcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUX0VSUk9SXCJdID0gNF0gPSBcIkNPTk5FQ1RfRVJST1JcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJCSU5BUllfRVZFTlRcIl0gPSA1XSA9IFwiQklOQVJZX0VWRU5UXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0FDS1wiXSA9IDZdID0gXCJCSU5BUllfQUNLXCI7XG59KShQYWNrZXRUeXBlID0gZXhwb3J0cy5QYWNrZXRUeXBlIHx8IChleHBvcnRzLlBhY2tldFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICAgIC8qKlxuICAgICAqIEVuY29kZXIgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlcGxhY2VyIC0gY3VzdG9tIHJlcGxhY2VyIHRvIHBhc3MgZG93biB0byBKU09OLnBhcnNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVwbGFjZXIpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAgICAgKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gICAgICovXG4gICAgZW5jb2RlKG9iaikge1xuICAgICAgICBkZWJ1ZyhcImVuY29kaW5nIHBhY2tldCAlalwiLCBvYmopO1xuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlQgfHwgb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQUNLKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGlzX2JpbmFyeV9qc18xLmhhc0JpbmFyeSkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZUFzQmluYXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gUGFja2V0VHlwZS5CSU5BUllfRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogUGFja2V0VHlwZS5CSU5BUllfQUNLLFxuICAgICAgICAgICAgICAgICAgICBuc3A6IG9iai5uc3AsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9iai5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpZDogb2JqLmlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy5lbmNvZGVBc1N0cmluZyhvYmopXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gICAgICAgIC8vIGZpcnN0IGlzIHR5cGVcbiAgICAgICAgbGV0IHN0ciA9IFwiXCIgKyBvYmoudHlwZTtcbiAgICAgICAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfRVZFTlQgfHxcbiAgICAgICAgICAgIG9iai50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyBcIi1cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gICAgICAgIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICAgICAgICBpZiAob2JqLm5zcCAmJiBcIi9cIiAhPT0gb2JqLm5zcCkge1xuICAgICAgICAgICAgc3RyICs9IG9iai5uc3AgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGpzb24gZGF0YVxuICAgICAgICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgICAgICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9iai5kYXRhLCB0aGlzLnJlcGxhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcImVuY29kZWQgJWogYXMgJXNcIiwgb2JqLCBzdHIpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAgICAgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gICAgICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gICAgICovXG4gICAgZW5jb2RlQXNCaW5hcnkob2JqKSB7XG4gICAgICAgIGNvbnN0IGRlY29uc3RydWN0aW9uID0gKDAsIGJpbmFyeV9qc18xLmRlY29uc3RydWN0UGFja2V0KShvYmopO1xuICAgICAgICBjb25zdCBwYWNrID0gdGhpcy5lbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcbiAgICAgICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgICAgICByZXR1cm4gYnVmZmVyczsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gICAgfVxufVxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2Rlcjtcbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTExMjgxL2NoZWNrLWlmLWEtdmFsdWUtaXMtYW4tb2JqZWN0LWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqL1xuY2xhc3MgRGVjb2RlciBleHRlbmRzIGNvbXBvbmVudF9lbWl0dGVyXzEuRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmV2aXZlciAtIGN1c3RvbSByZXZpdmVyIHRvIHBhc3MgZG93biB0byBKU09OLnN0cmluZ2lmeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldml2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBlbmNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICAgICAqL1xuICAgIGFkZChvYmopIHtcbiAgICAgICAgbGV0IHBhY2tldDtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnb3QgcGxhaW50ZXh0IGRhdGEgd2hlbiByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhY2tldCA9IHRoaXMuZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeUV2ZW50ID0gcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UO1xuICAgICAgICAgICAgaWYgKGlzQmluYXJ5RXZlbnQgfHwgcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgICAgIHBhY2tldC50eXBlID0gaXNCaW5hcnlFdmVudCA/IFBhY2tldFR5cGUuRVZFTlQgOiBQYWNrZXRUeXBlLkFDSztcbiAgICAgICAgICAgICAgICAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpc19iaW5hcnlfanNfMS5pc0JpbmFyeSkob2JqKSB8fCBvYmouYmFzZTY0KSB7XG4gICAgICAgICAgICAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvLyBsb29rIHVwIHR5cGVcbiAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFBhY2tldFR5cGVbcC50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHBhY2tldCB0eXBlIFwiICsgcC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gICAgICAgIGlmIChwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09IFwiLVwiICYmIGkgIT0gc3RyLmxlbmd0aCkgeyB9XG4gICAgICAgICAgICBjb25zdCBidWYgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gICAgICAgIGlmIChcIi9cIiA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiLFwiID09PSBjKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLm5zcCA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5uc3AgPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGlkXG4gICAgICAgIGNvbnN0IG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgaWYgKFwiXCIgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmlkID0gTnVtYmVyKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMudHJ5UGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgICAgICAgICBpZiAoRGVjb2Rlci5pc1BheWxvYWRWYWxpZChwLnR5cGUsIHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcImRlY29kZWQgJXMgYXMgJWpcIiwgc3RyLCBwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHRyeVBhcnNlKHN0cikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCB0aGlzLnJldml2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzUGF5bG9hZFZhbGlkKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QocGF5bG9hZCk7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiIHx8IGlzT2JqZWN0KHBheWxvYWQpO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBwYXlsb2FkWzBdID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHBheWxvYWRbMF0gPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRVNFUlZFRF9FVkVOVFMuaW5kZXhPZihwYXlsb2FkWzBdKSA9PT0gLTEpKSk7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQUNLOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQmluYXJ5UmVjb25zdHJ1Y3RvciB7XG4gICAgY29uc3RydWN0b3IocGFja2V0KSB7XG4gICAgICAgIHRoaXMucGFja2V0ID0gcGFja2V0O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAgICAgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICAgICAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gICAgICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAgICovXG4gICAgdGFrZUJpbmFyeURhdGEoYmluRGF0YSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9ICgwLCBiaW5hcnlfanNfMS5yZWNvbnN0cnVjdFBhY2tldCkodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBmaW5pc2hlZFJlY29uc3RydWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNCaW5hcnkgPSBleHBvcnRzLmlzQmluYXJ5ID0gdm9pZCAwO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1ZpZXcgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IEFycmF5QnVmZmVyLmlzVmlldyhvYmopXG4gICAgICAgIDogb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKEJsb2IpID09PSBcIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXVwiKTtcbmNvbnN0IHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKEZpbGUpID09PSBcIltvYmplY3QgRmlsZUNvbnN0cnVjdG9yXVwiKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIEJ1ZmZlciwgYW4gQXJyYXlCdWZmZXIsIGEgQmxvYiBvciBhIEZpbGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gICAgcmV0dXJuICgod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcob2JqKSkpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpO1xufVxuZXhwb3J0cy5pc0JpbmFyeSA9IGlzQmluYXJ5O1xuZnVuY3Rpb24gaGFzQmluYXJ5KG9iaiwgdG9KU09OKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0JpbmFyeShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnRvSlNPTiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNCaW5hcnkgPSBoYXNCaW5hcnk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIi8qIFVBUGFyc2VyLmpzIHYyLjAuMVxuICAgQ29weXJpZ2h0IMKpIDIwMTItMjAyNCBGYWlzYWwgU2FsbWFuIDxmQGZhaXNhbG1hbi5jb20+XG4gICBBR1BMdjMgTGljZW5zZSAqL1xuKChpLGwpPT57ZnVuY3Rpb24gSShpKXtmb3IodmFyIGU9e30sdD0wO3Q8aS5sZW5ndGg7dCsrKWVbaVt0XS50b1VwcGVyQ2FzZSgpXT1pW3RdO3JldHVybiBlfXZhciBNPTUwMCxVPVwidXNlci1hZ2VudFwiLHc9XCJcIixSPVwiP1wiLFY9XCJmdW5jdGlvblwiLG49XCJ1bmRlZmluZWRcIixjPVwib2JqZWN0XCIsTD1cInN0cmluZ1wiLHU9XCJicm93c2VyXCIsaD1cImNwdVwiLHA9XCJkZXZpY2VcIixtPVwiZW5naW5lXCIsZj1cIm9zXCIsZz1cInJlc3VsdFwiLHY9XCJuYW1lXCIsaz1cInR5cGVcIix4PVwidmVuZG9yXCIseT1cInZlcnNpb25cIixDPVwiYXJjaGl0ZWN0dXJlXCIsQj1cIm1ham9yXCIsVD1cIm1vZGVsXCIsRz1cImNvbnNvbGVcIixTPVwibW9iaWxlXCIscj1cInRhYmxldFwiLGU9XCJzbWFydHR2XCIsdD1cIndlYXJhYmxlXCIsRj1cInhyXCIsRD1cImVtYmVkZGVkXCIsJD1cImluYXBwXCIsVz1cImJyYW5kc1wiLF89XCJmb3JtRmFjdG9yc1wiLFg9XCJmdWxsVmVyc2lvbkxpc3RcIixxPVwicGxhdGZvcm1cIixLPVwicGxhdGZvcm1WZXJzaW9uXCIsUT1cImJpdG5lc3NcIixvPVwic2VjLWNoLXVhXCIsWj1vK1wiLWZ1bGwtdmVyc2lvbi1saXN0XCIsWT1vK1wiLWFyY2hcIixKPW8rXCItXCIrUSxpaT1vK1wiLWZvcm0tZmFjdG9yc1wiLGVpPW8rXCItXCIrUyx0aT1vK1wiLVwiK1Qsb2k9bytcIi1cIitxLHJpPW9pK1wiLXZlcnNpb25cIixhaT1bVyxYLFMsVCxxLEssQyxfLFFdLHNpPVwiQW1hem9uXCIsYT1cIkFwcGxlXCIsbmk9XCJBU1VTXCIsd2k9XCJCbGFja0JlcnJ5XCIscz1cIkdvb2dsZVwiLGJpPVwiSHVhd2VpXCIsZGk9XCJNaWNyb3NvZnRcIixsaT1cIk1vdG9yb2xhXCIsY2k9XCJOdmlkaWFcIix1aT1cIk9uZVBsdXNcIixoaT1cIk9QUE9cIixwaT1cIlNhbXN1bmdcIixtaT1cIlNvbnlcIixmaT1cIlhpYW9taVwiLGdpPVwiWmVicmFcIix2aT1cIkNocm9taXVtXCIsYj1cIkNocm9tZWNhc3RcIixraT1cIkZpcmVmb3hcIixkPVwiT3BlcmFcIix4aT1cIkZhY2Vib29rXCIsej1cIk1vYmlsZSBcIix5aT1cIiBCcm93c2VyXCIsQ2k9XCJXaW5kb3dzXCIsVGk9dHlwZW9mIGkhPT1uLEE9VGkmJmkubmF2aWdhdG9yP2kubmF2aWdhdG9yOmwsTz1BJiZBLnVzZXJBZ2VudERhdGE/QS51c2VyQWdlbnREYXRhOmwsU2k9ZnVuY3Rpb24oaSxlKXtpZih0eXBlb2YgaT09PWMmJjA8aS5sZW5ndGgpe2Zvcih2YXIgdCBpbiBpKWlmKGooaVt0XSk9PWooZSkpcmV0dXJuITA7cmV0dXJuITF9cmV0dXJuISFIKGkpJiYtMSE9PWooZSkuaW5kZXhPZihqKGkpKX0sX2k9ZnVuY3Rpb24oaSxlKXtmb3IodmFyIHQgaW4gaSlyZXR1cm4vXihicm93c2VyfGNwdXxkZXZpY2V8ZW5naW5lfG9zKSQvLnRlc3QodCl8fCEhZSYmX2koaVt0XSl9LEg9ZnVuY3Rpb24oaSl7cmV0dXJuIHR5cGVvZiBpPT09TH0scWk9ZnVuY3Rpb24oaSl7aWYoIWkpcmV0dXJuIGw7Zm9yKHZhciBlLHQ9W10sbz1BaSgvXFxcXD9cXFwiL2csaSkuc3BsaXQoXCIsXCIpLHI9MDtyPG8ubGVuZ3RoO3IrKyktMTxvW3JdLmluZGV4T2YoXCI7XCIpPyhlPUhpKG9bcl0pLnNwbGl0KFwiO3Y9XCIpLHRbcl09e2JyYW5kOmVbMF0sdmVyc2lvbjplWzFdfSk6dFtyXT1IaShvW3JdKTtyZXR1cm4gdH0saj1mdW5jdGlvbihpKXtyZXR1cm4gSChpKT9pLnRvTG93ZXJDYXNlKCk6aX0semk9ZnVuY3Rpb24oaSl7cmV0dXJuIEgoaSk/QWkoL1teXFxkXFwuXS9nLGkpLnNwbGl0KFwiLlwiKVswXTpsfSxOPWZ1bmN0aW9uKGkpe2Zvcih2YXIgZSBpbiBpKXtlPWlbZV07dHlwZW9mIGU9PWMmJjI9PWUubGVuZ3RoP3RoaXNbZVswXV09ZVsxXTp0aGlzW2VdPWx9cmV0dXJuIHRoaXN9LEFpPWZ1bmN0aW9uKGksZSl7cmV0dXJuIEgoZSk/ZS5yZXBsYWNlKGksdyk6ZX0sT2k9ZnVuY3Rpb24oaSl7cmV0dXJuIEFpKC9cXFxcP1xcXCIvZyxpKX0sSGk9ZnVuY3Rpb24oaSxlKXtpZihIKGkpKXJldHVybiBpPUFpKC9eXFxzXFxzKi8saSksdHlwZW9mIGU9PT1uP2k6aS5zdWJzdHJpbmcoMCxNKX0samk9ZnVuY3Rpb24oaSxlKXtpZihpJiZlKWZvcih2YXIgdCxvLHIsYSxzLG49MDtuPGUubGVuZ3RoJiYhYTspe2Zvcih2YXIgdz1lW25dLGI9ZVtuKzFdLGQ9dD0wO2Q8dy5sZW5ndGgmJiFhJiZ3W2RdOylpZihhPXdbZCsrXS5leGVjKGkpKWZvcihvPTA7bzxiLmxlbmd0aDtvKyspcz1hWysrdF0sdHlwZW9mKHI9YltvXSk9PT1jJiYwPHIubGVuZ3RoPzI9PT1yLmxlbmd0aD90eXBlb2YgclsxXT09Vj90aGlzW3JbMF1dPXJbMV0uY2FsbCh0aGlzLHMpOnRoaXNbclswXV09clsxXTozPT09ci5sZW5ndGg/dHlwZW9mIHJbMV0hPT1WfHxyWzFdLmV4ZWMmJnJbMV0udGVzdD90aGlzW3JbMF1dPXM/cy5yZXBsYWNlKHJbMV0sclsyXSk6bDp0aGlzW3JbMF1dPXM/clsxXS5jYWxsKHRoaXMscyxyWzJdKTpsOjQ9PT1yLmxlbmd0aCYmKHRoaXNbclswXV09cz9yWzNdLmNhbGwodGhpcyxzLnJlcGxhY2UoclsxXSxyWzJdKSk6bCk6dGhpc1tyXT1zfHxsO24rPTJ9fSxFPWZ1bmN0aW9uKGksZSl7Zm9yKHZhciB0IGluIGUpaWYodHlwZW9mIGVbdF09PT1jJiYwPGVbdF0ubGVuZ3RoKXtmb3IodmFyIG89MDtvPGVbdF0ubGVuZ3RoO28rKylpZihTaShlW3RdW29dLGkpKXJldHVybiB0PT09Uj9sOnR9ZWxzZSBpZihTaShlW3RdLGkpKXJldHVybiB0PT09Uj9sOnQ7cmV0dXJuIGUuaGFzT3duUHJvcGVydHkoXCIqXCIpP2VbXCIqXCJdOml9LE5pPXtNRTpcIjQuOTBcIixcIk5UIDMuMTFcIjpcIk5UMy41MVwiLFwiTlQgNC4wXCI6XCJOVDQuMFwiLDJlMzpcIk5UIDUuMFwiLFhQOltcIk5UIDUuMVwiLFwiTlQgNS4yXCJdLFZpc3RhOlwiTlQgNi4wXCIsNzpcIk5UIDYuMVwiLDg6XCJOVCA2LjJcIiw4LjE6XCJOVCA2LjNcIiwxMDpbXCJOVCA2LjRcIixcIk5UIDEwLjBcIl0sUlQ6XCJBUk1cIn0sRWk9e2VtYmVkZGVkOlwiQXV0b21vdGl2ZVwiLG1vYmlsZTpcIk1vYmlsZVwiLHRhYmxldDpbXCJUYWJsZXRcIixcIkVJbmtcIl0sc21hcnR0djpcIlRWXCIsd2VhcmFibGU6XCJXYXRjaFwiLHhyOltcIlZSXCIsXCJYUlwiXSxcIj9cIjpbXCJEZXNrdG9wXCIsXCJVbmtub3duXCJdLFwiKlwiOmx9LFBpPXticm93c2VyOltbL1xcYig/OmNybW98Y3Jpb3MpXFwvKFtcXHdcXC5dKykvaV0sW3ksW3YseitcIkNocm9tZVwiXV0sWy9lZGcoPzplfGlvc3xhKT9cXC8oW1xcd1xcLl0rKS9pXSxbeSxbdixcIkVkZ2VcIl1dLFsvKG9wZXJhIG1pbmkpXFwvKFstXFx3XFwuXSspL2ksLyhvcGVyYSBbbW9iaWxldGFiXXszLDZ9KVxcYi4rdmVyc2lvblxcLyhbLVxcd1xcLl0rKS9pLC8ob3BlcmEpKD86Lit2ZXJzaW9uXFwvfFtcXC8gXSspKFtcXHdcXC5dKykvaV0sW3YseV0sWy9vcGlvc1tcXC8gXSsoW1xcd1xcLl0rKS9pXSxbeSxbdixkK1wiIE1pbmlcIl1dLFsvXFxib3AoPzpyZyk/eFxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LGQrXCIgR1hcIl1dLFsvXFxib3ByXFwvKFtcXHdcXC5dKykvaV0sW3ksW3YsZF1dLFsvXFxiYlthaV0qZCg/OnVoZHxbdWJdKlthZWtvcHJzd3hdezUsNn0pW1xcLyBdPyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiQmFpZHVcIl1dLFsvXFxiKD86bXhicm93c2VyfG14aW9zfG15aWUyKVxcLz8oWy1cXHdcXC5dKilcXGIvaV0sW3ksW3YsXCJNYXh0aG9uXCJdXSxbLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyfHNsZWlwbmlyKVtcXC8gXT8oW1xcd1xcLl0qKS9pLC8oYXZhbnR8aWVtb2JpbGV8c2xpbSg/OmJyb3dzZXJ8Ym9hdHxqZXQpKVtcXC8gXT8oW1xcZFxcLl0qKS9pLC8oPzptc3xcXCgpKGllKSAoW1xcd1xcLl0rKS9pLC8oZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxvdmlicm93c2VyfGJvbHR8aXJvbnx2aXZhbGRpfGlyaWRpdW18cGhhbnRvbWpzfGJvd3NlcnxxdXB6aWxsYXxmYWxrb258cmVrb25xfHB1ZmZpbnxicmF2ZXx3aGFsZSg/IS4rbmF2ZXIpfHFxYnJvd3NlcmxpdGV8ZHVja2R1Y2tnb3xrbGFyfGhlbGlvfCg/PWNvbW9kb18pP2RyYWdvbilcXC8oWy1cXHdcXC5dKykvaSwvKGhleXRhcHxvdml8MTE1KWJyb3dzZXJcXC8oW1xcZFxcLl0rKS9pLC8od2VpYm8pX18oW1xcZFxcLl0rKS9pXSxbdix5XSxbL3F1YXJrKD86cGMpP1xcLyhbLVxcd1xcLl0rKS9pXSxbeSxbdixcIlF1YXJrXCJdXSxbL1xcYmRkZ1xcLyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiRHVja0R1Y2tHb1wiXV0sWy8oPzpcXGJ1Yz8gP2Jyb3dzZXJ8KD86anVjLispdWN3ZWIpW1xcLyBdPyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiVUNCcm93c2VyXCJdXSxbL21pY3JvbS4rXFxicWJjb3JlXFwvKFtcXHdcXC5dKykvaSwvXFxicWJjb3JlXFwvKFtcXHdcXC5dKykuK21pY3JvbS9pLC9taWNyb21lc3NlbmdlclxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiV2VDaGF0XCJdXSxbL2tvbnF1ZXJvclxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiS29ucXVlcm9yXCJdXSxbL3RyaWRlbnQuK3J2WzogXShbXFx3XFwuXXsxLDl9KVxcYi4rbGlrZSBnZWNrby9pXSxbeSxbdixcIklFXCJdXSxbL3lhKD86c2VhcmNoKT9icm93c2VyXFwvKFtcXHdcXC5dKykvaV0sW3ksW3YsXCJZYW5kZXhcIl1dLFsvc2xicm93c2VyXFwvKFtcXHdcXC5dKykvaV0sW3ksW3YsXCJTbWFydCBMZW5vdm9cIit5aV1dLFsvKGF2YXN0fGF2ZylcXC8oW1xcd1xcLl0rKS9pXSxbW3YsLyguKykvLFwiJDEgU2VjdXJlXCIreWldLHldLFsvXFxiZm9jdXNcXC8oW1xcd1xcLl0rKS9pXSxbeSxbdixraStcIiBGb2N1c1wiXV0sWy9cXGJvcHRcXC8oW1xcd1xcLl0rKS9pXSxbeSxbdixkK1wiIFRvdWNoXCJdXSxbL2NvY19jb2NcXHcrXFwvKFtcXHdcXC5dKykvaV0sW3ksW3YsXCJDb2MgQ29jXCJdXSxbL2RvbGZpblxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiRG9scGhpblwiXV0sWy9jb2FzdFxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LGQrXCIgQ29hc3RcIl1dLFsvbWl1aWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pXSxbeSxbdixcIk1JVUlcIit5aV1dLFsvZnhpb3NcXC8oW1xcd1xcLi1dKykvaV0sW3ksW3YseitraV1dLFsvXFxicWlob29icm93c2VyXFwvPyhbXFx3XFwuXSopL2ldLFt5LFt2LFwiMzYwXCJdXSxbL1xcYihxcSlcXC8oW1xcd1xcLl0rKS9pXSxbW3YsLyguKykvLFwiJDFCcm93c2VyXCJdLHldLFsvKG9jdWx1c3xzYWlsZmlzaHxodWF3ZWl8dml2b3xwaWNvKWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pXSxbW3YsLyguKykvLFwiJDFcIit5aV0seV0sWy9zYW1zdW5nYnJvd3NlclxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LHBpK1wiIEludGVybmV0XCJdXSxbL21ldGFzcltcXC8gXT8oW1xcZFxcLl0rKS9pXSxbeSxbdixcIlNvZ291IEV4cGxvcmVyXCJdXSxbLyhzb2dvdSltb1xcdytcXC8oW1xcZFxcLl0rKS9pXSxbW3YsXCJTb2dvdSBNb2JpbGVcIl0seV0sWy8oZWxlY3Ryb24pXFwvKFtcXHdcXC5dKykgc2FmYXJpL2ksLyh0ZXNsYSkoPzogcXRjYXJicm93c2VyfFxcLygyMFxcZFxcZFxcLlstXFx3XFwuXSspKS9pLC9tPyhxcWJyb3dzZXJ8MjM0NSg/PWJyb3dzZXJ8Y2hyb21lfGV4cGxvcmVyKSlcXHcqW1xcLyBdP3Y/KFtcXHdcXC5dKykvaV0sW3YseV0sWy8obGJicm93c2VyfHJla29ucSkvaV0sW3ZdLFsvb21lXFwvKFtcXHdcXC5dKykgXFx3KiA/KGlyb24pIHNhZi9pLC9vbWVcXC8oW1xcd1xcLl0rKS4rcWlodSAoMzYwKVtlc11lL2ldLFt5LHZdLFsvKCg/OmZiYW5cXC9mYmlvc3xmYl9pYWJcXC9mYjRhKSg/IS4rZmJhdil8O2ZiYXZcXC8oW1xcd1xcLl0rKTspL2ldLFtbdix4aV0seSxbaywkXV0sWy8oS2xhcm5hKVxcLyhbXFx3XFwuXSspL2ksLyhrYWthbyg/OnRhbGt8c3RvcnkpKVtcXC8gXShbXFx3XFwuXSspL2ksLyhuYXZlcilcXCguKj8oXFxkK1xcLltcXHdcXC5dKykuKlxcKS9pLC8oZGF1bSlhcHBzW1xcLyBdKFtcXHdcXC5dKykvaSwvc2FmYXJpIChsaW5lKVxcLyhbXFx3XFwuXSspL2ksL1xcYihsaW5lKVxcLyhbXFx3XFwuXSspXFwvaWFiL2ksLyhhbGlwYXkpY2xpZW50XFwvKFtcXHdcXC5dKykvaSwvKHR3aXR0ZXIpKD86YW5kfCBmLitlXFwvKFtcXHdcXC5dKykpL2ksLyhpbnN0YWdyYW18c25hcGNoYXQpW1xcLyBdKFstXFx3XFwuXSspL2ldLFt2LHksW2ssJF1dLFsvXFxiZ3NhXFwvKFtcXHdcXC5dKykgLipzYWZhcmlcXC8vaV0sW3ksW3YsXCJHU0FcIl0sW2ssJF1dLFsvbXVzaWNhbF9seSg/Oi4rYXBwXz92ZXJzaW9uXFwvfF8pKFtcXHdcXC5dKykvaV0sW3ksW3YsXCJUaWtUb2tcIl0sW2ssJF1dLFsvXFxbKGxpbmtlZGluKWFwcFxcXS9pXSxbdixbaywkXV0sWy8oY2hyb21pdW0pW1xcLyBdKFstXFx3XFwuXSspL2ldLFt2LHldLFsvaGVhZGxlc3NjaHJvbWUoPzpcXC8oW1xcd1xcLl0rKXwgKS9pXSxbeSxbdixcIkNocm9tZSBIZWFkbGVzc1wiXV0sWy8gd3ZcXCkuKyhjaHJvbWUpXFwvKFtcXHdcXC5dKykvaV0sW1t2LFwiQ2hyb21lIFdlYlZpZXdcIl0seV0sWy9kcm9pZC4rIHZlcnNpb25cXC8oW1xcd1xcLl0rKVxcYi4rKD86bW9iaWxlIHNhZmFyaXxzYWZhcmkpL2ldLFt5LFt2LFwiQW5kcm9pZFwiK3lpXV0sWy9jaHJvbWVcXC8oW1xcd1xcLl0rKSBtb2JpbGUvaV0sW3ksW3YseitcIkNocm9tZVwiXV0sWy8oY2hyb21lfG9tbml3ZWJ8YXJvcmF8W3RpemVub2thXXs1fSA/YnJvd3NlcilcXC92PyhbXFx3XFwuXSspL2ldLFt2LHldLFsvdmVyc2lvblxcLyhbXFx3XFwuXFwsXSspIC4qbW9iaWxlKD86XFwvXFx3KyB8ID8pc2FmYXJpL2ldLFt5LFt2LHorXCJTYWZhcmlcIl1dLFsvaXBob25lIC4qbW9iaWxlKD86XFwvXFx3KyB8ID8pc2FmYXJpL2ldLFtbdix6K1wiU2FmYXJpXCJdXSxbL3ZlcnNpb25cXC8oW1xcd1xcLlxcLF0rKSAuKihzYWZhcmkpL2ldLFt5LHZdLFsvd2Via2l0Lis/KG1vYmlsZSA/c2FmYXJpfHNhZmFyaSkoXFwvW1xcd1xcLl0rKS9pXSxbdixbeSxcIjFcIl1dLFsvKHdlYmtpdHxraHRtbClcXC8oW1xcd1xcLl0rKS9pXSxbdix5XSxbLyg/Om1vYmlsZXx0YWJsZXQpOy4qKGZpcmVmb3gpXFwvKFtcXHdcXC4tXSspL2ldLFtbdix6K2tpXSx5XSxbLyhuYXZpZ2F0b3J8bmV0c2NhcGVcXGQ/KVxcLyhbLVxcd1xcLl0rKS9pXSxbW3YsXCJOZXRzY2FwZVwiXSx5XSxbLyh3b2x2aWN8bGlicmV3b2xmKVxcLyhbXFx3XFwuXSspL2ldLFt2LHldLFsvbW9iaWxlIHZyOyBydjooW1xcd1xcLl0rKVxcKS4rZmlyZWZveC9pXSxbeSxbdixraStcIiBSZWFsaXR5XCJdXSxbL2VraW9oZi4rKGZsb3cpXFwvKFtcXHdcXC5dKykvaSwvKHN3aWZ0Zm94KS9pLC8oaWNlZHJhZ29ufGljZXdlYXNlbHxjYW1pbm98Y2hpbWVyYXxmZW5uZWN8bWFlbW8gYnJvd3NlcnxtaW5pbW98Y29ua2Vyb3IpW1xcLyBdPyhbXFx3XFwuXFwrXSspL2ksLyhzZWFtb25rZXl8ay1tZWxlb258aWNlY2F0fGljZWFwZXxmaXJlYmlyZHxwaG9lbml4fHBhbGVtb29ufGJhc2lsaXNrfHdhdGVyZm94KVxcLyhbLVxcd1xcLl0rKSQvaSwvKGZpcmVmb3gpXFwvKFtcXHdcXC5dKykvaSwvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykgLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksLyhhbWF5YXxkaWxsb3xkb3Jpc3xpY2FifGxhZHliaXJkfGx5bnh8bW9zYWljfG5ldHN1cmZ8b2JpZ298cG9sYXJpc3x3M218KD86Z298aWNlfHVwKVtcXC4gXT9icm93c2VyKVstXFwvIF0/dj8oW1xcd1xcLl0rKS9pLC9cXGIobGlua3MpIFxcKChbXFx3XFwuXSspL2ldLFt2LFt5LC9fL2csXCIuXCJdXSxbLyhjb2JhbHQpXFwvKFtcXHdcXC5dKykvaV0sW3YsW3ksL1teXFxkXFwuXSsuLyx3XV1dLGNwdTpbWy9cXGIoKGFtZHx4fHg4NlstX10/fHdvd3x3aW4pNjQpXFxiL2ldLFtbQyxcImFtZDY0XCJdXSxbLyhpYTMyKD89OykpL2ksL1xcYigoaVszNDZdfHgpODYpKHBjKT9cXGIvaV0sW1tDLFwiaWEzMlwiXV0sWy9cXGIoYWFyY2g2NHxhcm0odj9bODldZT9sP3xfPzY0KSlcXGIvaV0sW1tDLFwiYXJtNjRcIl1dLFsvXFxiKGFybSh2WzY3XSk/aHQ/bj9bZmxdcD8pXFxiL2ldLFtbQyxcImFybWhmXCJdXSxbLyggKGNlfG1vYmlsZSk7IHBwYzt8XFwvW1xcd1xcLl0rYXJtXFxiKS9pXSxbW0MsXCJhcm1cIl1dLFsvKChwcGN8cG93ZXJwYykoNjQpPykoIG1hY3w7fFxcKSkvaV0sW1tDLC9vd2VyLyx3LGpdXSxbLyBzdW40XFx3WztcXCldL2ldLFtbQyxcInNwYXJjXCJdXSxbL1xcYihhdnIzMnxpYTY0KD89Oyl8NjhrKD89XFwpKXxcXGJhcm0oPz12KFsxLTddfFs1LTddMSlsP3w7fGVhYmkpfChpcml4fG1pcHN8c3BhcmMpKDY0KT9cXGJ8cGEtcmlzYykvaV0sW1tDLGpdXV0sZGV2aWNlOltbL1xcYihzY2gtaVs4OV0wXFxkfHNody1tMzgwc3xzbS1bcHR4XVxcd3syLDR9fGd0LVtwbl1cXGR7Miw0fXxzZ2gtdDhbNTZdOXxuZXh1cyAxMCkvaV0sW1QsW3gscGldLFtrLHJdXSxbL1xcYigoPzpzW2NncF1ofGd0fHNtKS0oPyFbbHJdKVxcdyt8c2NbZy1dP1tcXGRdK2E/fGdhbGF4eSBuZXh1cykvaSwvc2Ftc3VuZ1stIF0oKD8hc20tW2xyXSlbLVxcd10rKS9pLC9zZWMtKHNnaFxcdyspL2ldLFtULFt4LHBpXSxbayxTXV0sWy8oPzpcXC98XFwoKShpcCg/OmhvbmV8b2QpW1xcdywgXSopKD86XFwvfDspL2ldLFtULFt4LGFdLFtrLFNdXSxbL1xcKChpcGFkKTtbLVxcd1xcKSw7IF0rYXBwbGUvaSwvYXBwbGVjb3JlbWVkaWFcXC9bXFx3XFwuXSsgXFwoKGlwYWQpL2ksL1xcYihpcGFkKVxcZFxcZD8sXFxkXFxkP1s7XFxdXS4raW9zL2ldLFtULFt4LGFdLFtrLHJdXSxbLyhtYWNpbnRvc2gpOy9pXSxbVCxbeCxhXV0sWy9cXGIoc2gtP1thbHR2el0/XFxkXFxkW2EtZWttXT8pL2ldLFtULFt4LFwiU2hhcnBcIl0sW2ssU11dLFsvXFxiKCg/OmJydHxlbG58aGV5Mj98Z2RpfGpkbiktYT9bbG53XTA5fCg/OmFnW3JtXTM/fGpkbjJ8a29iMiktYT9bbHddMFswOV1obikoPzogYnVpfFxcKXw7KS9pXSxbVCxbeCxcIkhvbm9yXCJdLFtrLHJdXSxbL2hvbm9yKFstXFx3IF0rKVs7XFwpXS9pXSxbVCxbeCxcIkhvbm9yXCJdLFtrLFNdXSxbL1xcYigoPzphZ1tyc11bMjM1Nl0/az98YmFoWzIzNF0/fGJnWzJvXXxidFtrdl18Y21yfGNwbnxkYltyeV0yP3xqZG4yfGdvdHxrb2IyP2s/fG1vbnxwY2V8c2NtfHNodD98W3R3XWdyfHZyZCktW2FkXT9bbHddWzAxMjVdWzA5XWI/fDYwNWh3fGJnMi11MDN8KD86Z2VtfGZkcnxtMnxwbGV8dDEpLVs3YV0wWzEtNF1bbHVdfHQxLWEyWzEzXVtsd118bWVkaWFwYWRbXFx3XFwuIF0qKD89IGJ1aXxcXCkpKVxcYig/IS4rZFxcL3MpL2ldLFtULFt4LGJpXSxbayxyXV0sWy8oPzpodWF3ZWkpKFstXFx3IF0rKVs7XFwpXS9pLC9cXGIobmV4dXMgNnB8XFx3ezIsNH1lPy1bYXR1XT9bbG5dW1xcZHhdWzAxMjM1OWNdW2Fkbl0/KVxcYig/IS4rZFxcL3MpL2ldLFtULFt4LGJpXSxbayxTXV0sWy9vaWRbXlxcKV0rOyAoMltcXGRiY117NH0oMTgyfDI4M3xycFxcd3syfSlbY2dsXXxtMjEwNWs4MWE/YykoPzogYnVpfFxcKSkvaSwvXFxiKCg/OnJlZCk/bWlbLV8gXT9wYWRbXFx3LSBdKikoPzogYnVpfFxcKSkvaV0sW1tULC9fL2csXCIgXCJdLFt4LGZpXSxbayxyXV0sWy9cXGIocG9jb1tcXHcgXSt8bTJcXGR7M31qXFxkXFxkW2Etel17Mn0pKD86IGJ1aXxcXCkpL2ksL1xcYjsgKFxcdyspIGJ1aWxkXFwvaG1cXDEvaSwvXFxiKGhtWy1fIF0/bm90ZT9bXyBdPyg/OlxcZFxcdyk/KSBidWkvaSwvXFxiKHJlZG1pW1xcLV8gXT8oPzpub3RlfGspP1tcXHdfIF0rKSg/OiBidWl8XFwpKS9pLC9vaWRbXlxcKV0rOyAobT9bMTJdWzAtMzg5XVswMV1cXHd7Myw2fVtjLXldKSggYnVpfDsgd3Z8XFwpKS9pLC9cXGIobWlbLV8gXT8oPzphXFxkfG9uZXxvbmVbXyBdcGx1c3xub3RlIGx0ZXxtYXh8Y2MpP1tfIF0/KD86XFxkP1xcdz8pW18gXT8oPzpwbHVzfHNlfGxpdGV8cHJvKT8pKD86IGJ1aXxcXCkpL2ksLyAoW1xcdyBdKykgbWl1aVxcL3Y/XFxkL2ldLFtbVCwvXy9nLFwiIFwiXSxbeCxmaV0sW2ssU11dLFsvOyAoXFx3KykgYnVpLisgb3Bwby9pLC9cXGIoY3BoWzEyXVxcZHszfXxwKD86YWZ8Y1thbF18ZFxcd3xlW2FyXSlbbXRdXFxkMHx4OTAwN3xhMTAxb3ApXFxiL2ldLFtULFt4LGhpXSxbayxTXV0sWy9cXGIob3BkMihcXGR7M31hPykpKD86IGJ1aXxcXCkpL2ldLFtULFt4LEUse09uZVBsdXM6W1wiMzA0XCIsXCI0MDNcIixcIjIwM1wiXSxcIipcIjpoaX1dLFtrLHJdXSxbL3Zpdm8gKFxcdyspKD86IGJ1aXxcXCkpL2ksL1xcYih2WzEyXVxcZHszfVxcdz9bYXRdKSg/OiBidWl8OykvaV0sW1QsW3gsXCJWaXZvXCJdLFtrLFNdXSxbL1xcYihybXhbMS0zXVxcZHszfSkoPzogYnVpfDt8XFwpKS9pXSxbVCxbeCxcIlJlYWxtZVwiXSxbayxTXV0sWy9cXGIobWlsZXN0b25lfGRyb2lkKD86WzItNHhdfCAoPzpiaW9uaWN8eDJ8cHJvfHJhenIpKT86PyggNGcpPylcXGJbXFx3IF0rYnVpbGRcXC8vaSwvXFxibW90KD86b3JvbGEpP1stIF0oXFx3KikvaSwvKCg/Om1vdG8oPyEgMzYwKVtcXHdcXChcXCkgXSt8eHRcXGR7Myw0fXxuZXh1cyA2KSg/PSBidWl8XFwpKSkvaV0sW1QsW3gsbGldLFtrLFNdXSxbL1xcYihtejYwXFxkfHhvb21bMiBdezAsMn0pIGJ1aWxkXFwvL2ldLFtULFt4LGxpXSxbayxyXV0sWy8oKD89bGcpP1t2bF1rXFwtP1xcZHszfSkgYnVpfCAzXFwuWy1cXHc7IF17MTB9bGc/LShbMDZjdjldezMsNH0pL2ldLFtULFt4LFwiTEdcIl0sW2sscl1dLFsvKGxtKD86LT9mMTAwW252XT98LVtcXHdcXC5dKykoPz0gYnVpfFxcKSl8bmV4dXMgWzQ1XSkvaSwvXFxibGdbLWU7XFwvIF0rKCg/IWJyb3dzZXJ8bmV0Y2FzdHxhbmRyb2lkIHR2fHdhdGNoKVxcdyspL2ksL1xcYmxnLT8oW1xcZFxcd10rKSBidWkvaV0sW1QsW3gsXCJMR1wiXSxbayxTXV0sWy8oaWRlYXRhYlstXFx3IF0rfDYwMmx2fGQtNDJhfGExMDFsdnxhMjEwOWF8YTM1MDAtaHZ8c1s1Nl0wMDB8cGItNjUwNVtteV18dGItP3g/XFxkezMsNH0oPzpmW2N1XXx4dXxbYXZdKXx5dFxcZD8tW2p4XT9cXGQrW2xmbXhdKSggYnVpfDt8XFwpfFxcLykvaSwvbGVub3ZvID8oYls2OF0wWzA4XTAtP1toZl0/fHRhYig/OltcXHctIF0rPyl8dGJbXFx3LV17Niw3fSkoIGJ1aXw7fFxcKXxcXC8pL2ldLFtULFt4LFwiTGVub3ZvXCJdLFtrLHJdXSxbLyhub2tpYSkgKHRbMTJdWzAxXSkvaV0sW3gsVCxbayxyXV0sWy8oPzptYWVtb3xub2tpYSkuKihuOTAwfGx1bWlhIFxcZCt8cm0tXFxkKykvaSwvbm9raWFbLV8gXT8oKFstXFx3XFwuIF0qKSkvaV0sW1tULC9fL2csXCIgXCJdLFtrLFNdLFt4LFwiTm9raWFcIl1dLFsvKHBpeGVsIChjfHRhYmxldCkpXFxiL2ldLFtULFt4LHNdLFtrLHJdXSxbL2Ryb2lkLis7IChwaXhlbFtcXGRheGwgXXswLDZ9KSg/OiBidWl8XFwpKS9pXSxbVCxbeCxzXSxbayxTXV0sWy9kcm9pZC4rOyAoYT9cXGRbMC0yXXsyfXNvfFtjLWddXFxkezR9fHNvWy1nbF1cXHcrfHhxLWFcXHdbNC03XVsxMl0pKD89IGJ1aXxcXCkuK2Nocm9tZVxcLyg/IVsxLTZdezAsMX1cXGRcXC4pKS9pXSxbVCxbeCxtaV0sW2ssU11dLFsvc29ueSB0YWJsZXQgW3BzXS9pLC9cXGIoPzpzb255KT9zZ3BcXHcrKD86IGJ1aXxcXCkpL2ldLFtbVCxcIlhwZXJpYSBUYWJsZXRcIl0sW3gsbWldLFtrLHJdXSxbLyAoa2IyMDA1fGluMjBbMTJdNXxiZTIwWzEyXVs1OV0pXFxiL2ksLyg/Om9uZSk/KD86cGx1cyk/IChhXFxkMFxcZFxcZCkoPzogYnxcXCkpL2ldLFtULFt4LHVpXSxbayxTXV0sWy8oYWxleGEpd2VibS9pLC8oa2ZbYS16XXsyfXdpfGFlbyg/IWJjKVxcd1xcdykoIGJ1aXxcXCkpL2ksLyhrZlthLXpdKykoIGJ1aXxcXCkpLitzaWxrXFwvL2ldLFtULFt4LHNpXSxbayxyXV0sWy8oKD86c2R8a2YpWzAzNDloaWpvcnN0dXddKykoIGJ1aXxcXCkpLitzaWxrXFwvL2ldLFtbVCwvKC4rKS9nLFwiRmlyZSBQaG9uZSAkMVwiXSxbeCxzaV0sW2ssU11dLFsvKHBsYXlib29rKTtbLVxcd1xcKSw7IF0rKHJpbSkvaV0sW1QseCxbayxyXV0sWy9cXGIoKD86YmJbYS1mXXxzdFtodl0pMTAwLVxcZCkvaSwvXFwoYmIxMDsgKFxcdyspL2ldLFtULFt4LHdpXSxbayxTXV0sWy8oPzpcXGJ8YXN1c18pKHRyYW5zZm9bcHJpbWUgXXs0LDEwfSBcXHcrfGVlZXBjfHNsaWRlciBcXHcrfG5leHVzIDd8cGFkZm9uZXxwMDBbY2pdKS9pXSxbVCxbeCxuaV0sW2sscl1dLFsvICh6W2Jlc102WzAyN11bMDEyXVtrbV1bbHNdfHplbmZvbmUgXFxkXFx3PylcXGIvaV0sW1QsW3gsbmldLFtrLFNdXSxbLyhuZXh1cyA5KS9pXSxbVCxbeCxcIkhUQ1wiXSxbayxyXV0sWy8oaHRjKVstO18gXXsxLDJ9KFtcXHcgXSsoPz1cXCl8IGJ1aSl8XFx3KykvaSwvKHp0ZSlbLSBdKFtcXHcgXSs/KSg/OiBidWl8XFwvfFxcKSkvaSwvKGFsY2F0ZWx8Z2Vla3NwaG9uZXxuZXhpYW58cGFuYXNvbmljKD8hKD86O3xcXC4pKXxzb255KD8hLWJyYSkpWy1fIF0/KFstXFx3XSopL2ldLFt4LFtULC9fL2csXCIgXCJdLFtrLFNdXSxbL3RjbCAoeGVzcyBwMTdhYSkvaSwvZHJvaWQgW1xcd1xcLl0rOyAoKD86OFsxNF05WzE2XXw5KD86MCg/OjQ4fDYwfDhbMDFdKXwxKD86M1syN118NjYpfDIoPzo2WzY5XXw5WzU2XSl8NDY2KSlbZ3Fzd3hdKShfXFx3KFxcd3xcXHdcXHcpKT8oXFwpfCBidWkpL2ldLFtULFt4LFwiVENMXCJdLFtrLHJdXSxbL2Ryb2lkIFtcXHdcXC5dKzsgKDQxOCg/OjdkfDh2KXw1MDg3enw1MTAybHw2MSg/OjAyW2RoXXwyNVthZGZoXXwyN1thaV18NTZbZGhdfDU5a3w2NVthaF0pfGE1MDlkbHx0KD86NDMoPzowd3wxW2FkZXBxdV0pfDUwKD86NmR8N1thZGp1XSl8Nig/OjA5ZGx8MTBrfDEyYnw3MVtlZmhvXXw3NltoamtdKXw3KD86NjZbYWhqdV18NjdbaHddfDdbMDQ1XVtiaF18NzFbaGtdfDczb3w3Nltob118Nzl3fDgxW2hrc10/fDgyaHw5MFtiaHN5XXw5OWIpfDgxMFtoc10pKShfXFx3KFxcd3xcXHdcXHcpKT8oXFwpfCBidWkpL2ldLFtULFt4LFwiVENMXCJdLFtrLFNdXSxbLyhpdGVsKSAoKFxcdyspKS9pXSxbW3gsal0sVCxbayxFLHt0YWJsZXQ6W1wicDEwMDAxbFwiLFwidzcwMDFcIl0sXCIqXCI6XCJtb2JpbGVcIn1dXSxbL2Ryb2lkLis7IChbYWJdWzEtN10tP1swMTc4YV1cXGRcXGQ/KS9pXSxbVCxbeCxcIkFjZXJcIl0sW2sscl1dLFsvZHJvaWQuKzsgKG1bMS01XSBub3RlKSBidWkvaSwvXFxibXotKFstXFx3XXsyLH0pL2ldLFtULFt4LFwiTWVpenVcIl0sW2ssU11dLFsvOyAoKD86cG93ZXIgKT9hcm1vcig/OltcXHcgXXswLDh9KSkoPzogYnVpfFxcKSkvaV0sW1QsW3gsXCJVbGVmb25lXCJdLFtrLFNdXSxbLzsgKGVuZXJneSA/XFx3KykoPzogYnVpfFxcKSkvaSwvOyBlbmVyZ2l6ZXIgKFtcXHcgXSspKD86IGJ1aXxcXCkpL2ldLFtULFt4LFwiRW5lcmdpemVyXCJdLFtrLFNdXSxbLzsgY2F0IChiMzUpOy9pLC87IChiMTVxP3xzMjIgZmxpcHxzNDhjfHM2MiBwcm8pKD86IGJ1aXxcXCkpL2ldLFtULFt4LFwiQ2F0XCJdLFtrLFNdXSxbLygoPzpuZXcgKT9hbmRyb21heFtcXHctIF0rKSg/OiBidWl8XFwpKS9pXSxbVCxbeCxcIlNtYXJ0ZnJlblwiXSxbayxTXV0sWy9kcm9pZC4rOyAoYSg/OjAxNXwwNlszNV18MTQycD8pKS9pXSxbVCxbeCxcIk5vdGhpbmdcIl0sW2ssU11dLFsvKGltbykgKHRhYiBcXHcrKS9pLC8oaW5maW5peCkgKHgxMTAxYj8pL2ldLFt4LFQsW2sscl1dLFsvKGJsYWNrYmVycnl8YmVucXxwYWxtKD89XFwtKXxzb255ZXJpY3Nzb258YWNlcnxhc3VzKD8hIHplbncpfGRlbGx8am9sbGF8bWVpenV8bW90b3JvbGF8cG9seXRyb258aW5maW5peHx0ZWNub3xtaWNyb21heHxhZHZhbilbLV8gXT8oWy1cXHddKikvaSwvOyAoaG1kfGltbykgKFtcXHcgXSs/KSg/OiBidWl8XFwpKS9pLC8oaHApIChbXFx3IF0rXFx3KS9pLC8obWljcm9zb2Z0KTsgKGx1bWlhW1xcdyBdKykvaSwvKGxlbm92bylbLV8gXT8oWy1cXHcgXSs/KSg/OiBidWl8XFwpfFxcLykvaSwvKG9wcG8pID8oW1xcdyBdKykgYnVpL2ldLFt4LFQsW2ssU11dLFsvKGtvYm8pXFxzKGVyZWFkZXJ8dG91Y2gpL2ksLyhhcmNob3MpIChnYW1lcGFkMj8pL2ksLyhocCkuKyh0b3VjaHBhZCg/IS4rdGFibGV0KXx0YWJsZXQpL2ksLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaV0sW3gsVCxbayxyXV0sWy8oc3VyZmFjZSBkdW8pL2ldLFtULFt4LGRpXSxbayxyXV0sWy9kcm9pZCBbXFxkXFwuXSs7IChmcFxcZHU/KSg/OiBifFxcKSkvaV0sW1QsW3gsXCJGYWlycGhvbmVcIl0sW2ssU11dLFsvKCg/OnRlZ3Jhbm90ZXxzaGllbGQgdCg/IS4rZCB0dikpW1xcdy0gXSo/KSg/OiBifFxcKSkvaV0sW1QsW3gsY2ldLFtrLHJdXSxbLyhzcHJpbnQpIChcXHcrKS9pXSxbeCxULFtrLFNdXSxbLyhraW5cXC5bb25ldHddezN9KS9pXSxbW1QsL1xcLi9nLFwiIFwiXSxbeCxkaV0sW2ssU11dLFsvZHJvaWQuKzsgKFtjNl0rfGV0NVsxNl18bWNbMjM5XVsyM114P3x2YzhbMDNdeD8pXFwpL2ldLFtULFt4LGdpXSxbayxyXV0sWy9kcm9pZC4rOyAoZWMzMHxwczIwfHRjWzItOF1cXGRba3hdKVxcKS9pXSxbVCxbeCxnaV0sW2ssU11dLFsvc21hcnQtdHYuKyhzYW1zdW5nKS9pXSxbeCxbayxlXV0sWy9oYmJ0di4rbWFwbGU7KFxcZCspL2ldLFtbVCwvXi8sXCJTbWFydFRWXCJdLFt4LHBpXSxbayxlXV0sWy8obnV4OyBuZXRjYXN0LitzbWFydHR2fGxnIChuZXRjYXN0XFwudHYtMjAxXFxkfGFuZHJvaWQgdHYpKS9pXSxbW3gsXCJMR1wiXSxbayxlXV0sWy8oYXBwbGUpID90di9pXSxbeCxbVCxhK1wiIFRWXCJdLFtrLGVdXSxbL2Nya2V5LipkZXZpY2V0eXBlXFwvY2hyb21lY2FzdC9pXSxbW1QsYitcIiBUaGlyZCBHZW5lcmF0aW9uXCJdLFt4LHNdLFtrLGVdXSxbL2Nya2V5LipkZXZpY2V0eXBlXFwvKFteL10qKS9pXSxbW1QsL14vLFwiQ2hyb21lY2FzdCBcIl0sW3gsc10sW2ssZV1dLFsvZnVjaHNpYS4qY3JrZXkvaV0sW1tULGIrXCIgTmVzdCBIdWJcIl0sW3gsc10sW2ssZV1dLFsvY3JrZXkvaV0sW1tULGJdLFt4LHNdLFtrLGVdXSxbL2Ryb2lkLithZnQoXFx3KykoIGJ1aXxcXCkpL2ldLFtULFt4LHNpXSxbayxlXV0sWy8oc2hpZWxkIFxcdysgdHYpL2ldLFtULFt4LGNpXSxbayxlXV0sWy9cXChkdHZbXFwpO10uKyhhcXVvcykvaSwvKGFxdW9zLXR2W1xcdyBdKylcXCkvaV0sW1QsW3gsXCJTaGFycFwiXSxbayxlXV0sWy8oYnJhdmlhW1xcdyBdKykoIGJ1aXxcXCkpL2ldLFtULFt4LG1pXSxbayxlXV0sWy8obWkodHZ8Ym94KS0/XFx3KykgYnVpL2ldLFtULFt4LGZpXSxbayxlXV0sWy9IYmJ0di4qKHRlY2huaXNhdCkgKC4qKTsvaV0sW3gsVCxbayxlXV0sWy9cXGIocm9rdSlbXFxkeF0qW1xcKVxcL10oKD86ZHZwLSk/W1xcZFxcLl0qKS9pLC9oYmJ0dlxcL1xcZCtcXC5cXGQrXFwuXFxkKyArXFwoW1xcd1xcKyBdKjsgKihbXFx3XFxkXVteO10qKTsoW147XSopL2ldLFtbeCxIaV0sW1QsSGldLFtrLGVdXSxbL2Ryb2lkLis7IChbXFx3LSBdKykgKD86YW5kcm9pZCB0dnxzbWFydFstIF0/dHYpL2ldLFtULFtrLGVdXSxbL1xcYihhbmRyb2lkIHR2fHNtYXJ0Wy0gXT90dnxvcGVyYSB0dnx0djsgcnY6KVxcYi9pXSxbW2ssZV1dLFsvKG91eWEpL2ksLyhuaW50ZW5kbykgKFxcdyspL2ldLFt4LFQsW2ssR11dLFsvZHJvaWQuKzsgKHNoaWVsZCkoIGJ1aXxcXCkpL2ldLFtULFt4LGNpXSxbayxHXV0sWy8ocGxheXN0YXRpb24gXFx3KykvaV0sW1QsW3gsbWldLFtrLEddXSxbL1xcYih4Ym94KD86IG9uZSk/KD8hOyB4Ym94KSlbXFwpOyBdL2ldLFtULFt4LGRpXSxbayxHXV0sWy9cXGIoc20tW2xyXVxcZFxcZFswMTU2XVtmbnV3XT9zP3xnZWFyIGxpdmUpXFxiL2ldLFtULFt4LHBpXSxbayx0XV0sWy8oKHBlYmJsZSkpYXBwL2ksLyhhc3VzfGdvb2dsZXxsZ3xvcHBvKSAoKHBpeGVsIHx6ZW4pP3dhdGNoW1xcdyBdKikoIGJ1aXxcXCkpL2ldLFt4LFQsW2ssdF1dLFsvKG93KD86MTl8MjApP3dlP1sxLTNdezEsM30pL2ldLFtULFt4LGhpXSxbayx0XV0sWy8od2F0Y2gpKD86ID9vc1ssXFwvXXxcXGQsXFxkXFwvKVtcXGRcXC5dKy9pXSxbVCxbeCxhXSxbayx0XV0sWy8ob3B3d2VcXGR7M30pL2ldLFtULFt4LHVpXSxbayx0XV0sWy8obW90byAzNjApL2ldLFtULFt4LGxpXSxbayx0XV0sWy8oc21hcnR3YXRjaCAzKS9pXSxbVCxbeCxtaV0sW2ssdF1dLFsvKGcgd2F0Y2ggcikvaV0sW1QsW3gsXCJMR1wiXSxbayx0XV0sWy9kcm9pZC4rOyAod3Q2Mz8wezIsM30pXFwpL2ldLFtULFt4LGdpXSxbayx0XV0sWy9kcm9pZC4rOyAoZ2xhc3MpIFxcZC9pXSxbVCxbeCxzXSxbayxGXV0sWy8ocGljbykgKDR8bmVvMyg/OiBsaW5rfHBybyk/KS9pXSxbeCxULFtrLEZdXSxbLzsgKHF1ZXN0KCBcXGR8IHBybyk/KS9pXSxbVCxbeCx4aV0sW2ssRl1dLFsvKHRlc2xhKSg/OiBxdGNhcmJyb3dzZXJ8XFwvWy1cXHdcXC5dKykvaV0sW3gsW2ssRF1dLFsvKGFlb2JjKVxcYi9pXSxbVCxbeCxzaV0sW2ssRF1dLFsvKGhvbWVwb2QpLittYWMgb3MvaV0sW1QsW3gsYV0sW2ssRF1dLFsvd2luZG93cyBpb3QvaV0sW1trLERdXSxbL2Ryb2lkIC4rPzsgKFteO10rPykoPzogYnVpfDsgd3ZcXCl8XFwpIGFwcGxldykuKz8obW9iaWxlfHZyfFxcZCkgc2FmYXJpL2ldLFtULFtrLEUse21vYmlsZTpcIk1vYmlsZVwiLHhyOlwiVlJcIixcIipcIjpyfV1dLFsvXFxiKCh0YWJsZXR8dGFiKVs7XFwvXXxmb2N1c1xcL1xcZCg/IS4rbW9iaWxlKSkvaV0sW1trLHJdXSxbLyhwaG9uZXxtb2JpbGUoPzpbO1xcL118IFsgXFx3XFwvXFwuXSpzYWZhcmkpfHBkYSg/PS4rd2luZG93cyBjZSkpL2ldLFtbayxTXV0sWy9kcm9pZCAuKz87IChbXFx3XFwuIC1dKykoIGJ1aXxcXCkpL2ldLFtULFt4LFwiR2VuZXJpY1wiXV1dLGVuZ2luZTpbWy93aW5kb3dzLisgZWRnZVxcLyhbXFx3XFwuXSspL2ldLFt5LFt2LFwiRWRnZUhUTUxcIl1dLFsvKGFya3dlYilcXC8oW1xcd1xcLl0rKS9pXSxbdix5XSxbL3dlYmtpdFxcLzUzN1xcLjM2LitjaHJvbWVcXC8oPyEyNykoW1xcd1xcLl0rKS9pXSxbeSxbdixcIkJsaW5rXCJdXSxbLyhwcmVzdG8pXFwvKFtcXHdcXC5dKykvaSwvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M218Z29hbm5hfHNlcnZvKVxcLyhbXFx3XFwuXSspL2ksL2VraW9oKGZsb3cpXFwvKFtcXHdcXC5dKykvaSwvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvIF1cXCg/KFtcXHdcXC5dKykvaSwvKGljYWIpW1xcLyBdKFsyM11cXC5bXFxkXFwuXSspL2ksL1xcYihsaWJ3ZWIpL2ldLFt2LHldLFsvbGFkeWJpcmRcXC8vaV0sW1t2LFwiTGliV2ViXCJdXSxbL3J2XFw6KFtcXHdcXC5dezEsOX0pXFxiLisoZ2Vja28pL2ldLFt5LHZdXSxvczpbWy9taWNyb3NvZnQgKHdpbmRvd3MpICh2aXN0YXx4cCkvaV0sW3YseV0sWy8od2luZG93cyAoPzpwaG9uZSg/OiBvcyk/fG1vYmlsZXxpb3QpKVtcXC8gXT8oW1xcZFxcLlxcdyBdKikvaV0sW3YsW3ksRSxOaV1dLFsvd2luZG93cyBudCA2XFwuMjsgKGFybSkvaSwvd2luZG93c1tcXC8gXShbbnRjZVxcZFxcLiBdK1xcdykoPyEuK3hib3gpL2ksLyg/Ondpbig/PTN8OXxuKXx3aW4gOXggKShbbnRcXGRcXC5dKykvaV0sW1t5LEUsTmldLFt2LENpXV0sWy9bYWRlaGltbm9wXXs0LDd9XFxiKD86LipvcyAoW1xcd10rKSBsaWtlIG1hY3w7IG9wZXJhKS9pLC8oPzppb3M7ZmJzdlxcL3xpcGhvbmUuK2lvc1tcXC8gXSkoW1xcZFxcLl0rKS9pLC9jZm5ldHdvcmtcXC8uK2Rhcndpbi9pXSxbW3ksL18vZyxcIi5cIl0sW3YsXCJpT1NcIl1dLFsvKG1hYyBvcyB4KSA/KFtcXHdcXC4gXSopL2ksLyhtYWNpbnRvc2h8bWFjX3Bvd2VycGNcXGIpKD8hLitoYWlrdSkvaV0sW1t2LFwibWFjT1NcIl0sW3ksL18vZyxcIi5cIl1dLFsvYW5kcm9pZCAoW1xcZFxcLl0rKS4qY3JrZXkvaV0sW3ksW3YsYitcIiBBbmRyb2lkXCJdXSxbL2Z1Y2hzaWEuKmNya2V5XFwvKFtcXGRcXC5dKykvaV0sW3ksW3YsYitcIiBGdWNoc2lhXCJdXSxbL2Nya2V5XFwvKFtcXGRcXC5dKykuKmRldmljZXR5cGVcXC9zbWFydHNwZWFrZXIvaV0sW3ksW3YsYitcIiBTbWFydFNwZWFrZXJcIl1dLFsvbGludXguKmNya2V5XFwvKFtcXGRcXC5dKykvaV0sW3ksW3YsYitcIiBMaW51eFwiXV0sWy9jcmtleVxcLyhbXFxkXFwuXSspL2ldLFt5LFt2LGJdXSxbL2Ryb2lkIChbXFx3XFwuXSspXFxiLisoYW5kcm9pZFstIF14ODZ8aGFybW9ueW9zKS9pXSxbeSx2XSxbLyh1YnVudHUpIChbXFx3XFwuXSspIGxpa2UgYW5kcm9pZC9pXSxbW3YsLyguKykvLFwiJDEgVG91Y2hcIl0seV0sWy8oYW5kcm9pZHxiYWRhfGJsYWNrYmVycnl8a2Fpb3N8bWFlbW98bWVlZ298b3Blbmhhcm1vbnl8cW54fHJpbSB0YWJsZXQgb3N8c2FpbGZpc2h8c2VyaWVzNDB8c3ltYmlhbnx0aXplbnx3ZWJvcylcXHcqWy1cXC87IF0/KFtcXGRcXC5dKikvaV0sW3YseV0sWy9cXChiYigxMCk7L2ldLFt5LFt2LHdpXV0sWy8oPzpzeW1iaWFuID9vc3xzeW1ib3N8czYwKD89Oyl8c2VyaWVzID82MClbLVxcLyBdPyhbXFx3XFwuXSopL2ldLFt5LFt2LFwiU3ltYmlhblwiXV0sWy9tb3ppbGxhXFwvW1xcZFxcLl0rIFxcKCg/Om1vYmlsZXx0YWJsZXR8dHZ8bW9iaWxlOyBbXFx3IF0rKTsgcnY6LisgZ2Vja29cXC8oW1xcd1xcLl0rKS9pXSxbeSxbdixraStcIiBPU1wiXV0sWy93ZWIwczsuK3J0KHR2KS9pLC9cXGIoPzpocCk/d29zKD86YnJvd3Nlcik/XFwvKFtcXHdcXC5dKykvaV0sW3ksW3YsXCJ3ZWJPU1wiXV0sWy93YXRjaCg/OiA/b3NbLFxcL118XFxkLFxcZFxcLykoW1xcZFxcLl0rKS9pXSxbeSxbdixcIndhdGNoT1NcIl1dLFsvKGNyb3MpIFtcXHddKyg/OlxcKXwgKFtcXHdcXC5dKylcXGIpL2ldLFtbdixcIkNocm9tZSBPU1wiXSx5XSxbL3BhbmFzb25pYzsodmllcmEpL2ksLyhuZXRyYW5nZSltbWgvaSwvKG5ldHR2KVxcLyhcXGQrXFwuW1xcd1xcLl0rKS9pLC8obmludGVuZG98cGxheXN0YXRpb24pIChcXHcrKS9pLC8oeGJveCk7ICt4Ym94IChbXlxcKTtdKykvaSwvKHBpY28pIC4rb3MoW1xcd1xcLl0rKS9pLC9cXGIoam9saXxwYWxtKVxcYiA/KD86b3MpP1xcLz8oW1xcd1xcLl0qKS9pLC8obWludClbXFwvXFwoXFwpIF0/KFxcdyopL2ksLyhtYWdlaWF8dmVjdG9ybGludXgpWzsgXS9pLC8oW2t4bG5dP3VidW50dXxkZWJpYW58c3VzZXxvcGVuc3VzZXxnZW50b298YXJjaCg/PSBsaW51eCl8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZCA/aGF0fHplbndhbGt8bGlucHVzfHJhc3BiaWFufHBsYW4gOXxtaW5peHxyaXNjIG9zfGNvbnRpa2l8ZGVlcGlufG1hbmphcm98ZWxlbWVudGFyeSBvc3xzYWJheW9ufGxpbnNwaXJlKSg/OiBnbnVcXC9saW51eCk/KD86IGVudGVycHJpc2UpPyg/OlstIF1saW51eCk/KD86LWdudSk/Wy1cXC8gXT8oPyFjaHJvbXxwYWNrYWdlKShbLVxcd1xcLl0qKS9pLC8oaHVyZHxsaW51eCkoPzogYXJtXFx3KnwgeDg2XFx3KnwgPykoW1xcd1xcLl0qKS9pLC8oZ251KSA/KFtcXHdcXC5dKikvaSwvXFxiKFstZnJlbnRvcGNnaHNdezAsNX1ic2R8ZHJhZ29uZmx5KVtcXC8gXT8oPyFhbWR8W2l4MzQ2XXsxLDJ9ODYpKFtcXHdcXC5dKikvaSwvKGhhaWt1KSAoXFx3KykvaV0sW3YseV0sWy8oc3Vub3MpID8oW1xcd1xcLlxcZF0qKS9pXSxbW3YsXCJTb2xhcmlzXCJdLHldLFsvKCg/Om9wZW4pP3NvbGFyaXMpWy1cXC8gXT8oW1xcd1xcLl0qKS9pLC8oYWl4KSAoKFxcZCkoPz1cXC58XFwpfCApW1xcd1xcLl0pKi9pLC9cXGIoYmVvc3xvc1xcLzJ8YW1pZ2Fvc3xtb3JwaG9zfG9wZW52bXN8ZnVjaHNpYXxocC11eHxzZXJlbml0eW9zKS9pLC8odW5peCkgPyhbXFx3XFwuXSopL2ldLFt2LHldXX0sSWk9KGQ9e2luaXQ6e30saXNJZ25vcmU6e30saXNJZ25vcmVSZ3g6e30sdG9TdHJpbmc6e319LE4uY2FsbChkLmluaXQsW1t1LFt2LHksQixrXV0sW2gsW0NdXSxbcCxbayxULHhdXSxbbSxbdix5XV0sW2YsW3YseV1dXSksTi5jYWxsKGQuaXNJZ25vcmUsW1t1LFt5LEJdXSxbbSxbeV1dLFtmLFt5XV1dKSxOLmNhbGwoZC5pc0lnbm9yZVJneCxbW3UsLyA/YnJvd3NlciQvaV0sW2YsLyA/b3MkL2ldXSksTi5jYWxsKGQudG9TdHJpbmcsW1t1LFt2LHldXSxbaCxbQ11dLFtwLFt4LFRdXSxbbSxbdix5XV0sW2YsW3YseV1dXSksZCksTWk9ZnVuY3Rpb24oZSxpKXt2YXIgdD1JaS5pbml0W2ldLG89SWkuaXNJZ25vcmVbaV18fDAscj1JaS5pc0lnbm9yZVJneFtpXXx8MCxhPUlpLnRvU3RyaW5nW2ldfHwwO2Z1bmN0aW9uIHMoKXtOLmNhbGwodGhpcyx0KX1yZXR1cm4gcy5wcm90b3R5cGUuZ2V0SXRlbT1mdW5jdGlvbigpe3JldHVybiBlfSxzLnByb3RvdHlwZS53aXRoQ2xpZW50SGludHM9ZnVuY3Rpb24oKXtyZXR1cm4gTz9PLmdldEhpZ2hFbnRyb3B5VmFsdWVzKGFpKS50aGVuKGZ1bmN0aW9uKGkpe3JldHVybiBlLnNldENIKG5ldyBVaShpLCExKSkucGFyc2VDSCgpLmdldCgpfSk6ZS5wYXJzZUNIKCkuZ2V0KCl9LHMucHJvdG90eXBlLndpdGhGZWF0dXJlQ2hlY2s9ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZXRlY3RGZWF0dXJlKCkuZ2V0KCl9LGkhPWcmJihzLnByb3RvdHlwZS5pcz1mdW5jdGlvbihpKXt2YXIgZSx0PSExO2ZvcihlIGluIHRoaXMpaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShlKSYmIVNpKG8sZSkmJmoocj9BaShyLHRoaXNbZV0pOnRoaXNbZV0pPT1qKHI/QWkocixpKTppKSl7aWYodD0hMCxpIT1uKWJyZWFrfWVsc2UgaWYoaT09biYmdCl7dD0hdDticmVha31yZXR1cm4gdH0scy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgaSxlPXc7Zm9yKGkgaW4gYSl0eXBlb2YgdGhpc1thW2ldXSE9PW4mJihlKz0oZT9cIiBcIjp3KSt0aGlzW2FbaV1dKTtyZXR1cm4gZXx8bn0pLE98fChzLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGkpe2Z1bmN0aW9uIGUoKXtmb3IodmFyIGkgaW4gdCl0Lmhhc093blByb3BlcnR5KGkpJiYodGhpc1tpXT10W2ldKX12YXIgdD10aGlzLG89KGUucHJvdG90eXBlPXtpczpzLnByb3RvdHlwZS5pcyx0b1N0cmluZzpzLnByb3RvdHlwZS50b1N0cmluZ30sbmV3IGUpO3JldHVybiBpKG8pLG99KSxuZXcgc307ZnVuY3Rpb24gVWkoaSxlKXtpZihpPWl8fHt9LE4uY2FsbCh0aGlzLGFpKSxlKU4uY2FsbCh0aGlzLFtbVyxxaShpW29dKV0sW1gscWkoaVtaXSldLFtTLC9cXD8xLy50ZXN0KGlbZWldKV0sW1QsT2koaVt0aV0pXSxbcSxPaShpW29pXSldLFtLLE9pKGlbcmldKV0sW0MsT2koaVtZXSldLFtfLHFpKGlbaWldKV0sW1EsT2koaVtKXSldXSk7ZWxzZSBmb3IodmFyIHQgaW4gaSl0aGlzLmhhc093blByb3BlcnR5KHQpJiZ0eXBlb2YgaVt0XSE9PW4mJih0aGlzW3RdPWlbdF0pfWZ1bmN0aW9uIFJpKGksZSx0LG8pe3JldHVybiB0aGlzLmdldD1mdW5jdGlvbihpKXtyZXR1cm4gaT90aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoaSk/dGhpcy5kYXRhW2ldOmw6dGhpcy5kYXRhfSx0aGlzLnNldD1mdW5jdGlvbihpLGUpe3JldHVybiB0aGlzLmRhdGFbaV09ZSx0aGlzfSx0aGlzLnNldENIPWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLnVhQ0g9aSx0aGlzfSx0aGlzLmRldGVjdEZlYXR1cmU9ZnVuY3Rpb24oKXtpZihBJiZBLnVzZXJBZ2VudD09dGhpcy51YSlzd2l0Y2godGhpcy5pdGVtVHlwZSl7Y2FzZSB1OkEuYnJhdmUmJnR5cGVvZiBBLmJyYXZlLmlzQnJhdmU9PVYmJnRoaXMuc2V0KHYsXCJCcmF2ZVwiKTticmVhaztjYXNlIHA6IXRoaXMuZ2V0KGspJiZPJiZPW1NdJiZ0aGlzLnNldChrLFMpLFwiTWFjaW50b3NoXCI9PXRoaXMuZ2V0KFQpJiZBJiZ0eXBlb2YgQS5zdGFuZGFsb25lIT09biYmQS5tYXhUb3VjaFBvaW50cyYmMjxBLm1heFRvdWNoUG9pbnRzJiZ0aGlzLnNldChULFwiaVBhZFwiKS5zZXQoayxyKTticmVhaztjYXNlIGY6IXRoaXMuZ2V0KHYpJiZPJiZPW3FdJiZ0aGlzLnNldCh2LE9bcV0pO2JyZWFrO2Nhc2UgZzp2YXIgZT10aGlzLmRhdGEsaT1mdW5jdGlvbihpKXtyZXR1cm4gZVtpXS5nZXRJdGVtKCkuZGV0ZWN0RmVhdHVyZSgpLmdldCgpfTt0aGlzLnNldCh1LGkodSkpLnNldChoLGkoaCkpLnNldChwLGkocCkpLnNldChtLGkobSkpLnNldChmLGkoZikpfXJldHVybiB0aGlzfSx0aGlzLnBhcnNlVUE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtVHlwZSE9ZyYmamkuY2FsbCh0aGlzLmRhdGEsdGhpcy51YSx0aGlzLnJneE1hcCksdGhpcy5pdGVtVHlwZT09dSYmdGhpcy5zZXQoQix6aSh0aGlzLmdldCh5KSkpLHRoaXN9LHRoaXMucGFyc2VDSD1mdW5jdGlvbigpe3ZhciBpLGU9dGhpcy51YUNILHQ9dGhpcy5yZ3hNYXA7c3dpdGNoKHRoaXMuaXRlbVR5cGUpe2Nhc2UgdTpjYXNlIG06dmFyIG8scj1lW1hdfHxlW1ddO2lmKHIpZm9yKHZhciBhIGluIHIpe3ZhciBzPXJbYV0uYnJhbmR8fHJbYV0sYT1yW2FdLnZlcnNpb247dGhpcy5pdGVtVHlwZSE9dXx8L25vdC5hLmJyYW5kL2kudGVzdChzKXx8byYmKCEvY2hyb20vaS50ZXN0KG8pfHxzPT12aSl8fChzPUUocyx7Q2hyb21lOlwiR29vZ2xlIENocm9tZVwiLEVkZ2U6XCJNaWNyb3NvZnQgRWRnZVwiLFwiQ2hyb21lIFdlYlZpZXdcIjpcIkFuZHJvaWQgV2ViVmlld1wiLFwiQ2hyb21lIEhlYWRsZXNzXCI6XCJIZWFkbGVzc0Nocm9tZVwifSksdGhpcy5zZXQodixzKS5zZXQoeSxhKS5zZXQoQix6aShhKSksbz1zKSx0aGlzLml0ZW1UeXBlPT1tJiZzPT12aSYmdGhpcy5zZXQoeSxhKX1icmVhaztjYXNlIGg6dmFyIG49ZVtDXTtuJiYoXCI2NFwiPT1lW1FdJiYobis9XCI2NFwiKSxqaS5jYWxsKHRoaXMuZGF0YSxuK1wiO1wiLHQpKTticmVhaztjYXNlIHA6aWYoZVtTXSYmdGhpcy5zZXQoayxTKSxlW1RdJiYodGhpcy5zZXQoVCxlW1RdKSx0aGlzLmdldChrKSYmdGhpcy5nZXQoeCl8fChqaS5jYWxsKG49e30sXCJkcm9pZCA5OyBcIitlW1RdK1wiKVwiLHQpLCF0aGlzLmdldChrKSYmbi50eXBlJiZ0aGlzLnNldChrLG4udHlwZSksIXRoaXMuZ2V0KHgpJiZuLnZlbmRvciYmdGhpcy5zZXQoeCxuLnZlbmRvcikpKSxlW19dKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZVtfXSlmb3IodmFyIHc9MDshaSYmdzxlW19dLmxlbmd0aDspaT1FKGVbX11bdysrXSxFaSk7ZWxzZSBpPUUoZVtfXSxFaSk7dGhpcy5zZXQoayxpKX1icmVhaztjYXNlIGY6dmFyIGIsbj1lW3FdO24mJihiPWVbS10sbj09Q2kmJihiPTEzPD1wYXJzZUludCh6aShiKSwxMCk/XCIxMVwiOlwiMTBcIiksdGhpcy5zZXQodixuKS5zZXQoeSxiKSksdGhpcy5nZXQodik9PUNpJiZcIlhib3hcIj09ZVtUXSYmdGhpcy5zZXQodixcIlhib3hcIikuc2V0KHksbCk7YnJlYWs7Y2FzZSBnOnZhciBkPXRoaXMuZGF0YSxuPWZ1bmN0aW9uKGkpe3JldHVybiBkW2ldLmdldEl0ZW0oKS5zZXRDSChlKS5wYXJzZUNIKCkuZ2V0KCl9O3RoaXMuc2V0KHUsbih1KSkuc2V0KGgsbihoKSkuc2V0KHAsbihwKSkuc2V0KG0sbihtKSkuc2V0KGYsbihmKSl9cmV0dXJuIHRoaXN9LE4uY2FsbCh0aGlzLFtbXCJpdGVtVHlwZVwiLGldLFtcInVhXCIsZV0sW1widWFDSFwiLG9dLFtcInJneE1hcFwiLHRdLFtcImRhdGFcIixNaSh0aGlzLGkpXV0pLHRoaXN9ZnVuY3Rpb24gUChpLGUsdCl7dmFyIG8scixhLHMsbjtyZXR1cm4gdHlwZW9mIGk9PT1jPyhlPV9pKGksITApPyh0eXBlb2YgZT09PWMmJih0PWUpLGkpOih0PWksbCksaT1sKTp0eXBlb2YgaSE9PUx8fF9pKGUsITApfHwodD1lLGU9bCksdCYmdHlwZW9mIHQuYXBwZW5kPT09ViYmKG89e30sdC5mb3JFYWNoKGZ1bmN0aW9uKGksZSl7b1tlXT1pfSksdD1vKSx0aGlzIGluc3RhbmNlb2YgUD8ocj10eXBlb2YgaT09PUw/aTp0JiZ0W1VdP3RbVV06QSYmQS51c2VyQWdlbnQ/QS51c2VyQWdlbnQ6dyxhPW5ldyBVaSh0LCEwKSxzPWU/KChpLGUpPT57dmFyIHQsbz17fSxyPWU7aWYoIV9pKGUpKWZvcih2YXIgYSBpbiByPXt9LGUpZm9yKHZhciBzIGluIGVbYV0pcltzXT1lW2FdW3NdLmNvbmNhdChyW3NdfHxbXSk7Zm9yKHQgaW4gaSlvW3RdPXJbdF0mJnJbdF0ubGVuZ3RoJTI9PTA/clt0XS5jb25jYXQoaVt0XSk6aVt0XTtyZXR1cm4gb30pKFBpLGUpOlBpLE4uY2FsbCh0aGlzLFtbXCJnZXRCcm93c2VyXCIsKG49ZnVuY3Rpb24oaSl7cmV0dXJuIGk9PWc/ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFJpKGkscixzLGEpLnNldChcInVhXCIscikuc2V0KHUsdGhpcy5nZXRCcm93c2VyKCkpLnNldChoLHRoaXMuZ2V0Q1BVKCkpLnNldChwLHRoaXMuZ2V0RGV2aWNlKCkpLnNldChtLHRoaXMuZ2V0RW5naW5lKCkpLnNldChmLHRoaXMuZ2V0T1MoKSkuZ2V0KCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBSaShpLHIsc1tpXSxhKS5wYXJzZVVBKCkuZ2V0KCl9fSkodSldLFtcImdldENQVVwiLG4oaCldLFtcImdldERldmljZVwiLG4ocCldLFtcImdldEVuZ2luZVwiLG4obSldLFtcImdldE9TXCIsbihmKV0sW1wiZ2V0UmVzdWx0XCIsbihnKV0sW1wiZ2V0VUFcIixmdW5jdGlvbigpe3JldHVybiByfV0sW1wic2V0VUFcIixmdW5jdGlvbihpKXtyZXR1cm4gSChpKSYmKHI9aS5sZW5ndGg+TT9IaShpLE0pOmkpLHRoaXN9XV0pLnNldFVBKHIpLHRoaXMpOm5ldyBQKGksZSx0KS5nZXRSZXN1bHQoKX1QLlZFUlNJT049XCIyLjAuMVwiLFAuQlJPV1NFUj1JKFt2LHksQixrXSksUC5DUFU9SShbQ10pLFAuREVWSUNFPUkoW1QseCxrLEcsUyxlLHIsdCxEXSksUC5FTkdJTkU9UC5PUz1JKFt2LHldKSx0eXBlb2YgZXhwb3J0cyE9PW4/KGV4cG9ydHM9dHlwZW9mIG1vZHVsZSE9PW4mJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPVA6ZXhwb3J0cykuVUFQYXJzZXI9UDp0eXBlb2YgZGVmaW5lPT09ViYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gUH0pOlRpJiYoaS5VQVBhcnNlcj1QKTt2YXIgVmksTGk9VGkmJihpLmpRdWVyeXx8aS5aZXB0byk7TGkmJiFMaS51YSYmKFZpPW5ldyBQLExpLnVhPVZpLmdldFJlc3VsdCgpLExpLnVhLmdldD1mdW5jdGlvbigpe3JldHVybiBWaS5nZXRVQSgpfSxMaS51YS5zZXQ9ZnVuY3Rpb24oaSl7Vmkuc2V0VUEoaSk7dmFyIGUsdD1WaS5nZXRSZXN1bHQoKTtmb3IoZSBpbiB0KUxpLnVhW2VdPXRbZV19KX0pKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMpOyIsIi8vaW5kZXguanNcclxuY29uc3QgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50JylcclxuY29uc3QgbWVkaWFzb3VwQ2xpZW50ID0gcmVxdWlyZSgnbWVkaWFzb3VwLWNsaWVudCcpXHJcblxyXG5jb25zdCBzb2NrZXQgPSBpbyhcIi9tZWRpYXNvdXBcIilcclxuXHJcbnNvY2tldC5vbignY29ubmVjdGlvbi1zdWNjZXNzJywgKHsgc29ja2V0SWQgfSkgPT4ge1xyXG4gIGNvbnNvbGUubG9nKHNvY2tldElkKVxyXG59KVxyXG5cclxubGV0IGRldmljZVxyXG5sZXQgcnRwQ2FwYWJpbGl0aWVzXHJcbmxldCBwcm9kdWNlclRyYW5zcG9ydFxyXG5sZXQgY29uc3VtZXJUcmFuc3BvcnRcclxubGV0IHByb2R1Y2VyXHJcbmxldCBjb25zdW1lclxyXG5cclxuLy8gaHR0cHM6Ly9tZWRpYXNvdXAub3JnL2RvY3VtZW50YXRpb24vdjMvbWVkaWFzb3VwLWNsaWVudC9hcGkvI1Byb2R1Y2VyT3B0aW9uc1xyXG4vLyBodHRwczovL21lZGlhc291cC5vcmcvZG9jdW1lbnRhdGlvbi92My9tZWRpYXNvdXAtY2xpZW50L2FwaS8jdHJhbnNwb3J0LXByb2R1Y2VcclxubGV0IHBhcmFtcyA9IHtcclxuICAvLyBtZWRpYXNvdXAgcGFyYW1zXHJcbiAgZW5jb2RpbmdzOiBbXHJcbiAgICB7XHJcbiAgICAgIHJpZDogJ3IwJyxcclxuICAgICAgbWF4Qml0cmF0ZTogMTAwMDAwLFxyXG4gICAgICBzY2FsYWJpbGl0eU1vZGU6ICdTMVQzJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHJpZDogJ3IxJyxcclxuICAgICAgbWF4Qml0cmF0ZTogMzAwMDAwLFxyXG4gICAgICBzY2FsYWJpbGl0eU1vZGU6ICdTMVQzJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHJpZDogJ3IyJyxcclxuICAgICAgbWF4Qml0cmF0ZTogOTAwMDAwLFxyXG4gICAgICBzY2FsYWJpbGl0eU1vZGU6ICdTMVQzJyxcclxuICAgIH0sXHJcbiAgXSxcclxuICAvLyBodHRwczovL21lZGlhc291cC5vcmcvZG9jdW1lbnRhdGlvbi92My9tZWRpYXNvdXAtY2xpZW50L2FwaS8jUHJvZHVjZXJDb2RlY09wdGlvbnNcclxuICBjb2RlY09wdGlvbnM6IHtcclxuICAgIHZpZGVvR29vZ2xlU3RhcnRCaXRyYXRlOiAxMDAwXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBzdHJlYW1TdWNjZXNzID0gYXN5bmMgKHN0cmVhbSkgPT4ge1xyXG4gIGxvY2FsVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtXHJcbiAgY29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXVxyXG4gIHBhcmFtcyA9IHtcclxuICAgIHRyYWNrLFxyXG4gICAgLi4ucGFyYW1zXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBnZXRMb2NhbFN0cmVhbSA9ICgpID0+IHtcclxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKHtcclxuICAgIGF1ZGlvOiBmYWxzZSxcclxuICAgIHZpZGVvOiB7XHJcbiAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgbWluOiA2NDAsXHJcbiAgICAgICAgbWF4OiAxOTIwLFxyXG4gICAgICB9LFxyXG4gICAgICBoZWlnaHQ6IHtcclxuICAgICAgICBtaW46IDQwMCxcclxuICAgICAgICBtYXg6IDEwODAsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBzdHJlYW1TdWNjZXNzLCBlcnJvciA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhlcnJvci5tZXNzYWdlKVxyXG4gIH0pXHJcbn1cclxuXHJcbi8vIEEgZGV2aWNlIGlzIGFuIGVuZHBvaW50IGNvbm5lY3RpbmcgdG8gYSBSb3V0ZXIgb24gdGhlIFxyXG4vLyBzZXJ2ZXIgc2lkZSB0byBzZW5kL3JlY2l2ZSBtZWRpYVxyXG5jb25zdCBjcmVhdGVEZXZpY2UgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGRldmljZSA9IG5ldyBtZWRpYXNvdXBDbGllbnQuRGV2aWNlKClcclxuXHJcbiAgICAvLyBodHRwczovL21lZGlhc291cC5vcmcvZG9jdW1lbnRhdGlvbi92My9tZWRpYXNvdXAtY2xpZW50L2FwaS8jZGV2aWNlLWxvYWRcclxuICAgIC8vIExvYWRzIHRoZSBkZXZpY2Ugd2l0aCBSVFAgY2FwYWJpbGl0aWVzIG9mIHRoZSBSb3V0ZXIgKHNlcnZlciBzaWRlKVxyXG4gICAgYXdhaXQgZGV2aWNlLmxvYWQoe1xyXG4gICAgICAvLyBzZWUgZ2V0UnRwQ2FwYWJpbGl0aWVzKCkgYmVsb3dcclxuICAgICAgcm91dGVyUnRwQ2FwYWJpbGl0aWVzOiBydHBDYXBhYmlsaXRpZXNcclxuICAgIH0pXHJcblxyXG4gICAgY29uc29sZS5sb2coJ1JUUCBDYXBhYmlsaXRpZXMnLCBkZXZpY2UucnRwQ2FwYWJpbGl0aWVzKVxyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5sb2coZXJyb3IpXHJcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1Vuc3VwcG9ydGVkRXJyb3InKVxyXG4gICAgICBjb25zb2xlLndhcm4oJ2Jyb3dzZXIgbm90IHN1cHBvcnRlZCcpXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBnZXRSdHBDYXBhYmlsaXRpZXMgPSAoKSA9PiB7XHJcbiAgLy8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciBmb3IgUm91dGVyIFJUUCBDYXBhYmlsaXRpZXNcclxuICAvLyBzZWUgc2VydmVyJ3Mgc29ja2V0Lm9uKCdnZXRSdHBDYXBhYmlsaXRpZXMnLCAuLi4pXHJcbiAgLy8gdGhlIHNlcnZlciBzZW5kcyBiYWNrIGRhdGEgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHJ0cENhcGFiaWxpdGllc1xyXG4gIHNvY2tldC5lbWl0KCdnZXRSdHBDYXBhYmlsaXRpZXMnLCAoZGF0YSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coYFJvdXRlciBSVFAgQ2FwYWJpbGl0aWVzLi4uICR7ZGF0YS5ydHBDYXBhYmlsaXRpZXN9YClcclxuXHJcbiAgICAvLyB3ZSBhc3NpZ24gdG8gbG9jYWwgdmFyaWFibGUgYW5kIHdpbGwgYmUgdXNlZCB3aGVuXHJcbiAgICAvLyBsb2FkaW5nIHRoZSBjbGllbnQgRGV2aWNlIChzZWUgY3JlYXRlRGV2aWNlIGFib3ZlKVxyXG4gICAgcnRwQ2FwYWJpbGl0aWVzID0gZGF0YS5ydHBDYXBhYmlsaXRpZXNcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBjcmVhdGVTZW5kVHJhbnNwb3J0ID0gKCkgPT4ge1xyXG4gIC8vIHNlZSBzZXJ2ZXIncyBzb2NrZXQub24oJ2NyZWF0ZVdlYlJ0Y1RyYW5zcG9ydCcsIHNlbmRlcj8sIC4uLilcclxuICAvLyB0aGlzIGlzIGEgY2FsbCBmcm9tIFByb2R1Y2VyLCBzbyBzZW5kZXIgPSB0cnVlXHJcbiAgc29ja2V0LmVtaXQoJ2NyZWF0ZVdlYlJ0Y1RyYW5zcG9ydCcsIHsgc2VuZGVyOiB0cnVlIH0sICh7IHBhcmFtcyB9KSA9PiB7XHJcbiAgICAvLyBUaGUgc2VydmVyIHNlbmRzIGJhY2sgcGFyYW1zIG5lZWRlZCBcclxuICAgIC8vIHRvIGNyZWF0ZSBTZW5kIFRyYW5zcG9ydCBvbiB0aGUgY2xpZW50IHNpZGVcclxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2cocGFyYW1zLmVycm9yKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhwYXJhbXMpXHJcblxyXG4gICAgLy8gY3JlYXRlcyBhIG5ldyBXZWJSVEMgVHJhbnNwb3J0IHRvIHNlbmQgbWVkaWFcclxuICAgIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXIncyBwcm9kdWNlciB0cmFuc3BvcnQgcGFyYW1zXHJcbiAgICAvLyBodHRwczovL21lZGlhc291cC5vcmcvZG9jdW1lbnRhdGlvbi92My9tZWRpYXNvdXAtY2xpZW50L2FwaS8jVHJhbnNwb3J0T3B0aW9uc1xyXG4gICAgcHJvZHVjZXJUcmFuc3BvcnQgPSBkZXZpY2UuY3JlYXRlU2VuZFRyYW5zcG9ydChwYXJhbXMpXHJcblxyXG4gICAgLy8gaHR0cHM6Ly9tZWRpYXNvdXAub3JnL2RvY3VtZW50YXRpb24vdjMvY29tbXVuaWNhdGlvbi1iZXR3ZWVuLWNsaWVudC1hbmQtc2VydmVyLyNwcm9kdWNpbmctbWVkaWFcclxuICAgIC8vIHRoaXMgZXZlbnQgaXMgcmFpc2VkIHdoZW4gYSBmaXJzdCBjYWxsIHRvIHRyYW5zcG9ydC5wcm9kdWNlKCkgaXMgbWFkZVxyXG4gICAgLy8gc2VlIGNvbm5lY3RTZW5kVHJhbnNwb3J0KCkgYmVsb3dcclxuICAgIHByb2R1Y2VyVHJhbnNwb3J0Lm9uKCdjb25uZWN0JywgYXN5bmMgKHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBTaWduYWwgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzIHRvIHRoZSBzZXJ2ZXIgc2lkZSB0cmFuc3BvcnRcclxuICAgICAgICAvLyBzZWUgc2VydmVyJ3Mgc29ja2V0Lm9uKCd0cmFuc3BvcnQtY29ubmVjdCcsIC4uLilcclxuICAgICAgICBhd2FpdCBzb2NrZXQuZW1pdCgndHJhbnNwb3J0LWNvbm5lY3QnLCB7XHJcbiAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBUZWxsIHRoZSB0cmFuc3BvcnQgdGhhdCBwYXJhbWV0ZXJzIHdlcmUgdHJhbnNtaXR0ZWQuXHJcbiAgICAgICAgY2FsbGJhY2soKVxyXG5cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBlcnJiYWNrKGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIHByb2R1Y2VyVHJhbnNwb3J0Lm9uKCdwcm9kdWNlJywgYXN5bmMgKHBhcmFtZXRlcnMsIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKHBhcmFtZXRlcnMpXHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIHRlbGwgdGhlIHNlcnZlciB0byBjcmVhdGUgYSBQcm9kdWNlclxyXG4gICAgICAgIC8vIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIGFuZCBwcm9kdWNlXHJcbiAgICAgICAgLy8gYW5kIGV4cGVjdCBiYWNrIGEgc2VydmVyIHNpZGUgcHJvZHVjZXIgaWRcclxuICAgICAgICAvLyBzZWUgc2VydmVyJ3Mgc29ja2V0Lm9uKCd0cmFuc3BvcnQtcHJvZHVjZScsIC4uLilcclxuICAgICAgICBhd2FpdCBzb2NrZXQuZW1pdCgndHJhbnNwb3J0LXByb2R1Y2UnLCB7XHJcbiAgICAgICAgICBraW5kOiBwYXJhbWV0ZXJzLmtpbmQsXHJcbiAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLnJ0cFBhcmFtZXRlcnMsXHJcbiAgICAgICAgICBhcHBEYXRhOiBwYXJhbWV0ZXJzLmFwcERhdGEsXHJcbiAgICAgICAgfSwgKHsgaWQgfSkgPT4ge1xyXG4gICAgICAgICAgLy8gVGVsbCB0aGUgdHJhbnNwb3J0IHRoYXQgcGFyYW1ldGVycyB3ZXJlIHRyYW5zbWl0dGVkIGFuZCBwcm92aWRlIGl0IHdpdGggdGhlXHJcbiAgICAgICAgICAvLyBzZXJ2ZXIgc2lkZSBwcm9kdWNlcidzIGlkLlxyXG4gICAgICAgICAgY2FsbGJhY2soeyBpZCB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgZXJyYmFjayhlcnJvcilcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBjb25uZWN0U2VuZFRyYW5zcG9ydCA9IGFzeW5jICgpID0+IHtcclxuICAvLyB3ZSBub3cgY2FsbCBwcm9kdWNlKCkgdG8gaW5zdHJ1Y3QgdGhlIHByb2R1Y2VyIHRyYW5zcG9ydFxyXG4gIC8vIHRvIHNlbmQgbWVkaWEgdG8gdGhlIFJvdXRlclxyXG4gIC8vIGh0dHBzOi8vbWVkaWFzb3VwLm9yZy9kb2N1bWVudGF0aW9uL3YzL21lZGlhc291cC1jbGllbnQvYXBpLyN0cmFuc3BvcnQtcHJvZHVjZVxyXG4gIC8vIHRoaXMgYWN0aW9uIHdpbGwgdHJpZ2dlciB0aGUgJ2Nvbm5lY3QnIGFuZCAncHJvZHVjZScgZXZlbnRzIGFib3ZlXHJcbiAgcHJvZHVjZXIgPSBhd2FpdCBwcm9kdWNlclRyYW5zcG9ydC5wcm9kdWNlKHBhcmFtcylcclxuXHJcbiAgcHJvZHVjZXIub24oJ3RyYWNrZW5kZWQnLCAoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygndHJhY2sgZW5kZWQnKVxyXG5cclxuICAgIC8vIGNsb3NlIHZpZGVvIHRyYWNrXHJcbiAgfSlcclxuXHJcbiAgcHJvZHVjZXIub24oJ3RyYW5zcG9ydGNsb3NlJywgKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ3RyYW5zcG9ydCBlbmRlZCcpXHJcblxyXG4gICAgLy8gY2xvc2UgdmlkZW8gdHJhY2tcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBjcmVhdGVSZWN2VHJhbnNwb3J0ID0gYXN5bmMgKCkgPT4ge1xyXG4gIC8vIHNlZSBzZXJ2ZXIncyBzb2NrZXQub24oJ2NvbnN1bWUnLCBzZW5kZXI/LCAuLi4pXHJcbiAgLy8gdGhpcyBpcyBhIGNhbGwgZnJvbSBDb25zdW1lciwgc28gc2VuZGVyID0gZmFsc2VcclxuICBhd2FpdCBzb2NrZXQuZW1pdCgnY3JlYXRlV2ViUnRjVHJhbnNwb3J0JywgeyBzZW5kZXI6IGZhbHNlIH0sICh7IHBhcmFtcyB9KSA9PiB7XHJcbiAgICAvLyBUaGUgc2VydmVyIHNlbmRzIGJhY2sgcGFyYW1zIG5lZWRlZCBcclxuICAgIC8vIHRvIGNyZWF0ZSBTZW5kIFRyYW5zcG9ydCBvbiB0aGUgY2xpZW50IHNpZGVcclxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2cocGFyYW1zLmVycm9yKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhwYXJhbXMpXHJcblxyXG4gICAgLy8gY3JlYXRlcyBhIG5ldyBXZWJSVEMgVHJhbnNwb3J0IHRvIHJlY2VpdmUgbWVkaWFcclxuICAgIC8vIGJhc2VkIG9uIHNlcnZlcidzIGNvbnN1bWVyIHRyYW5zcG9ydCBwYXJhbXNcclxuICAgIC8vIGh0dHBzOi8vbWVkaWFzb3VwLm9yZy9kb2N1bWVudGF0aW9uL3YzL21lZGlhc291cC1jbGllbnQvYXBpLyNkZXZpY2UtY3JlYXRlUmVjdlRyYW5zcG9ydFxyXG4gICAgY29uc3VtZXJUcmFuc3BvcnQgPSBkZXZpY2UuY3JlYXRlUmVjdlRyYW5zcG9ydChwYXJhbXMpXHJcblxyXG4gICAgLy8gaHR0cHM6Ly9tZWRpYXNvdXAub3JnL2RvY3VtZW50YXRpb24vdjMvY29tbXVuaWNhdGlvbi1iZXR3ZWVuLWNsaWVudC1hbmQtc2VydmVyLyNwcm9kdWNpbmctbWVkaWFcclxuICAgIC8vIHRoaXMgZXZlbnQgaXMgcmFpc2VkIHdoZW4gYSBmaXJzdCBjYWxsIHRvIHRyYW5zcG9ydC5wcm9kdWNlKCkgaXMgbWFkZVxyXG4gICAgLy8gc2VlIGNvbm5lY3RSZWN2VHJhbnNwb3J0KCkgYmVsb3dcclxuICAgIGNvbnN1bWVyVHJhbnNwb3J0Lm9uKCdjb25uZWN0JywgYXN5bmMgKHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBTaWduYWwgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzIHRvIHRoZSBzZXJ2ZXIgc2lkZSB0cmFuc3BvcnRcclxuICAgICAgICAvLyBzZWUgc2VydmVyJ3Mgc29ja2V0Lm9uKCd0cmFuc3BvcnQtcmVjdi1jb25uZWN0JywgLi4uKVxyXG4gICAgICAgIGF3YWl0IHNvY2tldC5lbWl0KCd0cmFuc3BvcnQtcmVjdi1jb25uZWN0Jywge1xyXG4gICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gVGVsbCB0aGUgdHJhbnNwb3J0IHRoYXQgcGFyYW1ldGVycyB3ZXJlIHRyYW5zbWl0dGVkLlxyXG4gICAgICAgIGNhbGxiYWNrKClcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAvLyBUZWxsIHRoZSB0cmFuc3BvcnQgdGhhdCBzb21ldGhpbmcgd2FzIHdyb25nXHJcbiAgICAgICAgZXJyYmFjayhlcnJvcilcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBjb25uZWN0UmVjdlRyYW5zcG9ydCA9IGFzeW5jICgpID0+IHtcclxuICAvLyBmb3IgY29uc3VtZXIsIHdlIG5lZWQgdG8gdGVsbCB0aGUgc2VydmVyIGZpcnN0XHJcbiAgLy8gdG8gY3JlYXRlIGEgY29uc3VtZXIgYmFzZWQgb24gdGhlIHJ0cENhcGFiaWxpdGllcyBhbmQgY29uc3VtZVxyXG4gIC8vIGlmIHRoZSByb3V0ZXIgY2FuIGNvbnN1bWUsIGl0IHdpbGwgc2VuZCBiYWNrIGEgc2V0IG9mIHBhcmFtcyBhcyBiZWxvd1xyXG4gIGF3YWl0IHNvY2tldC5lbWl0KCdjb25zdW1lJywge1xyXG4gICAgcnRwQ2FwYWJpbGl0aWVzOiBkZXZpY2UucnRwQ2FwYWJpbGl0aWVzLFxyXG4gIH0sIGFzeW5jICh7IHBhcmFtcyB9KSA9PiB7XHJcbiAgICBpZiAocGFyYW1zLmVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDYW5ub3QgQ29uc3VtZScpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKHBhcmFtcylcclxuICAgIC8vIHRoZW4gY29uc3VtZSB3aXRoIHRoZSBsb2NhbCBjb25zdW1lciB0cmFuc3BvcnRcclxuICAgIC8vIHdoaWNoIGNyZWF0ZXMgYSBjb25zdW1lclxyXG4gICAgY29uc3VtZXIgPSBhd2FpdCBjb25zdW1lclRyYW5zcG9ydC5jb25zdW1lKHtcclxuICAgICAgaWQ6IHBhcmFtcy5pZCxcclxuICAgICAgcHJvZHVjZXJJZDogcGFyYW1zLnByb2R1Y2VySWQsXHJcbiAgICAgIGtpbmQ6IHBhcmFtcy5raW5kLFxyXG4gICAgICBydHBQYXJhbWV0ZXJzOiBwYXJhbXMucnRwUGFyYW1ldGVyc1xyXG4gICAgfSlcclxuXHJcbiAgICAvLyBkZXN0cnVjdHVyZSBhbmQgcmV0cmlldmUgdGhlIHZpZGVvIHRyYWNrIGZyb20gdGhlIHByb2R1Y2VyXHJcbiAgICBjb25zdCB7IHRyYWNrIH0gPSBjb25zdW1lclxyXG5cclxuICAgIHJlbW90ZVZpZGVvLnNyY09iamVjdCA9IG5ldyBNZWRpYVN0cmVhbShbdHJhY2tdKVxyXG5cclxuICAgIC8vIHRoZSBzZXJ2ZXIgY29uc3VtZXIgc3RhcnRlZCB3aXRoIG1lZGlhIHBhdXNlZFxyXG4gICAgLy8gc28gd2UgbmVlZCB0byBpbmZvcm0gdGhlIHNlcnZlciB0byByZXN1bWVcclxuICAgIHNvY2tldC5lbWl0KCdjb25zdW1lci1yZXN1bWUnKVxyXG4gIH0pXHJcbn1cclxuXHJcbmJ0bkxvY2FsVmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZXRMb2NhbFN0cmVhbSlcclxuYnRuUnRwQ2FwYWJpbGl0aWVzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZ2V0UnRwQ2FwYWJpbGl0aWVzKVxyXG5idG5EZXZpY2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjcmVhdGVEZXZpY2UpXHJcbmJ0bkNyZWF0ZVNlbmRUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjcmVhdGVTZW5kVHJhbnNwb3J0KVxyXG5idG5Db25uZWN0U2VuZFRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNvbm5lY3RTZW5kVHJhbnNwb3J0KVxyXG5idG5SZWN2U2VuZFRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNyZWF0ZVJlY3ZUcmFuc3BvcnQpXHJcbmJ0bkNvbm5lY3RSZWN2VHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY29ubmVjdFJlY3ZUcmFuc3BvcnQpIl19
